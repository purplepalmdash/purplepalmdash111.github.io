
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dash</title>
  <meta name="author" content="Dash">

  
  <meta name="description" content="1. 汇编程序代码格式 汇编代码由一系列的声明所组成，每行一个。每条声明由下列格式组成： 1
label(标签): instruction @comment(注释) 说明： label:
标签的引入使得在内存中查询指令地址变得很方便，标签可以在任意一个内存地址使用，
例如分支指令中就可以用到标签 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://purplepalmdash.github.io/posts/54">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/purplepalmdash/atom.xml" rel="alternate" title="Dash" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Dash</a></h1>
  
    <h2>Get busy living, or get busy dying.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/purplepalmdash/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:purplepalmdash.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/">用Qemu和GNU编译链研究ARM汇编(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-09T20:42:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:42 pm</span></time>
        
         | <a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 汇编程序代码格式</p>

<p>汇编代码由一系列的声明所组成，每行一个。每条声明由下列格式组成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>label(标签):   instruction @comment(注释)</span></code></pre></td></tr></table></div></figure>


<p>说明：</p>

<ul>
<li>label:
标签的引入使得在内存中查询指令地址变得很方便，标签可以在任意一个内存地址使用，
例如分支指令中就可以用到标签, 标签可以包括字母、数字_和$符号。</li>
<li>注释：
注释内容必须在@符号之后</li>
<li>指令:
指令可以是ARM指令集或是汇编器指令，汇编器指令是需要传递给汇编器的命令，总是以.开头。</li>
</ul>


<p>2. 一个简单的汇编语言文件:</p>

<figure class='code'><figcaption><span>add.s -add.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>                       <span class="o">@</span> Label<span class="p">,</span> not really required
</span><span class='line'>        mov   r0<span class="p">,</span> <span class="c1">#5         @ Load register r0 with the value 5</span>
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#4         @ Load register r1 with the value 4</span>
</span><span class='line'>        add   r2<span class="p">,</span> r1<span class="p">,</span> r0     <span class="o">@</span> Add r0 and r1 and store <span class="kr">in</span> r2
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b stop               <span class="o">@</span> Infinite loop to stop execution
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的意思是，把立即数5载入到寄存器r0, 4载入到r1,
以r1和r0相加的结果填充r2.</p>

<p>.text是汇编器指令，用于告知汇编器需要把代码组装到code段,而不是.data段。有关section的概念在后面将被讲到。</p>

<p>3. 编译二进制文件</p>

<p>GNU的汇编器名字叫as， 用下列命令将源文件编译成.o文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o add.o add.s</span></code></pre></td></tr></table></div></figure>


<p>链接器的名字叫ld，用下列命令可以将二进制文件链接成elf文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o</span></code></pre></td></tr></table></div></figure>


<p>-Ttext指明需要分配给label的地址,
这条指令告诉链接器从地址0x0开始装载指令。我们可以用nm来查看具体的地址分配信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm add.elf 
</span><span class='line'>00008010 T __bss_end__
</span><span class='line'>00008010 T _bss_end__
</span><span class='line'>00008010 T __bss_start
</span><span class='line'>00008010 T __bss_start__
</span><span class='line'>00008010 T __data_start
</span><span class='line'>00008010 T _edata
</span><span class='line'>00008010 T _end
</span><span class='line'>00008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000000 t start
</span><span class='line'>         U _start
</span><span class='line'>0000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>start和stop之间由0c个字节，因为stop是在start开始后三条指令，
每条指令的长度为4个Byte，3*4=12=0xc</p>

<p>更改链接的参数将得到不同的地址分配。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 20000000
</span><span class='line'>$ arm-none-eabi-nm add.elf
</span><span class='line'>20008010 T __bss_end__
</span><span class='line'>20008010 T _bss_end__
</span><span class='line'>20008010 T __bss_start
</span><span class='line'>20008010 T __bss_start__
</span><span class='line'>20008010 T __data_start
</span><span class='line'>20008010 T _edata
</span><span class='line'>20008010 T _end
</span><span class='line'>20008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>20000000 t start
</span><span class='line'>         U _start
</span><span class='line'>2000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>ld得到的文件一般是ELF文件，在有操作系统的时候ELF可以工作的很好，但是我们将在裸机模式下(Bare
Metal)运行此程序， 因此需要将文件类型转化为更简单的binary类型。</p>

<p>GNU编译链的objcopy可以完成不同可执行文件之间的转换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary add.elf add.bin
</span><span class='line'>$ file add.bin
</span><span class='line'>add.bin: Hitachi SH big-endian COFF</span></code></pre></td></tr></table></div></figure>


<p>4. 在Qemu中执行二进制文件。</p>

<p>我们将使用connex开发板来模拟运行此程序，它把16MB的Flash放在地址0x0，而通常arm处理器重启时都会执行0x0处的代码。
因而我们需要把add.bin写入到16MB Flash文件的头部。</p>

<p>首先创建一个空的16MB Flash文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>4096+0 records in
</span><span class='line'>4096+0 records out
</span><span class='line'>16777216 bytes (17 MB) copied, 0.0153106 s, 1.1 GB/s</span></code></pre></td></tr></table></div></figure>


<p>而后，使用下列命令将add.bin放到Flash头部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'>0+1 records in
</span><span class='line'>0+1 records out
</span><span class='line'>16 bytes (16 B) copied, 0.00011154 s, 143 kB/s</span></code></pre></td></tr></table></div></figure>


<p>add.bin大小刚好为16B, notrunc参数代表no truncated，意思是直接覆盖掉原有内容。</p>

<p>用下列命令执行此改动后的flash文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information</span></code></pre></td></tr></table></div></figure>


<p>-M connex 指定connex机器， -pflash指定flash.bin代替flash闪存。</p>

<p>-pflash file    use &lsquo;file&rsquo; as a parallel flash image 并行flash镜像</p>

<p>-serial /dev/null 将connex的串口输出重定向到/dev/null</p>

<p>查看寄存器信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000005 R01=00000004 R02=00000009 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000000c
</span><span class='line'>PSR=400001d3 -Z-- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R02的值正是计算后的结果4+5=9.
R15=0000000c 猜测应该为指令寄存器，指向stop(0xc)</p>

<p>5. 更多的查看命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>help  List available commands
</span><span class='line'>quit   Quits the emulator
</span><span class='line'>xp /fmt addr   Physical memory dump from addr
</span><span class='line'>system_reset   Reset the system.</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) help xp
</span><span class='line'>xp /fmt addr -- physical memory dump starting at 'addr'
</span><span class='line'>(qemu) xp /4iw 0x0
</span><span class='line'>0x00000000:  e3a00005      mov    r0, #5  ; 0x5
</span><span class='line'>0x00000004:  e3a01004      mov    r1, #4  ; 0x4
</span><span class='line'>0x00000008:  e0812000      add    r2, r1, r0
</span><span class='line'>0x0000000c:  eafffffe      b  0xc</span></code></pre></td></tr></table></div></figure>


<p>4: 4 个条目被显示, i表示打印出指令，即内建的反汇编，
w表明条目的大小为32个bit，即一个全字。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/">在Qemu上运行Raspberry PI镜像</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T18:09:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:09 pm</span></time>
        
         | <a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载和准备镜像文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://downloads.raspberrypi.org/images/raspbian/2013-05-25-wheezy-raspbian/2013-05-25-wheezy-raspbian.zip
</span><span class='line'>$ unzip 2013-05-25-wheezy-raspbian.zip</span></code></pre></td></tr></table></div></figure>


<p>2. 查看镜像文件分区信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fdisk -l 2013-05-25-wheezy-raspbian.img 
</span><span class='line'>Disk 2013-05-25-wheezy-raspbian.img: 1939 MB, 1939865600 bytes, 3788800 sectors
</span><span class='line'>Units = sectors of 1 * 512 = 512 bytes
</span><span class='line'>Sector size (logical/physical): 512 bytes / 512 bytes
</span><span class='line'>I/O size (minimum/optimal): 512 bytes / 512 bytes
</span><span class='line'>Disk label type: dos
</span><span class='line'>Disk identifier: 0x000c7b31
</span><span class='line'>
</span><span class='line'>                         Device Boot      Start         End      Blocks   Id
</span><span class='line'>System
</span><span class='line'>2013-05-25-wheezy-raspbian.img1            8192      122879       57344    c  W95 FAT32 (LBA)
</span><span class='line'>2013-05-25-wheezy-raspbian.img2          122880     3788799     1832960   83  Linux</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看到，根文件分区的地址偏移为512*122880=62914560</p>

<p>3. 更改根分区文件里preload信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo mount ./2013-05-25-wheezy-raspbian.img -o offset=62914560 /mnt3
</span><span class='line'>$ sudo vim /mnt3/etc/ld.so.preload 
</span><span class='line'>#注释掉这一行，否则在qemu启动完系统后将自动提示配置rpi而造成系统无法登陆
</span><span class='line'>#/usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class='line'>$ sudo umount /mnt3</span></code></pre></td></tr></table></div></figure>


<p>4. 用qemu-system-arm启动raspberrypi镜像</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -kernel kernel-qemu -cpu arm1176 -m 256 -M versatilepb \
</span><span class='line'>-no-reboot -serial stdio -append "root=/dev/sda2 panic=1" -hda \
</span><span class='line'>./2013-05-25-wheezy-raspbian.img </span></code></pre></td></tr></table></div></figure>


<p>系统将启动到一个root登陆的无需密码的shell中，运行下列命令以修复文件系统:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fsck /dev/sda2
</span><span class='line'>$ shutdown -r now</span></code></pre></td></tr></table></div></figure>


<p>再次启动完毕后的登陆用户名和密码如下，接下来就等同于原机操作了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Login as pi
</span><span class='line'>Password raspberry</span></code></pre></td></tr></table></div></figure>


<p>5. ArchLinux on RaspberryPI</p>

<p>基本步骤也是一样，挂在第2块分区后，需要更改etc/fstab做下列修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;          &lt;dump&gt; &lt;pass&gt;
</span><span class='line'>/dev/sda1   /boot           vfat    defaults        0       0
</span><span class='line'>/dev/sda2   /     auto    defaults        0       0</span></code></pre></td></tr></table></div></figure>


<p>之后挂载命令一样。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/">用Qemu模拟ARM(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T16:35:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:35 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载并交叉编译u-boot。</p>

<p>新版本的u-boot我加载后总有问题，2009.11版则可以顺利通过编译和测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget ftp://ftp.denx.de/pub/u-boot/u-boot-2009.11.tar.bz2
</span><span class='line'>$ tar xjvf u-boot-2009.11.tar.bz2 
</span><span class='line'>$ cd u-boot-2009.11
</span><span class='line'>$ make versatilepb_config arch=ARM CROSS_COMPILE=arm-none-eabi-
</span><span class='line'>$ make all arch=ARM CROSS_COMPILE=arm-none-eabi- </span></code></pre></td></tr></table></div></figure>


<p>编译完成后会在目录下生成u-boot.bin和u-boot文件。</p>

<p>2. 运行u-boot.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel u-boot.bin -nographic</span></code></pre></td></tr></table></div></figure>


<p>如果采用-nographic来运行qemu-system-arm，终端将无法再响应任何系统输入譬如Ctrl+c/ctrl+d_，要终止qemu-system-arm就只能查到进程号再kill。所以我一般不带-nographic选项，启动后ctrl+alt+2去看serial0输出,保留在终端窗口直接ctrl+c杀死qemu-sytem-arm进程的权力。</p>

<p>3. 用u-boot引导镜像文件:</p>

<p>改动上一篇文章里用于构建启动镜像的linker.ld文件，因为u-boot.bin文件大小的缘故，我们需要把启动镜像的起始地址整体上移.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h u-boot.bin 
</span><span class='line'>-rwxr-xr-x 1 Trusty root 85K Jul  8 15:57 u-boot.bin</span></code></pre></td></tr></table></div></figure>


<p>linker.ld文件里， 0x100000，这个大小相比于85K显然已经足够。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>SECTIONS
</span><span class='line'>{
</span><span class='line'>. = 0x100000;
</span><span class='line'>startup : { startup.o(.text)}
</span><span class='line'>.data : {*(.data)}
</span><span class='line'>.bss : {*(.bss)}
</span><span class='line'>. = . + 0x500;
</span><span class='line'>sp_top = .;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>按上一章的编译方法生成output.bin，不再重述。</p>

<p>使用mkimage工具创建u-boot可识别的image文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkimage -A arm -C none -O linux -T kernel -d output.bin -a 0x00100000 -e 0x00100000 output.uimg
</span><span class='line'>Image Name:   
</span><span class='line'>Created:      Mon Jul  8 16:04:11 2013
</span><span class='line'>Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>Data Size:    152 Bytes = 0.15 kB = 0.00 MB
</span><span class='line'>Load Address: 00100000
</span><span class='line'>Entry Point:  00100000
</span><span class='line'>
</span><span class='line'>$ file *.uimg
</span><span class='line'>output.uimg: u-boot legacy uImage, , Linux/ARM, OS Kernel Image (Not \
</span><span class='line'>compressed), 152 bytes, Mon Jul  8 16:04:11 2013, Load Address: 0x00100000,\
</span><span class='line'>Entry Point: 0x00100000, Header CRC: 0x3C62F575, Data CRC: 0x69CE9647</span></code></pre></td></tr></table></div></figure>


<p>将u-boot.bin和output.uimg打包为一个文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat u-boot.bin output.uimg &gt;flash.bin</span></code></pre></td></tr></table></div></figure>


<p>下面这条命令用于计算output.img在使用u-boot加载完flash.bin后在内存中的地址，-kernel选项告诉qemu从0x100000开始加载镜像，即65536。
65536+u-boot.bin后的大小，即output.img在内存中的地址。printf则是用16进制的格式打印出来，以便加载.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ printf "0x%X" $(expr $(stat -c%s u-boot.bin) + 65536)
</span><span class='line'>0x2525C</span></code></pre></td></tr></table></div></figure>


<p>启动qemu-system-arm并运行自定义镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel flash.bin
</span><span class='line'># iminfo 0x2525c
</span><span class='line'>
</span><span class='line'>## Checking Image at 0002525c ...
</span><span class='line'>   Legacy image found
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Verifying Checksum ... OK
</span><span class='line'>
</span><span class='line'>VersatilePB # bootm 0x2525c
</span><span class='line'>## Booting kernel from Legacy Image at 0002525c ...
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Loading Kernel Image ... OK
</span><span class='line'>OK
</span><span class='line'>
</span><span class='line'>Starting kernel ...
</span><span class='line'>
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>u-boot可以支持的选项还有很多，包括使用NFS/TFTP启动等等，留待以后慢慢研究。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-2/">用Qemu模拟ARM(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T15:18:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>3:18 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 关于Bootloader:</p>

<p>(引导程序)位于电脑或其他计算机应用上，是指引导操作系统启动的程序。引导程序启动方式和程序视应用机型种类而不同。例如在普通的个人电脑上，引导程序通常分为两部分：第一阶段引导程序位于主引导记录（MBR），用以引导位于某个分区上的第二阶段引导程序，如NTLDR、GNU
GRUB等。</p>

<p> 嵌入式系统中常见的Bootloader主要有以下几种:</p>

<ul>
<li>Das U-Boot
是一个主要用于嵌入式系统的开机载入程序，可以支持多种不同的计算机系统结构，包括PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。</li>
<li>vivi是由mizi公司设计为ARM处理器系列设计的一个bootloader.</li>
<li>Redboot (Red Hat Embedded Debug and Bootstrap)是Red
Hat公司开发的一个独立运行在嵌入式系统上的BootLoader程序，是目前比较流行的一个功能、可移植性好的BootLoader。</li>
</ul>


<p>2. 关于“裸机编程(Bare-Metal)”:</p>

<p>微控制器开发人员很熟悉这个概念，
Bare-Metal是指的你的程序和处理器之间没有任何东西&mdash;-你写的程序将直接运行在处理器上,
换言之，开发人员是在直接操控硬件。在裸机编程的场景中，需要由开发人员检查并排除任何一个可以导致系统崩溃的风险。</p>

<p>&ldquo;Bare-Metal"要求开发人员了解关于硬件的细节，所以接下来我们将对编译链和qemu本身进行分析。</p>

<p>3. 下载qemu源码包并查询相关硬件信息：</p>

<p>ArchLinux采用ABS(Arch Build
System)来管理源码包，下面的步骤将qemu源码包下载到本地，更详细的关于ABS的操作可以在ArchLinux的Wiki中找到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S abs
</span><span class='line'>$ pacman -Ss qemu
</span><span class='line'>extra/qemu 1.4.2-2 [installed]
</span><span class='line'>$ abs extra/qemu 
</span><span class='line'>$ cp -r /var/abs/extra/qemu/ ~/abs 
</span><span class='line'>$ cd ~/abs && makepkg -s --asroot -o</span></code></pre></td></tr></table></div></figure>


<p>得到versatilepb开发板的CPU型号, 可以看到"arm926"是我们要的结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grep "arm" src/qemu-1.4.2/hw/versatilepb.c 
</span><span class='line'>#include "arm-misc.h"
</span><span class='line'>static struct arm_boot_info versatile_binfo;
</span><span class='line'>        args-&gt;cpu_model = "arm926";
</span><span class='line'>    cpu = cpu_arm_init(args-&gt;cpu_model);
</span><span class='line'>    cpu_pic = arm_pic_init_cpu(cpu);
</span><span class='line'>    arm_load_kernel(cpu, &versatile_binfo);</span></code></pre></td></tr></table></div></figure>


<p>得到versatilepb开发板的串口寄存器硬件信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grep "UART*" src/qemu-1.4.2/hw/versatilepb.c 
</span><span class='line'>    /*  0x10009000 UART3.  */
</span><span class='line'>    /*  0x101f1000 UART0.  */
</span><span class='line'>    /*  0x101f2000 UART1.  */
</span><span class='line'>    /*  0x101f3000 UART2.  */</span></code></pre></td></tr></table></div></figure>


<p>所以说开源是王道嘛，很快就查到了每一个需要了解的细节。UART0在内存中map到的地址是0x101f1000,
我们直接往这个地址写数据，就可以在终端上看到数据输出了。</p>

<p>4. 查看编译链支持的平台：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat ~/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/share/doc/arm-arm-none-eabi/info/gcc.info | grep arm926
</span><span class='line'>     `arm926ej-s', `arm940t', `arm9tdmi', `arm10tdmi', `arm1020t',</span></code></pre></td></tr></table></div></figure>


<p>arm926ej-s是被支持的，因此我们可以用这套编译链来生成需要的裸机调试代码。</p>

<p>5. 启动应用程序init.c的编写:</p>

<p>首先创建应用程序init.c：</p>

<figure class='code'><figcaption><span>init.c - init.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">UART0_PTR</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0101f1000</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">string</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span><span class='line'>        <span class="o">*</span><span class="n">UART0_PTR</span> <span class="o">=</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">my_init</span><span class="p">(){</span>
</span><span class='line'>    <span class="n">display</span><span class="p">(</span><span class="s">&quot;Hello Open World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>init.c中，我们首先声明一个volatile变UART0_PTR,volatile关键字用于告知编译器此变量是用于直接访问内存映像设备的，即串口0内存地址</p>

<p>display()函数则是用于将字符串中的字符按顺序输出到串口0, 直到遇到字符串结尾。</p>

<p>my_init()调用了display(), 接下来我们将把它作为C入口函数.</p>

<p>预编译init.c:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-gcc -c -mcpu=arm926ej-s init.c -o init.o</span></code></pre></td></tr></table></div></figure>


<p>6. 启动代码start.s编写：</p>

<figure class='code'><figcaption><span>start.s - start.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="m">.</span>global _Start
</span><span class='line'>_Start<span class="o">:</span>
</span><span class='line'>LDR sp<span class="p">,</span> <span class="o">=</span> sp_top
</span><span class='line'>BL my_init
</span><span class='line'>B <span class="m">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理器加电后，将跳转到指定的内存地址,从此地址开始读入并执行代码。</p>

<p>_Start被声明为全局函数，_Start的实现中，首先将栈地址指向sp_top, LDR(load),
sp是栈地址寄存器(stack pointer),</p>

<p>BL则是跳转指令，跳转到my_init函数，事实上你可以跳转到任何一个你想跳转的函数，临时写一个their_init()跳转过去也行。Debug时常更改这里以调试不同的子系统功能。</p>

<p>&ldquo;B."可以理解为汇编里的while(1)或for(;;)循环，处理器空转，什么也不做。如果不调用它，系统就会崩溃。所谓嵌入式编程的一个基本理念就是，代码无限循环。</p>

<p>预编译汇编文件start.s:
    $ arm-none-eabi-as -mcpu=arm926ej-s startup.s -o startup.o</p>

<p>7. 接下来我们需要用一个可以被编译器识别的链接脚本链接两文件, linker.ld:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>  SECTIONS
</span><span class='line'>  {
</span><span class='line'>  . = 0x10000;
</span><span class='line'>  startup : { startup.o(.text)}
</span><span class='line'>  .data : {*(.data)}
</span><span class='line'>  .bss : {*(.bss)}
</span><span class='line'>  . = . + 0x500;
</span><span class='line'>  sp_top = .;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>ENTRY(_Start)用于告知链接器程序的入口点(entry point)是_Start(start.s中定义).
Qemu模拟器如果加上-kernel选项时，将自动从0x10000开始执行，所以我们必须将代码放到这个地址。所以第四行我们指定".
= 0x10000". SECTIONS就是用于定义程序的不同部分的。</p>

<p>startup.o组成了代码的text部分，然后是data部分和bss部分，最后一步则定义了栈指针(sp,
stack pointer)地址. 栈通常是向下增长的，所以最好给它一个比较安全的地址， . =
.+0x500就是用于避免栈被改写的。sp_top用于存储栈顶地址。</p>

<p>有关程序结构：</p>

<ul>
<li>BSS段:  在采用段式内存管理的架构中，BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。.bss section的空间结构类似于stack, 主要用于存储静态变量、未显式初始化、在变量使用前由运行时初始化为零。</li>
<li>数据段(data segment): 通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>代码段(code segment/text segment): 通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许程序自修改。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>


<p>编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -T linker.ld init.o startup.o -o output.elf
</span><span class='line'>$ file output.elf 
</span><span class='line'>output.elf: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),statically linked, not stripped
</span><span class='line'>$  arm-none-eabi-objcopy -O binary output.elf output.bin
</span><span class='line'>$ file output.bin 
</span><span class='line'>output.bin: data</span></code></pre></td></tr></table></div></figure>


<p>8. 使用qemu-system-arm运行output.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm --help | grep nographic 
</span><span class='line'>-nographic      disable graphical output and redirect serial I/Os to console.
</span><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>9. Play more tricks:
改动init.c里的串口输出地址为串口1：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>volatile unsigned char * const UART0_PTR = (unsigned char *)0x0101f2000;
</span><span class='line'>  // 0x101f1000  --&gt; 0x101f2000</span></code></pre></td></tr></table></div></figure>


<p>按照步骤3～7里重新编译，并运行以查看结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 没有反应！
</span><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
</span><span class='line'># 终端有输出字符。
</span><span class='line'>$ qemu-system-arm -M versatilepb -kernel output.bin -serial vc:800x600 -serial stdio
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>同样你也可以把字符输出到第三个串口，只不过前两个-serial的重定向需要指定到别的设备而已。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-1/">用Qemu模拟ARM(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T10:45:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>10:45 am</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前面已经安装并配置了编译链和qemu，现在可以用qemu来模拟arm平台了。</p>

<p>1. Hello, Qemu!</p>

<p>输入下面的代码:</p>

<figure class='code'><figcaption><span>hello.c - hello.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, Qemu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-linux-gnueabi-gcc -o hello hello.c -static
</span><span class='line'>$ qemu-arm ./hello
</span><span class='line'>$ file hello
</span><span class='line'>hello: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), \
</span><span class='line'> statically linked, for GNU/Linux 2.6.16, not stripped</span></code></pre></td></tr></table></div></figure>


<p>不加-static变量的话，运行时则需要使用-L选项链接到相应的运行库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-arm -L /home/Trusty/CodeSourcery/\
</span><span class='line'>Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/\
</span><span class='line'>arm-none-linux-gnueabi/libc/  ./hello_1 
</span><span class='line'>Hello, Qemu!
</span><span class='line'>$ file hello_1
</span><span class='line'>hello_1: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),\
</span><span class='line'> dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped</span></code></pre></td></tr></table></div></figure>


<p>动态编译和静态编译生成的文件大小差别：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h
</span><span class='line'>total 656K
</span><span class='line'>-rwxr-xr-x 1 Trusty root 640K Jul  7 18:46 hello
</span><span class='line'>-rwxr-xr-x 1 Trusty root 6.6K Jul  7 18:48 hello_1</span></code></pre></td></tr></table></div></figure>


<h3>小插曲1：</h3>

<p>系统里安装了两套编译链arm-none-eabi-和arm-none-linux-eabi-,很容易让人混淆，可参考编译链的命名规则：</p>

<p>arch(架构)-vendor(厂商名)-(os(操作系统名)-)abi(Application Binary
Interface，应用程序二进制接口)</p>

<p>举例说明：</p>

<ul>
<li>x86_64-w64-mingw32 = x86_64 &ldquo;arch"字段 (=AMD64), w64 (=mingw-w64
是"vendor"字段), mingw32 (=GCC所见的win32 API)</li>
<li>i686-unknown-linux-gnu = 32位 GNU/linux编译链</li>
<li>arm-none-linux-gnueabi = ARM 架构, 无vendor字段, linux 系统, gnueabi ABI.</li>
<li>arm-none-eabi = ARM架构, 无厂商, eabi ABI(embedded abi)</li>
</ul>


<p>两种编译链的主要区别在于库的差别，前者没有后者的库多，后者主要用于在有操作系统的时候编译APP用的。前者不包括标准输入输出库在内的很多C标准库，适合于做面向硬件的类似单片机那样的开发。因而如果采用arm-none-eabi-gcc来编译hello.c会出现链接错误。</p>

<h3>小插曲2：</h3>

<p>qemu-arm和qemu-system-arm的区别：</p>

<ul>
<li>qemu-arm是用户模式的模拟器(更精确的表述应该是系统调用模拟器)，而qemu-system-arm则是系统模拟器，它可以模拟出整个机器并运行操作系统</li>
<li>qemu-arm仅可用来运行二进制文件，因此你可以交叉编译完例如hello
world之类的程序然后交给qemu-arm来运行，简单而高效。而qemu-system-arm则需要你把hello
world程序下载到客户机操作系统能访问到的硬盘里才能运行。</li>
</ul>


<p>2. 使用qemu-system-arm运行Linux内核</p>

<p>从www.kernel.org下载最新内核,而后解压</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tar xJf linux-3.10.tar.xz
</span><span class='line'>$ cd linux-3.10
</span><span class='line'>$ make ARCH=arm versatile_defconfig
</span><span class='line'>$ make menuconfig ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-</span></code></pre></td></tr></table></div></figure>


<p>上面的命令指定内核架构为arm，交叉编译链为arm-none-linux-gnueabi,
需要在make menuconfig弹出的窗口中选择到 “Kernel Features”, 激活“Use the ARM
EABI to compile the kernel”,
如果不激活这个选项的话，内核将无法加载接下来要制作的initramfs。</p>

<p>如果需要在u-boot上加载内核，就要编译为uImage的格式，uImage通过mkimage程序来压缩的，ArchLinux的yaourt仓库里可以找到这个包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yaourt -S mkimage</span></code></pre></td></tr></table></div></figure>


<p>安装好mkimage后，开始编译内核，因为CPU有4核，所以开启了-j8选项以加速编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- all -j8 uImage </span></code></pre></td></tr></table></div></figure>


<p>接下来我们可以在qemu-system-arm中测试我们的内核了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -m 128M -kernel ./arch/arm/boot/uImage</span></code></pre></td></tr></table></div></figure>


<p>在弹出的窗口中可以内核运行到了kernel
panic状态，这是因为内核无法加载root镜像的缘故，我们将制作一个最简单的hello
world的文件系统，告知kernel运行之。</p>

<figure class='code'><figcaption><span>init.c - init.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并制作启动镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-linux-gnueabi-gcc -o init init.c -static
</span><span class='line'>$ echo init |cpio -o --format=newc &gt; initramfs
</span><span class='line'>1280 blocks
</span><span class='line'>$ file initramfs 
</span><span class='line'>initramfs: ASCII cpio archive (SVR4 with no CRC)</span></code></pre></td></tr></table></div></figure>


<p>接下来我们回到编译目录下执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel ./arch/arm/boot/uImage  -initrd
</span><span class='line'>../initramfs -serial stdio -append "console=tty1"</span></code></pre></td></tr></table></div></figure>


<p>这时候可以看到，kernel运行并在Qemu自带的终端里打印出"Hello World!&ldquo;。</p>

<p>如果我们改变console变量为ttyAMA0, 将在启动qemu-system-arm的本终端上打印出qemu的输出。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/07/qemukuai-su-shang-shou/">Qemu快速上手</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-07T15:19:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>3:19 pm</span></time>
        
         | <a href="/blog/2013/07/07/qemukuai-su-shang-shou/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 安装Qemu</p>

<p>ArchLinux的仓库里包含有qemu已编译好的包:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Ss qemu
</span><span class='line'>extra/qemu 1.4.2-2 [installed]
</span><span class='line'>    A generic and open source processor emulator which achieves a good \
</span><span class='line'>emulation speed by using dynamic translation.
</span><span class='line'>$ pacman -S qemu</span></code></pre></td></tr></table></div></figure>


<p>会根据默认配置安装好几乎所有平台支持的Qemu.</p>

<p>或者你可以手动下载源码包进行编译:官方下载地址在<a href="http://wiki.qemu.org/Download">http://wiki.qemu.org/Download</a></p>

<p>安装完qemu后运行qemu-system-i386, 如果弹出窗口，则说明qemu安装正确。</p>

<p>2. 创建新虚拟机磁盘镜像</p>

<p>创建虚拟机的第一步是创建一个新的磁盘镜像，qemu提供了对多种磁盘镜像格式的支持，如raw、qcow2、qed、vdi等，qemu-img的帮助里介绍qcow2是最多才多艺(Versatile)的格式，支持压缩、加密等功能，还能最大程度节省磁盘空间。我们选择它来做磁盘镜像(Virtualbox可以直接读取qcow2格式的虚拟机镜像)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-img create -f qcow2 ubuntu.qcow2 16G
</span><span class='line'>Formatting 'ubuntu.qcow2', fmt=qcow2 size=17179869184 encryption=off \
</span><span class='line'>cluster_size=65536 lazy_refcounts=off </span></code></pre></td></tr></table></div></figure>


<p>3. 启动并安装虚拟机:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda ubuntu.qcow2 -boot d -cdrom \
</span><span class='line'>./ubuntu-13.04-desktop-i386.iso -m 1024 -enable-kvm</span></code></pre></td></tr></table></div></figure>


<p>-boot d代表优先从光驱启动，对应的选项有a, b (软驱 1 和 2), c (硬盘优先), d (光盘优先), n-p(支持Etherboot的网卡1-4).</p>

<p>安装ubuntu的步骤很直观，这里就不用篇幅描述了。安装完毕后，使用下列命令启动安装好的虚拟机镜像</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda ubuntu.qcow2 -m 1024 -enable-kvm</span></code></pre></td></tr></table></div></figure>


<p>4. 配置虚拟机网络：</p>

<p>4.1 使用桥接网络</p>

<p>这种方法需要改动系统配置，使用bridge-utils来创建虚拟网卡和实际网卡之间的桥接。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Ss bridge-utils
</span><span class='line'>core/bridge-utils 1.5-2
</span><span class='line'>    Utilities for configuring the Linux ethernet bridge
</span><span class='line'>$ pacman -S bridge-utils</span></code></pre></td></tr></table></div></figure>


<p>创建桥接设备(br0)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ modprobe bridge
</span><span class='line'>$ brctl addbr br0</span></code></pre></td></tr></table></div></figure>


<p>出现add bridge failed: Package not installed时的解决方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brctl addbr br0
</span><span class='line'>add bridge failed: Package not installed
</span><span class='line'># 查看kernel中关于bridge配置选项
</span><span class='line'>$ zcat /proc/config.gz | grep CONFIG_BRIDGE=
</span><span class='line'>CONFIG_BRIDGE=m
</span><span class='line'># 查看是否存在ko文件
</span><span class='line'>$ ls /usr/lib/modules/`uname -r`/kernel/net/bridge
</span><span class='line'>bridge.ko.gz  netfilter
</span><span class='line'># 加载bridge内核模块
</span><span class='line'>$ modprobe bridge
</span><span class='line'># 检查内核模块是否被加载
</span><span class='line'>$ lsmod | grep ^bridge
</span><span class='line'>bridge                 93187  0 </span></code></pre></td></tr></table></div></figure>


<p>若modprobe bridge后lsmod看不到bridge模块，有可能是因为更新完系统安装到新的kernel version后没有重启，ArchLinux是一个非常激进的发行版，内核往往几天一升级，习惯休眠或长期不关机的用户可能会碰到这个问题。</p>

<p>检查bridge网络</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brctl show br0
</span><span class='line'>bridge name   bridge id       STP enabled interfaces
</span><span class='line'>br0       8000.000000000000   no</span></code></pre></td></tr></table></div></figure>


<p>关于STP:
Spanning Tree Protocol (STP) is a Layer 2 protocol that runs on bridges and
switches. The specification for STP is IEEE 802.1D. The main purpose of STP is
to ensure that you do not create loops when you have redundant paths in your
network. Loops are deadly to a network.
生成树协议运行于bridge或交换机上，主要目的为确保在存在冗余路径时网络中不会生成回路，回路会造成网络的死循环。</p>

<p>用下列命令查看网口信息, 或者ifconfig -a直接查看也可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ifconfig -s | awk '{print $1}' | grep -v "Iface\|lo"
</span><span class='line'>enp0s25</span></code></pre></td></tr></table></div></figure>


<p>将enp0s25加入到br0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /sbin/ifconfig enp0s25 down
</span><span class='line'>$ /sbin/ifconfig enp0s25 0.0.0.0 promisc up
</span><span class='line'>$ brctl addif br0 enp0s25
</span><span class='line'>$ dhcpcd br0</span></code></pre></td></tr></table></div></figure>


<p>查看bridge端口信息,发现enp0s25已经被加入了br0：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brctl show br0
</span><span class='line'>bridge name   bridge id       STP enabled interfaces
</span><span class='line'>br0       8000.c8cbb8b48913   no      enp0s25</span></code></pre></td></tr></table></div></figure>


<p>有关bridge网络的dhcp相关配置，可以参考<a href="http://Tomcat.no-ip.biz/blog/2013/07/07/archlinuxwang-luo-pei-zhi-wen-ti/">ArchLinux网络配置问题</a>。</p>

<p>创建qemu启动脚本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /etc/qemu-ifup
</span><span class='line'>#!/bin/sh
</span><span class='line'>  
</span><span class='line'>echo "Executing /etc/qemu-ifup"
</span><span class='line'>echo "Bringing up $1 for bridged mode..."
</span><span class='line'>sudo /usr/bin/ip link set $1 up promisc on
</span><span class='line'>echo "Adding $1 to br0..."
</span><span class='line'>sudo /usr/bin/brctl addif br0 $1
</span><span class='line'>sleep 2</span></code></pre></td></tr></table></div></figure>


<p>更改脚本权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ chmod 750 /etc/qemu-ifup 
</span><span class='line'>$ chown -R root /etc/qemu-ifup 
</span><span class='line'>$ chgrp kvm /etc/qemu-ifup </span></code></pre></td></tr></table></div></figure>


<p>创建qemu结束脚本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /etc/qemu-ifdown
</span><span class='line'>#!/bin/sh
</span><span class='line'> 
</span><span class='line'>echo "Executing /etc/qemu-ifdown"
</span><span class='line'>sudo /usr/bin/ip link set $1 down
</span><span class='line'>sudo /usr/bin/brctl delif br0 $1
</span><span class='line'>sudo /usr/bin/ip link delete dev $1</span></code></pre></td></tr></table></div></figure>


<p>更改脚本权限:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ chmod 750 /etc/qemu-ifdown 
</span><span class='line'>$ chown -R root /etc/qemu-ifdown 
</span><span class='line'>$ chgrp kvm /etc/qemu-ifdown </span></code></pre></td></tr></table></div></figure>


<p>添加当前用户到kvm用户组并在visudo中开放对应命令的权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ usermod -a -G kvm Trusty
</span><span class='line'>$ visudo
</span><span class='line'>Cmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
</span><span class='line'>%kvm     ALL=NOPASSWD: QEMU</span></code></pre></td></tr></table></div></figure>


<p>建立run-qemu文件，并添加到系统路径中.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /bin/run-qemu
</span><span class='line'>#!/bin/bash
</span><span class='line'>USERID=`whoami`
</span><span class='line'>precreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
</span><span class='line'>sudo /usr/bin/ip tuntap add user $USERID mode tap
</span><span class='line'>postcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
</span><span class='line'>IFACE=$(comm -13 &lt;(echo "$precreationg") &lt;(echo "$postcreation"))
</span><span class='line'>
</span><span class='line'># This line creates a random mac address. The downside is the dhcp server will
</span><span class='line'>assign a different ip each time
</span><span class='line'>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM & 0xff)) $(( $RANDOM &
</span><span class='line'>0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff ))
</span><span class='line'># Instead, uncomment and edit this line to set an static mac address. The
</span><span class='line'>benefit is that the dhcp server will assign the same ip.
</span><span class='line'># macaddr='52:54:be:36:42:a9'
</span><span class='line'>  
</span><span class='line'>qemu-system-i386 -enable-kvm -net nic,macaddr=$macaddr -net tap,ifname="$IFACE"
</span><span class='line'>$*
</span><span class='line'>  
</span><span class='line'>sudo ip link set dev $IFACE down &&gt; /dev/null
</span><span class='line'>sudo ip tuntap del $IFACE mode tap &&gt; /dev/null 
</span><span class='line'>$ sudo chmod a+w /bin/run-qemu</span></code></pre></td></tr></table></div></figure>


<p>使用下列命令来运行qemu</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /bin/run-qemu -hda ./ubuntu.qcow2 -m 1024 -vga std</span></code></pre></td></tr></table></div></figure>


<p>运行多个run-qemu实例后的网络信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ifconfig -s
</span><span class='line'>Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
</span><span class='line'>br0       1500    70676      0      0 0         64334      0      0      0 BMRU
</span><span class='line'>enp0s25   1500   103814      0      0 0         75661      0      0      0 BMPRU
</span><span class='line'>lo       65536      983      0      0 0           983      0      0      0 LRU
</span><span class='line'>tap0      1500        3      0      0 0            11      0      0      0 BMPRU
</span><span class='line'>tap1      1500        3      0      0 0            11      0      0      0 BMPRU</span></code></pre></td></tr></table></div></figure>


<p>4.2 使用VDE(Virtual Distrubuted Ethernet)创建Qemu网络，这种方法无需改变系统配置。</p>

<p>有关VDE的配置可以参考前面写过的<a href="http://Tomcat.no-ip.biz/blog/2013/07/04/zai-centosshang-an-zhuang-ji-yu-qemude-xu-ni-ji/">在CentOS上安装基于Qemu的虚拟机</a>一文。</p>

<p>值得注意的是, vdeswitch和slirpvde都可以在ArchLinux的软件库中找到:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Ss vde
</span><span class='line'>extra/vde2 2.3.2-4 [installed]
</span><span class='line'>    Virtual Distributed Ethernet for emulators like qemu</span></code></pre></td></tr></table></div></figure>


<p>使用VDE创建的网络对外是不可见的，它使用由slirpvde分配的dhcp地址，通常以10.0.0开头，VDE配置的网络也可以在VirtualBox中看到，VirtualBox中关于NAT的网络配置就是基于VDE的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/07/archlinuxwang-luo-pei-zhi-wen-ti/">ArchLinux DHCP配置问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-07T12:10:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:10 pm</span></time>
        
         | <a href="/blog/2013/07/07/archlinuxwang-luo-pei-zhi-wen-ti/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>安装完ArchLinux后，发现网卡无法从路由器通过dhcp得到地址，ArchLinux的dhcp客户端是dhcpcd,默认配置文件。路由器型号是TP-link WR340G v5, 2010年入手的。</p>

<p>手动调用dhcpcd时候发现LOG里有NAK消息爆出。</p>

<p>翻了下Arch的论坛，这个问题是由于dhcpcd的参数配置引发的，某些dhcpcd向路由器请求的参数无法得到而导致，个人觉得大约是WR340G版本够老，无法提供这些个参数。</p>

<h2>解决方案一：</h2>

<p>编辑/etc/dhcpcd.conf， 注释掉classless_static_routes 和 interface_mtu即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># option classless_static_routes
</span><span class='line'>
</span><span class='line'># Respect the network MTU.
</span><span class='line'># option interface_mtu</span></code></pre></td></tr></table></div></figure>


<p>而后我们可以用systemd在每次启动的时候自动调用dhcpcd绑定地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ systemctl enable dhcpcd@enp0s25
</span><span class='line'>$ systemctl start dhcpcd@enp0s25</span></code></pre></td></tr></table></div></figure>


<h2>解决方案二:</h2>

<p>安装dhclient:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S dhclient
</span><span class='line'>$ dhclient enp0s25</span></code></pre></td></tr></table></div></figure>


<p>这种方法需要每次手动输入，不过我们可以使用netctl包来自动管理网络接口信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cp /etc/netctl/examples/ethernet-dhcp /etc/netctl/ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>由netctl.profile查到指定dhcp客户端的字段，而后在/etc/netctl/ethernet-dhcp文件中添加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DHCPClient=dhclient
</span><span class='line'># !!! 别忘了修改dhcp侦听的设备地址：
</span><span class='line'># Interface=eth0
</span><span class='line'>Interface=enp0s25</span></code></pre></td></tr></table></div></figure>


<p>把ethernet-dhcp作为netctl的默认启动配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ netctl enable ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>立即开启netctl:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ netctl start ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>查看netctl服务运行情况，我的网络是桥接的，和依据上面步骤配出来的字段会有所不同</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ systemctl list-units -t service | grep netctl
</span><span class='line'>netctl@bridge.service        loaded active exited  Example Bridge connection</span></code></pre></td></tr></table></div></figure>


<p>如果切换了网络环境，例如如果在待机唤醒时处于另一网络中，则需要用下列命令重新配置网络:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ netctl restart ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>两种方法各有千秋，前者比较灵活，但是遇到复杂网络配置的时候可能会很棘手，譬如多网卡/桥接等模型时容易把人弄晕。后者配置选项很多，但一劳永逸。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/06/archlinuxshang-an-zhuang-armbian-yi-lian/">ArchLinux上安装arm编译链</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-06T20:14:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:14 pm</span></time>
        
         | <a href="/blog/2013/07/06/archlinuxshang-an-zhuang-armbian-yi-lian/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在X86_64的ArchLinux上安装Mentor Graphics提供的arm交叉编译链时出现下列问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./arm-2013.05-23-arm-none-eabi.bin 
</span><span class='line'>Checking for required programs: awk grep sed bzip2 gunzip
</span><span class='line'>===============================================================
</span><span class='line'>Error: Missing 32-bit libraries on 64-bit Linux host
</span><span class='line'>===============================================================
</span><span class='line'>Your 64-bit Linux host is missing the 32-bit libraries
</span><span class='line'>required to install and use Sourcery CodeBench.</span></code></pre></td></tr></table></div></figure>


<p>解决方法：</p>

<p>编辑/etc/pacman.conf，去掉下列两行的注释</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[multilib]
</span><span class='line'>Include = /etc/pacman.d/mirrorlist</span></code></pre></td></tr></table></div></figure>


<p>而后安装必要的ia32相关的包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Sy
</span><span class='line'>$ pacman -S lib32-glibc
</span><span class='line'>$ pacman -S lib32-gtk lib32-gtk2</span></code></pre></td></tr></table></div></figure>


<p>安装好以后执行前面被中断的安装进程，这时候可以顺利安装了。</p>

<p>安装完毕后记得把交叉编译链的路径加入到系统路径中，最好在~/.bashrc里加上一笔:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PATH=$HOME/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/bin:$PATH
</span><span class='line'>export PATH=$HOME/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/bin:$PATH</span></code></pre></td></tr></table></div></figure>


<p>ArchLinux的yaourt仓库里也有arm-none-eabi和arm-none-linux-eabi等交叉编译链，但是每次编译都会出现莫名其妙的错误，使用现成的编译链能大大节省开发时间。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/05/archlinuxchu-bu-pei-zhi-wang-luo/">ArchLinux初步配置网络</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-05T20:21:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:21 pm</span></time>
        
         | <a href="/blog/2013/07/05/archlinuxchu-bu-pei-zhi-wang-luo/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>刚安装好的ArchLinux上只有基本的系统组件，启动以后连ifconfig都没有（其实ifconfig早在N年前就被干掉，以ip命令代替了)。在这种一穷二白的情况下，如何配置好网络参数？下面的步骤可以让人一劳永逸。</p>

<p>1. 查看网络接口信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ip link show
</span><span class='line'>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT 
</span><span class='line'>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span><span class='line'>2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
</span><span class='line'>    link/ether 08:00:27:09:fd:b7 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>可以看到enp0s3为有线端口，未启动，无地址无网关无路由。</span></code></pre></td></tr></table></div></figure>


<p>2. 启动网口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ip link enp0s3 up</span></code></pre></td></tr></table></div></figure>


<p>3. 配置网卡地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ip addr add 192.168.1.133/24 broadcast 192.168.1.255 dev enp0s3</span></code></pre></td></tr></table></div></figure>


<p>参数解释：IP地址: 192.168.1.133, 广播地址:192.168.1.255</p>

<p>4. 配置默认路由为192.168.1.1:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ip default-gateway 192.168.1.1</span></code></pre></td></tr></table></div></figure>


<p>5. 查看接口信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#路由信息
</span><span class='line'>$ ip route show
</span><span class='line'>#地址信息
</span><span class='line'>$ ip addr show</span></code></pre></td></tr></table></div></figure>


<p>6. 添加dns解析信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /etc/resolv.conf</span></code></pre></td></tr></table></div></figure>


<p>输入ISP提供的dns服务器信息，例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nameserver 58.XXX.xx.xx
</span><span class='line'>nameserver 221.x.x.xx</span></code></pre></td></tr></table></div></figure>


<p>7. 安装net-tools，这里包含了ifconfig，终于可以不用忍受ip命令的折磨了。但是我记得看过一个高手的文章，他建议使用ip而不是使用陈旧的功能有限的ifconfig，高手开了个玩笑：“记住每次你敲ifconfig时，就会有一只无辜的小猫咪因为偷吃奶酪被击杀，可怜可怜小猫咪吧 :(”。虽然ifconfig很方便也是大多数教程里的常用配置，还是建议大家尽快适应繁琐的ip命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S net-tools</span></code></pre></td></tr></table></div></figure>


<p>8. 安装dhcpcd并加入到系统启动项中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S dhcpcd
</span><span class='line'># 临时启动dhcpcd
</span><span class='line'>$ systemctl start dhcpcd@enp0s3
</span><span class='line'># 将dhcpcd加入到启动项中
</span><span class='line'>$ systemctl enable dhcpcd@enp0s3</span></code></pre></td></tr></table></div></figure>


<p>现在重启机器，就可以从dhcp服务器自动获取地址并配置dns服务器等信息了。</p>

<p>9. 其他：</p>

<p>删除当前已经绑定的IP地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ip addr del 192.168.1.134/32 dev enp0s3</span></code></pre></td></tr></table></div></figure>


<p>若机器处于有防火墙的机器中，则需要配置好proxy信息才能正常使用网络，在命令行下，输入一下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export http_proxy=http://ip_address:ip_port
</span><span class='line'>$ export https_proxy=http://ip_address:ip_port
</span><span class='line'>$ export ftp_proxy=http://ip_address:ip_port
</span><span class='line'>$ export ftps_proxy=http://ip_address:ip_port</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/05/zai-centosshang-an-zhuang-ji-yu-qemude-xu-ni-ji-2/">在CentOS上安装基于qemu的虚拟机(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-05T16:18:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:18 pm</span></time>
        
         | <a href="/blog/2013/07/05/zai-centosshang-an-zhuang-ji-yu-qemude-xu-ni-ji-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 启动完毕后客户机无法得到网络地址：</p>

<p>故事的小插曲：由于虚拟机是“偷”跑在某台服务器上，不便在系统路径里留下痕迹，只能使用CPU/内存资源，采取了挂载NFS文件系统的方法，Qemu和vde均自行编译，先于vde编译的Qemu在配置的时候未能激活vde选项，造成客户机中无法找到vde配置的网络。</p>

<p>现象:重新编译qemu,使用下列命令时报错：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure --prefix=Your_place_here --target-list="i386-softmmu \
</span><span class='line'>x86_64-softmmu  i386-linux-user x86_64-linux-user" --enable-kvm \
</span><span class='line'>--enable-user --enable-vde</span></code></pre></td></tr></table></div></figure>


<p>安装vde2到系统路径后重编译qemu成功。而后</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export LD_LIBRARY_PATH=/usr/lib:$LD_LIBRARY_PATH</span></code></pre></td></tr></table></div></figure>


<p>则可正常启动vde/qemu</p>

<p>2. 开启Linux内核的forwarding, 这样客户机可以接入Internet.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo 1>/proc/sys/net/ipv4/ip_forward</span></code></pre></td></tr></table></div></figure>


<p>3. 增加更多的核:</p>

<p>在启动参数中添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-cpu host -smp cores=2,threads=1</span></code></pre></td></tr></table></div></figure>


<p>To be continued.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/55">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/53">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/09/20151009bei-zhu/">20151009备注</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/08/20151008bei-zhu/">20151008备注</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/08/dockerize-markdown-written-cv/">Dockerize Markdown Written CV</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/22/sharing-mouse-slash-keyboard-among-3-nodes/">Sharing Mouse/Keyboard Among 3 Nodes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/10/trouble-shooting-on-chromeoss-crouton-updating/">Trouble-Shooting on ChromeOS's Crouton Updating</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Dash -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dashsagittariussglory';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
