
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dash</title>
  <meta name="author" content="Dash">

  
  <meta name="description" content="It seems this board is good: OpenWRT trunk for imx233-OLinuXino now have 3220 packages http://olimex.wordpress.com/2013/07/24/openwrt-for-imx233- &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://purplepalmdash.github.io/posts/56">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/purplepalmdash/atom.xml" rel="alternate" title="Dash" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Dash</a></h1>
  
    <h2>Get busy living, or get busy dying.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/purplepalmdash/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:purplepalmdash.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/25/olimex-refer/">Olimex Refer</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-25T16:52:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:52 pm</span></time>
        
         | <a href="/blog/2013/07/25/olimex-refer/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>It seems this board is good:</p>

<p>OpenWRT trunk for imx233-OLinuXino now have 3220 packages <a href="http://olimex.wordpress.com/2013/07/24/openwrt-for-imx233-olinuxino-trunk-now-with-3220-packages/">http://olimex.wordpress.com/2013/07/24/openwrt-for-imx233-olinuxino-trunk-now-with-3220-packages/</a> …</p>

<p>Taobao Address:
<a href="http://item.taobao.com/item.htm?spm=a230r.1.14.7.WT8tYl&amp;id=21117476143">http://item.taobao.com/item.htm?spm=a230r.1.14.7.WT8tYl&amp;id=21117476143</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/15/arduinobi-ji-2/">Arduino笔记(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-15T16:33:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:33 pm</span></time>
        
         | <a href="/blog/2013/07/15/arduinobi-ji-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. PWM概念：
PWM( Pulse Width Modulation).简单来说，在arduino中我们可以理解为就是通过调节占空比来实现不同电压输出。</p>

<p>图片：</p>

<p>2. analogWrite()</p>

<p>描述</p>

<p>从一个引脚输出模拟值（PWM）。可用于让LED以不同的亮度点亮或驱动电机以不同的速度旋转。analogWrite()输出结束后，该引脚将产生一个稳定的特殊占空比方波，直到下次调用analogWrite()（或在同一引脚调用digitalRead()或digitalWrite()）。PWM信号的频率大约是490赫兹。</p>

<p>在大多数arduino板（ATmega168或ATmega328），只有引脚3，5，6，9，10和11可以实现该功能。在aduino Mega上，引脚2到13可以实现该功能。老的Arduino板（ATmega8）的只有引脚9、10、11可以使用analogWrite()。在使用analogWrite()前，你不需要调用pinMode()来设置引脚为输出引脚。</p>

<p>analogWrite函数与模拟引脚、analogRead函数没有直接关系。</p>

<p>通过读取电位器的阻值控制LED的亮度</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ledPin = 9;  // LED连接到数字引脚9
</span><span class='line'>int analogPin = 3;  //电位器连接到模拟引脚3
</span><span class='line'>int val = 0;  //定义变量存以储读值
</span><span class='line'> 
</span><span class='line'>void setup()
</span><span class='line'> 
</span><span class='line'>{
</span><span class='line'>pinMode（ledPin,OUTPUT）;  //设置引脚为输出引脚
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>val = analogRead（analogPin）;  //从输入引脚读取数值
</span><span class='line'>analogWrite（ledPin，val / 4）;  // 以val / 4的数值点亮LED（因为analogRead读取的数值从0到1023，而analogWrite输出的数值从0到255）
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3. 调节PWM值的程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int n=0;
</span><span class='line'>void setup ()
</span><span class='line'>{
</span><span class='line'>  pinMode(4,INPUT);
</span><span class='line'>  pinMode(6,OUTPUT);      //该端口需要选择有#号标识的数字口
</span><span class='line'>  pinMode(10,INPUT);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  int up =digitalRead(4);          //读取4号口的状态
</span><span class='line'>  int down = digitalRead(10);      //读取10号口的状态   
</span><span class='line'>  if (up==HIGH)                    //判断4号口目前是否是高电平
</span><span class='line'>  { 
</span><span class='line'>   n=n+5;                         //每次累加值为5
</span><span class='line'>    if (n>=255) {
</span><span class='line'>      n=255;
</span><span class='line'>    }            //限定最大值为255   
</span><span class='line'>analogWrite(6,n);               //使用PWM控制6号口输出，变量n的取值范围是0-255 
</span><span class='line'>    delay (300);
</span><span class='line'>  }
</span><span class='line'>  if (down==HIGH)                    //减少亮度
</span><span class='line'>  {
</span><span class='line'>   n=n-5;
</span><span class='line'>    if (n&lt;=0) {
</span><span class='line'>      n=0;
</span><span class='line'>    }
</span><span class='line'> analogWrite(6,n);
</span><span class='line'>    delay (300);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>需要选择#号标识的数字口是因为这些端口需要支持PWM功能。而后在loop()函数中，将修改后的n值输出到6号端口。</p>

<p>4. analogRead()</p>

<p>描述</p>

<p>从指定的模拟引脚读取数据值。
Arduino板包含一个6通道（Mini和Nano有8个通道，Mega有16个通道），10位模拟数字转换器。这意味着它将0至5伏特之间的输入电压映射到0至1023之间的整数值。这将产生读数之间的关系：5伏特/
1024单位，或0.0049伏特（4.9
mV）每单位。输入范围和精度可以使用analogReference()改变。
它需要大约100微秒（0.0001）来读取模拟输入，所以最大的阅读速度是每秒10000次。</p>

<p>语法</p>

<p>analogRead（PIN）</p>

<p>数值的读取</p>

<p>引脚：从输入引脚（大部分板子从0到5，Mini和Nano从0到7，Mega从0到15）读取数值</p>

<p>返回</p>

<p>从0到1023的整数值</p>

<p>5. 实现呼吸灯：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup ()
</span><span class='line'>{
</span><span class='line'>  pinMode(11,OUTPUT);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  for (int a=0; a&lt;=255;a++)                //循环语句，控制PWM亮度的增加
</span><span class='line'>  {
</span><span class='line'>    analogWrite(11,a);
</span><span class='line'>    delay(16);                             //当前亮度级别维持的时间,单位毫秒            
</span><span class='line'>  }
</span><span class='line'>    for (int a=255; a>=0;a--)             //循环语句，控制PWM亮度减小
</span><span class='line'>  {
</span><span class='line'>    analogWrite(11,a);
</span><span class='line'>    delay(16);                             //当前亮度的维持的时间,单位毫秒  
</span><span class='line'>  }
</span><span class='line'>  delay(800);                             //完成一个循环后等待的时间,单位毫秒
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>或者：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int n = 0; // n 从 1 至 255，控制led亮度
</span><span class='line'>int i = 5;  // 递进数
</span><span class='line'>
</span><span class='line'>void setup()
</span><span class='line'>{
</span><span class='line'>  pinMode( 11, OUTPUT); //设置11口为PWM输出端
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  n += i;                               // n每次增加 i 
</span><span class='line'>
</span><span class='line'>  
</span><span class='line'>
</span><span class='line'>  if ( n == 255 || n == 0)
</span><span class='line'>//在n升至255或者降至0时，i进行反转。这样led灯能在亮暗间转换
</span><span class='line'>   i = -i; 
</span><span class='line'>
</span><span class='line'>  analogWrite( 11, n );
</span><span class='line'>  delay( 50 );       //延迟50ms，进行下一次亮度调整
</span><span class='line'>  
</span><span class='line'>   if( n == 0)
</span><span class='line'>     delay(1800);
</span><span class='line'>  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>6. 实现温度计</p>

<p>主要器件LM315.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup() {
</span><span class='line'> 
</span><span class='line'>  Serial.begin(9600);         //使用9600速率进行串口通讯
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop() {
</span><span class='line'> 
</span><span class='line'>  int n = analogRead(A0);    //读取A0口的电压值
</span><span class='line'> 
</span><span class='line'>  float vol = n * (5.0 / 1023.0*100);
</span><span class='line'>//使用浮点数存储温度数据，温度数据由电压值换算得到
</span><span class='line'> 
</span><span class='line'>  Serial.println(vol);                   //串口输出温度数据
</span><span class='line'>  delay(2000);                           //等待2秒，控制刷新速度
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Serial.begin()</p>

<p>将串行数据传输速率设置为位/秒（波特）。与计算机进行通信时，可以使用这些波特率：300，1200，2400，4800，9600，14400，19200，28800，38400，57600或115200。当然，您也可以指定其他波特率- 例如，引脚0和1和一个元件进行通信，它需要一个特定的波特率。</p>

<p>Serial.println()
打印数据到串行端口，输出人们可识别的ASCII码文本并回车 (ASCII 13, 或 &lsquo;\r&rsquo;) 及换行(ASCII 10, 或 &lsquo;\n&rsquo;)。此命令采用的形式与Serial.print ()相同 。</p>

<p>和DS18b20有什么区别？</p>

<p>DS18b20是数字的，数字的出来的是方波，用脉冲方波和协议来通讯，模拟的出来的是电压，利用AD转换（ARDUINO的模拟脚可以理解为就是数字脚+AD/DA转换模块，如果你需要大量的模拟脚但是不要求数字脚，可以直接外接AD/DA转换器来实现）来得到测量值并换算成温度</p>

<p>0-100度 对应0-5v  模拟口返回数值0-1024  所以。模拟口的值 1=0.48828125</p>

<p>7. 光敏电阻的程序改动：</p>

<p>&ldquo;达文西的手电筒"，有光才能亮，没光，绝对不会亮！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int a =300;     //此处需是环境基础亮度变量，请查看自己的亮度数值，
</span><span class='line'>                //填写到此处数值要略大于所测得的数据但小于灯光下的数据
</span><span class='line'>void setup ()
</span><span class='line'>{
</span><span class='line'>  Serial.begin(9600);
</span><span class='line'>  pinMode(13,OUTPUT);
</span><span class='line'>}
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  int n = analogRead(A0);            //读取模拟口A0数值
</span><span class='line'>  Serial.println(n);
</span><span class='line'>  if (n>= a )                   //对光线强度进行判断，如果比我们的预设值大
</span><span class='line'>就点亮LED否则就关闭
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,HIGH);
</span><span class='line'>  }
</span><span class='line'>  else
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,LOW);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>修改为符合逻辑的光控电路：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 光强度小于临界值 */
</span><span class='line'>if ( n &lt; a)
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,HIGH);        // 点亮LED
</span><span class='line'>  }
</span><span class='line'>  else
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,LOW);     // 超过临界值时，关闭
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p> 光敏三极管有凸起的一边为发射极，此端接A0检测口，同时并联一个10K欧姆的分压电阻到地线以扩展光敏三极管的灵敏度（此处电阻越小灵敏度越高）。另一极使用5V输入。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/15/ardiunobi-ji-1/">Arduino笔记(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-15T09:39:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:39 am</span></time>
        
         | <a href="/blog/2013/07/15/ardiunobi-ji-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 稳压IC的作用：</p>

<p>稳压器IC就是使输出电压稳定的设备中的电子元器件。所有的稳压器，都利用了相同的技术实现输出电压的稳定输出电压通过连接到误差放大器（Error Amplifier）反相输入端（Inverting Input）的分压电阻（Resistive Divider）采样（Sampled），误差放大器的同相输入端（Non-inverting Input）连接到一个参考电压Vref。 参考电压由IC内部的带隙参考源(Bandgap Reference)产生。误差放大器总是试图迫使其两端输入相等。为此，它提供负载电流以保证输出电压稳定。</p>

<p>2. ICSP(In-circuit serial programming)</p>

<p>3. FT232: USB->UART</p>

<p> The FT232BM is the 2nd generation of FTDI&rsquo;s popular USB UART device and the FT232BL is a lead free version of it.  The FT232BQ provides the same functionality as the FT232BM and FT232BL in a QFN-32 lead free package.</p>

<p>4. ATmega328P Parameters:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Parameter        Value
</span><span class='line'>Flash (Kbytes):       32 Kbytes
</span><span class='line'>Pin Count:        32
</span><span class='line'>Max. Operating Frequency: 20 MHz
</span><span class='line'>CPU:          8-bit AVR
</span><span class='line'># of Touch Channels:  16
</span><span class='line'>Hardware QTouch Acquisition: No
</span><span class='line'>Max I/O Pins:     23
</span><span class='line'>Ext Interrupts:       24
</span><span class='line'>USB Speed:        No
</span><span class='line'>USB Interface:        No
</span><span class='line'>SPI:          2
</span><span class='line'>TWI (I2C):        1
</span><span class='line'>UART:         1
</span><span class='line'>Graphic LCD:      No
</span><span class='line'>Video Decoder:        No
</span><span class='line'>Camera Interface: No
</span><span class='line'>ADC channels:     8
</span><span class='line'>ADC Resolution (bits):    10
</span><span class='line'>ADC Speed (ksps): 15
</span><span class='line'>Analog Comparators:   1
</span><span class='line'>Resistive Touch Screen:   No
</span><span class='line'>DAC Resolution (bits):    0
</span><span class='line'>Temp. Sensor:     Yes
</span><span class='line'>Crypto Engine:        No
</span><span class='line'>SRAM (Kbytes):        2
</span><span class='line'>EEPROM (Bytes):       1024
</span><span class='line'>Self Program Memory:  YES
</span><span class='line'>External Bus Interface:   0
</span><span class='line'>DRAM Memory:      No
</span><span class='line'>NAND Interface:       No
</span><span class='line'>picoPower:        Yes
</span><span class='line'>Temp. Range (deg C):  -40 to 85
</span><span class='line'>I/O Supply Class: 1.8 to 5.5
</span><span class='line'>Operating Voltage (Vcc):1.8 to 5.5
</span><span class='line'>FPU:          No
</span><span class='line'>MPU / MMU:        no / no
</span><span class='line'>Timers:           3
</span><span class='line'>Output Compare channels:  6
</span><span class='line'>Input Capture Channels:       1
</span><span class='line'>PWM Channels:     6
</span><span class='line'>32kHz RTC:        Yes
</span><span class='line'>Calibrated RC Oscillator: Yes
</span><span class='line'>Watchdog:     Yes</span></code></pre></td></tr></table></div></figure>


<p>5. ATmega328P主要特性如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>高性能、低功耗的 8 位AVR 微处理器
</span><span class='line'>先进的RISC 结构
</span><span class='line'>131 条指令 – 大多数指令执行时间为单个时钟周期
</span><span class='line'>32 个8 位通用工作寄存器
</span><span class='line'>全静态工作
</span><span class='line'>工作于20 MHz 时性能高达20 MIPS
</span><span class='line'>只需两个时钟周期的硬件乘法器
</span><span class='line'>非易失性程序和数据存储器
</span><span class='line'>32K字节的系统内可编程Flash
</span><span class='line'>擦写寿命: 10,000 次
</span><span class='line'>具有独立锁定位的可选Boot 代码区
</span><span class='line'>通过片上Boot 程序实现系统内编程
</span><span class='line'>真正的同时读写操作
</span><span class='line'>1024字节的EEPROM
</span><span class='line'>擦写寿命: 100,000 次
</span><span class='line'>2K字节的片内SRAM
</span><span class='line'>可以对锁定位进行编程以实现用户程序的加密
</span><span class='line'>外设特点
</span><span class='line'>两个具有独立预分频器和比较器功能的8位定时器/计数器
</span><span class='line'>一个具有预分频器、比较功能和捕捉功能的16位定时器/计数器
</span><span class='line'>具有独立振荡器的实时计数器RTC
</span><span class='line'>六通道PWM
</span><span class='line'>8路10 位ADC
</span><span class='line'>可编程的串行USART
</span><span class='line'>可工作于主机/ 从机模式的SPI 串行接口
</span><span class='line'>基于字节的2-wire串行接口
</span><span class='line'>具有独立片内振荡器的可编程看门狗定时器
</span><span class='line'>片内模拟比较器
</span><span class='line'>引脚电平变化可引发中断及唤醒MCU
</span><span class='line'>特殊的微控制器特点
</span><span class='line'>上电复位(POR) 以及可编程的掉电检测(BOD)
</span><span class='line'>经过校准的片内RC 振荡器
</span><span class='line'>片内、片外中断源
</span><span class='line'>6种休眠模式：空闲模式、ADC 噪声抑制模式、省电模式、掉电模式、待机模式和延长待机模式
</span><span class='line'>I/O 和封装
</span><span class='line'>23个可编程的I/O 口
</span><span class='line'>28引脚PDIP，32引脚TQFP，28引脚QFN/MLF，与32引脚QFN/MLF封装
</span><span class='line'>工作电压
</span><span class='line'>1.8 - 5.5V
</span><span class='line'>工作温度范围:
</span><span class='line'>-40℃至85℃
</span><span class='line'>工作速度等级
</span><span class='line'>0 - 20 MHz @ 1.8 - 5.5V
</span><span class='line'>超低功耗
</span><span class='line'>正常模式：
</span><span class='line'>1 MHz, 1.8V, 25°C: 0.2 mA
</span><span class='line'>掉电模式:
</span><span class='line'>1.8V, 0.1 μA
</span><span class='line'>省电模式:
</span><span class='line'>1.8V, 0.75 μA</span></code></pre></td></tr></table></div></figure>


<p>6. LED闪烁测试程序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Let the LED shinning per 1 seconds 
</span><span class='line'> */
</span><span class='line'> 
</span><span class='line'> void setup()
</span><span class='line'> {
</span><span class='line'>   // Arduino's port 13 has a LED
</span><span class='line'>   pinMode(13, OUTPUT);
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> void loop()
</span><span class='line'> {
</span><span class='line'>   digitalWrite(13, HIGH);  // LED is on
</span><span class='line'>   delay(1000);             // Last for 1 second
</span><span class='line'>   digitalWrite(13, LOW);   // LED is off
</span><span class='line'>   delay(1000);             // Last for 1 second
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>在Arduino中程序运行时将首先调用 setup() 函数。用于初始化变量、设置针脚的输出\输入类型、配置串口、引入类库文件等等。每次 Arduino 上电或重启后，setup 函数只运行一次。</p>

<p>pinMode(): 将指定的引脚配置成输出或输入。详情请见digital pins。</p>

<p>在 setup() 函数中初始化和定义了变量，然后执行 loop() 函数。顾名思义,该函数在程序运行过程中不断的循环，根据一些反馈,相应改变执行情况。通过该函数动态控制 Arduino 主控板。</p>

<p>digitalWrite() 给一个数字引脚写入HIGH或者LOW。</p>

<p>如果一个引脚已经使用pinMode()配置为OUTPUT模式，其电压将被设置为相应的值，HIGH为5V（3.3V控制板上为3.3V），LOW为0V。</p>

<p>如果引脚配置为INPUT模式，使用digitalWrite()写入HIGH值，将使内部20K上拉电阻（详见数字引脚教程）。写入LOW将会禁用上拉。上拉电阻可以点亮一个LED让其微微亮，如果LED工作，但是亮度很低，可能是因为这个原因引起的。补救的办法是 使用pinMode()函数设置为输出引脚。</p>

<p>注意：数字13号引脚难以作为数字输入使用，因为大部分的控制板上使用了一颗LED与一个电阻连接到他。如果启动了内部的20K上拉电阻，他的电压将在1.7V左右，而不是正常的5V，因为板载LED串联的电阻把他使他降了下来，这意味着他返回的值总是LOW。如果必须使用数字13号引脚的输入模式，需要使用外部上拉下拉电阻。</p>

<p>delay(): 使程序暂定设定的时间（单位毫秒）。（一秒等于1000毫秒）</p>

<p>编译并烧入到开发板后，可以看到系统的LED灯开始闪烁。</p>

<p>7. 更多的LED</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup()
</span><span class='line'>{
</span><span class='line'>  for (int i=2; i&lt;=7; i++)    //通过循环的方式设置2-7号引脚为输出状态
</span><span class='line'>  {
</span><span class='line'>    pinMode(i,OUTPUT);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  for (int x=2; x&lt;=7; x++)
</span><span class='line'>//通过循环的方式依次让每个引脚的led在1秒内完成明灭
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(x,HIGH);
</span><span class='line'>    delay(500);
</span><span class='line'>    digitalWrite(x,LOW);
</span><span class='line'>    delay(500);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/12/qemukuai-su-bao-cun-he-hui-fu-zhuang-tai/">Qemu快速保存和恢复状态</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-12T09:41:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:41 am</span></time>
        
         | <a href="/blog/2013/07/12/qemukuai-su-bao-cun-he-hui-fu-zhuang-tai/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 启动镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda hd.qcow2</span></code></pre></td></tr></table></div></figure>


<p>2. 保存当前运行状态：</p>

<p>同时按下ctrl+alt+2切换到Qemu内建命令行，输入:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) savevm booted</span></code></pre></td></tr></table></div></figure>


<p>如果需要即时回复到保存时状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) loadvm booted</span></code></pre></td></tr></table></div></figure>


<p>关闭Qemu运行窗口</p>

<p>3. 快速恢复到保存状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda hd.qcow2 -loadvm booted</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/">用Qemu和GNU编译链研究ARM汇编(4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-11T21:46:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:46 pm</span></time>
        
         | <a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 有关异常向量</p>

<p>前面的例子中存在一个大BUG，内存布局中的前8个全字是为异常向量而保留的。当异常发生时控制逻辑将转到这些位置以执行对应的异常处理代码。异常向量和它们的地址如下：</p>

<ul>
<li>Exception  Address</li>
<li>Reset  0x00</li>
<li>Undefined Instruction  0x04</li>
<li>Software Interrupt (SWI)   0x08</li>
<li>Prefetch Abort     0x0C</li>
<li>Data Abort     0x10</li>
<li>Reserved, not used     0x14</li>
<li>IRQ    0x18</li>
<li>FIQ    0x1C</li>
</ul>


<p>按理说，这些个异常向量应该对应到异常处理程序中，既然我们代码中不会有异常发生，索性就用死循环来代替，如下：</p>

<figure class='code'><figcaption><span>vector.s -vector.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span></code></pre></td></tr></table></div></figure>


<p>对应的，为了确保这些指令被放置在异常向量地址中，链接脚本也需要做相应的改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>                * (vectors);
</span><span class='line'>                * (.text);
</span><span class='line'>                ...
</span><span class='line'>        }
</span><span class='line'>        ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>异常向量需要放置在所有代码之前，这确保了代了向量是从0x0地址开始。</p>

<p>2. C启动代码</p>

<p>直接执行C代码会造成CPU直接重启，因为和汇编代码不同的是C语言需要初始化运行环境。</p>

<figure class='code'><figcaption><span>sum.c -sum.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>C语言运行环境需要设置
1. 栈
2. 全局变量： 已初始化的 &amp;&amp; 未初始化的
3. 只读数据</p>

<p>2.1 栈设置</p>

<p>栈被用来存储自动变量，传递函数变量，存储返回地址等等。ARM Architecture
Procedure Call Standard
(AAPCS)是ARM体系结构中用于生成栈的规则。r13被用于作栈指针。</p>

<p>对于特定的开发板来说，栈开始地址可能不同，对于connex开发板来说，地址可以用下面的代码来定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ldr sp, =0xA4000000</span></code></pre></td></tr></table></div></figure>


<p>2.2 全局变量</p>

<p>C代码在编译时会把已初始化的全局变量放在.data段中，因而在初始化的汇编代码中，需要把.data段从Flash搬移到RAM中。</p>

<p>C代码确保未初始化的全局变量被初始化成0.
当C程序被编译时，独立的.bss段被用作未初始化的变量。因为未初始化的值都是0,我们无需将其存储在FLASH中。只不过在搬移的时候，我们需要在程序中将它们初始化为0而已。</p>

<p>2.3 只读数据</p>

<p>const常量会被初始化为.rodata， .rodata也被用于存储字符常量。</p>

<p>.rodata在运行时不会被改变，所以它们可以被直接放置在FLASH中。</p>

<p>2.4 启动代码</p>

<p>Linker脚本需要做下面的事：
1. .bss部分代替
2.  vectors部分代替
3. .rodata部分代替</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (vectors);
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        .rodata : {
</span><span class='line'>              * (.rodata);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {
</span><span class='line'>              * (.data);
</span><span class='line'>        }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>
</span><span class='line'>        sbss = .;
</span><span class='line'>        .bss : {
</span><span class='line'>             * (.bss);
</span><span class='line'>        }
</span><span class='line'>        ebss = .;
</span><span class='line'>        bss_size = ebss - sbss;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>启动代码需要完成下列任务：
1. 中断向量设置
2. 将.data部分从FLASH拷贝到RAM
3. 将.bss置0后拷贝到RAM
4. 设置栈指针(stack pointer)
5. 分支程序到main函数</p>

<figure class='code'><figcaption><span>startup.s - startup.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Copy data to RAM.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle data_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_bss
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb   r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs   r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne    copy
</span><span class='line'>
</span><span class='line'>init_bss<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize <span class="m">.</span>bss
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>sbss
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ebss
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>bss_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle bss_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_stack
</span><span class='line'>
</span><span class='line'>        mov   r4<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>zero<span class="o">:</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   zero
</span><span class='line'>
</span><span class='line'>init_stack<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize the stack pointer
</span><span class='line'>        ldr   sp<span class="p">,</span> <span class="o">=</span><span class="mh">0xA4000000</span>
</span><span class='line'>
</span><span class='line'>        bl    main
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b     <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将直接用arm-none-eabi-gcc来编译所有程序：
    arm-none-eabi-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s
-nostdlib选项用于指定标准C不应该被链接。</p>

<p>查看符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>arm-none-eabi-nm -n csum.elf 
</span><span class='line'>00000000 t reset
</span><span class='line'>00000004 A bss_size
</span><span class='line'>00000004 t undef
</span><span class='line'>00000008 t swi
</span><span class='line'>0000000c t pabt
</span><span class='line'>00000010 t dabt
</span><span class='line'>00000018 A data_size
</span><span class='line'>00000018 t irq
</span><span class='line'>0000001c t fiq
</span><span class='line'>00000020 T main
</span><span class='line'>00000094 t start
</span><span class='line'>000000a8 t copy
</span><span class='line'>000000b8 t init_bss
</span><span class='line'>000000d0 t zero
</span><span class='line'>000000dc t init_stack
</span><span class='line'>000000e4 t stop
</span><span class='line'>00000100 r n
</span><span class='line'>00000104 R flash_sdata
</span><span class='line'>a0000000 d arr
</span><span class='line'>a0000000 D ram_sdata
</span><span class='line'>a0000018 D ram_edata
</span><span class='line'>a0000018 D sbss
</span><span class='line'>a0000018 b sum
</span><span class='line'>a000001c B ebss</span></code></pre></td></tr></table></div></figure>


<p>可以看到： 中断向量从0x0开始; 汇编代码从8个全字后开始(0x20==32==8<em>4);
只读数据n放在代码之后; arr，初始化后的数据，放在RAM中;
未初始化的数据,sum放在6个int之后6</em>4==24==0x18</p>

<p>转化成.bin二进制格式后，在Qemu中运行之，检查结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary csum.elf csum.bin  
</span><span class='line'>$ dd if=/dev/zero of=./flash.bin bs=4K count=4K
</span><span class='line'>      $ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc
</span><span class='line'>      $ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>(qemu) xp /6dw 0xa0000000
</span><span class='line'>a0000000:          1         10          4          5
</span><span class='line'>a0000010:          6          7
</span><span class='line'>(qemu) xp /1dw 0xa0000018
</span><span class='line'>a0000018:         33</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，1, 10, 4, 5, 6, 7 分别为数组元素，而结果为33,
储存在0x18的地址。如果感兴趣，我们大可查找出别的数据地址，这里就不一一述说了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/">用Qemu和GNU编译链研究ARM汇编(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T20:50:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:50 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在多个文件构成的程序中，源文件首先被编译成多个对象(object)文件(.o文件),
然后交由链接器生成最终的可执行文件，如下图所示：</p>

<p><img class="img" src="/images/linker.png"></p>

<p>在组建可执行文件时，链接器主要完成下列操作:</p>

<ul>
<li>解析符号</li>
<li>重定位</li>
</ul>


<p>1. 符号解析</p>

<p>在编译单个文件组成的程序时，所有标号的解析都可以由汇编器替代为对应的地址。而在多文件组成的程序中，如果有储存在其他文件中的符号引用，汇编器会将其标识为"unresolved"(未解析).当对象文件被传递给链接器时，链接器从这些文件中决定对应的值，并把code中的unresolved的值替代为正确的值。</p>

<p>我们用上一节的求和函数来演示链接器是如何进行符号解析的。
这两个文件汇编后，会在链接时被检查未被解析的引用。</p>

<figure class='code'><figcaption><span>main.s - main.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>main.s
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>
</span><span class='line'>        bl    sum               <span class="o">@</span> Invoke the sum subroutine
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>sum-sub.s - sum-sub.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="kp">sum</span><span class="o">-</span>sub.s
</span><span class='line'>        <span class="o">@</span> Args
</span><span class='line'>        <span class="o">@</span> r0<span class="o">:</span> Start address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span> r1<span class="o">:</span> End address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span>
</span><span class='line'>        <span class="o">@</span> Result
</span><span class='line'>        <span class="o">@</span> r3<span class="o">:</span> Sum of Array
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>global <span class="kp">sum</span>
</span><span class='line'>
</span><span class='line'><span class="kp">sum</span><span class="o">:</span>    mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *r0++    ; Get array element</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2      <span class="p">;</span> Calculate <span class="kp">sum</span>
</span><span class='line'>        cmp   r0<span class="p">,</span> r1            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r0 <span class="o">!=</span> r1<span class="p">)</span> <span class="p">;</span> Check <span class="kr">if</span> hit end<span class="o">-</span>of<span class="o">-</span><span class="kt">array</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop  <span class="p">;</span> Loop
</span><span class='line'>        mov   pc<span class="p">,</span> lr            <span class="o">@</span> pc <span class="o">=</span> lr       <span class="p">;</span> Return when done
</span></code></pre></td></tr></table></div></figure>


<p>查看.o文件符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm main.o
</span><span class='line'>00000004 t arr
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000008 t start
</span><span class='line'>00000014 t stop
</span><span class='line'>         U sum
</span><span class='line'>$ arm-none-eabi-nm sum-sub.o 
</span><span class='line'>00000004 t loop
</span><span class='line'>00000000 T sum</span></code></pre></td></tr></table></div></figure>


<p>t代表符号已经被定义了， 而u则代表符号未被定义。大写字母表示该符号是全局变量。</p>

<p>从上面的输出结果看，sum是被定义在sum-sub.o的全局变量，而该变量在main.o中未被解析到。当linker被调用时，符号引用将被解析到，对应的可执行文件将被生成。</p>

<p>总结： as程序负责把.s文件编译成object文件，而生成最终的可执行文件时，ld负责把未被定位的符号定位到实际的库函数所在的位置。</p>

<p>2. 重定位.</p>

<p>重定位用于改变已经分配给标号的地址。它包括将所有符号引用映射到新分配的内存地址。</p>

<p>合并段后的符号列表情况，可以对比于上面的main.o和sum-sub.o来看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000000
</span><span class='line'>$ arm-none-eabi-nm sum.elf
</span><span class='line'>00000004 t arr
</span><span class='line'>00008038 T __bss_end__
</span><span class='line'>00008038 T _bss_end__
</span><span class='line'>00008038 T __bss_start
</span><span class='line'>00008038 T __bss_start__
</span><span class='line'>00008038 T __data_start
</span><span class='line'>00008038 T _edata
</span><span class='line'>00008038 T _end
</span><span class='line'>00008038 T __end__
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000024 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000008 t start
</span><span class='line'>         U _start
</span><span class='line'>00000014 t stop
</span><span class='line'>00000020 T sum</span></code></pre></td></tr></table></div></figure>


<p>可以看到stop后面的sum已经被定位好了(之前是main.o中的U标记)，而loop则相应延后，被定位到了再往后的00000024。</p>

<p>地址的变更： loop原本地址为00000004, 现在是00000024, 而sum原本为0x00000000，现在为00000020, 这是因为sum-sub.o中的.text和main.o中的.text部分一起组成了sum.elf中的.text部分。</p>

<p>整体移动某个段到指定内存位置, 注意在-Ttext中我们增加的0x100的偏移量，使得地址对比于上面的结果整体上移了0x100:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x100 -o sum100.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000100
</span><span class='line'>$ arm-none-eabi-nm sum100.elf 
</span><span class='line'>00000104 t arr
</span><span class='line'>00008138 T __bss_end__
</span><span class='line'>00008138 T _bss_end__
</span><span class='line'>00008138 T __bss_start
</span><span class='line'>00008138 T __bss_start__
</span><span class='line'>00008138 T __data_start
</span><span class='line'>00008138 T _edata
</span><span class='line'>00008138 T _end
</span><span class='line'>00008138 T __end__
</span><span class='line'>00000107 t eoa
</span><span class='line'>00000124 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000108 t start
</span><span class='line'>         U _start
</span><span class='line'>00000114 t stop
</span><span class='line'>00000120 T sum</span></code></pre></td></tr></table></div></figure>


<p>3. 重定位.data到RAM中。</p>

<p>我们可以通过撰写链接脚本，将程序的.data段放置在RAM中。这也是通常嵌入式系统所谓bootloader干的活儿，从Flash中加载启动代码到RAM中而后执行。</p>

<p>例程从RAM中加载两个数值，将两者相加而后将结果写回RAM，两个值和结果都放置在.data部分。</p>

<p>代码：</p>

<figure class='code'><figcaption><span>sum_ram.s - sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.4</span>byte <span class="m">0</span>                <span class="o">@</span> <span class="m">4</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>链接脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从connex的内存布局来看，内存地址为0xa000_0000到0xa400_0000，因而A0000000刚好在内存中。</p>

<p>查看链接后的内存符号地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o sum.o sum.s
</span><span class='line'>$ arm-none-eabi-ld -T sum_link.ld -o sum.elf sum.o 
</span><span class='line'>$ arm-none-eabi-nm -n sum.elf 
</span><span class='line'>00000000 t start
</span><span class='line'>0000001c t stop
</span><span class='line'>a0000000 d val1
</span><span class='line'>a0000004 d val2
</span><span class='line'>a0000008 d result</span></code></pre></td></tr></table></div></figure>


<p>这样就完了？NO！！！！！！！！因为：RAM is Volatile! 内存是易变的！</p>

<p>RAM是易失性介质，怎可保证每次加电时就有代码洗干净PP在等着被运行？嵌入式系统里必然有非易失性存储，所有的代码和数据在加电前都需要放在这些非易失性存储介质中，例如在FLASH中。这样在加电后我们就可以利用一段启动代码把代码从FLASH搬到RAM中。</p>

<p>从这个设计思路出发，我们需要程序的.data有两个地址，一个是加载地址，另一个是运行地址。
这就是常说的：LMA(Load Memory Address)  VS    VMA(Virtual Memory Address)。</p>

<p>上面的代码需要做两个修改:</p>

<ol>
<li>需要在.data中指定load地址和运行地址</li>
<li>需要写一段代码用于将数据从FLASH读取到RAM中, 从存储地址到运行地址。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>        etext = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : AT (etext) { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>etext包含了FLASH中放置完地址后的空白地址，记住这个地址以便在接下来将这个数值传送给.data部分，以便程序将.data部分从FLASH拷贝到RAM中。etext只是符号表中的一个，本身并不占据任何内存(可以回去翻上一篇日志)。</p>

<p>关于AT关键字:  它指定了.data部分的加载地址，一个地址或符号被传递给AT关键字，以便它从该地址拷贝数据。 在这里，我们传递etext符号给AT。</p>

<p>要把代码从FLASH拷贝到RAM中，下列信息需要被提供：</p>

<ol>
<li>Flash中数据地址(flash_sdata)</li>
<li>RAM中数据地址(ram_sdata)</li>
<li>.data部分大小(data_size)</li>
</ol>


<p>拷贝代码：</p>

<figure class='code'><figcaption><span>modified_sum_ram.s - modified_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span></code></pre></td></tr></table></div></figure>


<p>由此，我们需要在链接脚本中生成这三个数值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {* (.data); }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ram_sdata为ram中数据开始地址，而ram_edata为结束地址，两者相减则为数据块大小。</p>

<p>改变后的带有copy数据的代码：</p>

<figure class='code'><figcaption><span>final_sum_ram.s - final_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.</span>space <span class="m">4</span>                <span class="o">@</span> <span class="m">1</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Copy data to RAM.
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Add and store result.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用修改过的final_sum_ram.s和link脚本编译，并生成flash.bin后，就可以在qemu-system-arm中验证结果了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information
</span><span class='line'>(qemu) info registers
</span><span class='line'>R00=a0000008 R01=a0000004 R02=0000000a R03=0000001e
</span><span class='line'>R04=00000028 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000038
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000
</span><span class='line'>
</span><span class='line'>(qemu) xp /4dw 0xA0000000
</span><span class='line'>00000000a0000000:         10         30         40          0</span></code></pre></td></tr></table></div></figure>


<p>R04包含了我们相加后的结果, 为0x28=40, R02/R03则分别为操作数10/30. 而通过显示0xA0000000也显示了内存中的值分别为val1/val2/result的值。</p>

<p>接下来的章节中，我们将讲到C代码入口。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-2/">用Qemu和GNU编译链研究ARM汇编(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T16:30:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:30 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>研究两个汇编程序, 通过研究这两个程序，初步了解ARM汇编的知识：</p>

<ul>
<li>用于求数组和的程序</li>
<li>用于计算字符串长度的程序</li>
</ul>


<p>1. 数组求和</p>

<figure class='code'><figcaption><span>sum.s - sum.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>entry<span class="o">:</span>  b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1      @ r2 = *r1++</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2
</span><span class='line'>        cmp   r1<span class="p">,</span> r0            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r1 <span class="o">!=</span> r2<span class="p">)</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>.byte声明：</p>

<p>.byte声明的变量在内存中以连续的比特存在，.2byte和.4byte与之类似，分别用于存储16位值和32位值。联想到C语言中的内建数据结构定义，不难想象char/int/long int 预编译完是哪一种类型。</p>

<p>通用语法结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.byte   exp1, exp2, ...
</span><span class='line'>.2byte  exp1, exp2, ...
</span><span class='line'>.4byte  exp1, exp2, ...</span></code></pre></td></tr></table></div></figure>


<p>你可以指定数据的格式，二进制用前缀0b/0B修饰，八进制以前缀0修饰，十进制/十六进制以0x/0X开头。整数也可以用字符常量来表示，加上单引号即可，在这种情况下ASCII码会被用到。</p>

<p>也可以用C表达式，包含文字和其他符号的组合，如下例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pattern:  .byte 0b01010101, 0b00110011, 0b00001111
</span><span class='line'>npattern: .byte npattern - pattern
</span><span class='line'>halpha:   .byte 'A', 'B', 'C', 'D', 'E', 'F'
</span><span class='line'>dummy:    .4byte 0xDEADBEEF
</span><span class='line'>nalpha:   .byte 'Z' - 'A' + 1</span></code></pre></td></tr></table></div></figure>


<p>.align声明：</p>

<p>ARM指令需要32位对齐，指令的起始内存地址需要是4的倍数，所以用.align指令来插入无用的byte，来确保下一条指令的起始地址是4的倍数。在代码中存在byte或是半字(half words)的时候，需要用到这条指令。</p>

<p>编译&amp;运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># assemble
</span><span class='line'>$ arm-none-eabi-as -o sum.o sum.s 
</span><span class='line'># link to elf file
</span><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf sum.o
</span><span class='line'># form bin file
</span><span class='line'>$ arm-none-eabi-objcopy -O binary sum.elf sum.bin
</span><span class='line'># form flash image
</span><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>$ dd if=sum.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'># emulate with flash image
</span><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'># examine the result
</span><span class='line'>R00=00000007 R01=00000007 R02=00000019 R03=00000037
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000024
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R03的值正是我们求和的结果:  0x37==55==10+20+25, 可以用一张流程图来表示程序的运行过程</p>

<p>2. 字符串长度</p>

<figure class='code'><figcaption><span>string.s - string.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start
</span><span class='line'>
</span><span class='line'>str<span class="o">:</span>    <span class="m">.</span>asciz <span class="s">&quot;Hello World&quot;</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>equ   nul<span class="p">,</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>  ldr   r0<span class="p">,</span> <span class="o">=</span>str          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>str
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *(r0++)</span>
</span><span class='line'>        add   r1<span class="p">,</span> r1<span class="p">,</span> <span class="c1">#1        @ r1 += 1</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#nul          @ if (r1 != nul)</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop
</span><span class='line'>
</span><span class='line'>        sub   r1<span class="p">,</span> r1<span class="p">,</span> <span class="c1">#1        @ r1 -= 1</span>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000010 R01=0000000b R02=00000000 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000002c
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>r1是用来存储字符串长度的，计算结果为11。</p>

<p>.asciz声明:
 .asciz声明接受一个字符串作为参数，字符串以双引号修饰的字符表示。汇编器自动在字符串后面加nul字符（即\0字符）</p>

<p>.equ声明
汇编器维持一张符号表，符号表维持键->值的格式。当汇编器遇到一个标号时，汇编器将在符号表中自动建立一个条目。以后当汇编器遇到一个关于label的引用时，将自动替换为符号表中储存的label的地址。</p>

<p>使用汇编器指令.equ，我们可以手动在符号表中插入条目。</p>

<p>.equ通常这样定义:
    .equ name, expression</p>

<p>.equ不会分配任何内存，它们只是在符号表中插入条目罢了。</p>

<p>bne的意思是(!=) , b means bit. bit not equal. ble (&lt;=), beq (==), bge (>=), bgt (>), and bne (!=).</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/">用Qemu和GNU编译链研究ARM汇编(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-09T20:42:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:42 pm</span></time>
        
         | <a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 汇编程序代码格式</p>

<p>汇编代码由一系列的声明所组成，每行一个。每条声明由下列格式组成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>label(标签):   instruction @comment(注释)</span></code></pre></td></tr></table></div></figure>


<p>说明：</p>

<ul>
<li>label:
标签的引入使得在内存中查询指令地址变得很方便，标签可以在任意一个内存地址使用，
例如分支指令中就可以用到标签, 标签可以包括字母、数字_和$符号。</li>
<li>注释：
注释内容必须在@符号之后</li>
<li>指令:
指令可以是ARM指令集或是汇编器指令，汇编器指令是需要传递给汇编器的命令，总是以.开头。</li>
</ul>


<p>2. 一个简单的汇编语言文件:</p>

<figure class='code'><figcaption><span>add.s -add.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>                       <span class="o">@</span> Label<span class="p">,</span> not really required
</span><span class='line'>        mov   r0<span class="p">,</span> <span class="c1">#5         @ Load register r0 with the value 5</span>
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#4         @ Load register r1 with the value 4</span>
</span><span class='line'>        add   r2<span class="p">,</span> r1<span class="p">,</span> r0     <span class="o">@</span> Add r0 and r1 and store <span class="kr">in</span> r2
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b stop               <span class="o">@</span> Infinite loop to stop execution
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的意思是，把立即数5载入到寄存器r0, 4载入到r1,
以r1和r0相加的结果填充r2.</p>

<p>.text是汇编器指令，用于告知汇编器需要把代码组装到code段,而不是.data段。有关section的概念在后面将被讲到。</p>

<p>3. 编译二进制文件</p>

<p>GNU的汇编器名字叫as， 用下列命令将源文件编译成.o文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o add.o add.s</span></code></pre></td></tr></table></div></figure>


<p>链接器的名字叫ld，用下列命令可以将二进制文件链接成elf文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o</span></code></pre></td></tr></table></div></figure>


<p>-Ttext指明需要分配给label的地址,
这条指令告诉链接器从地址0x0开始装载指令。我们可以用nm来查看具体的地址分配信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm add.elf 
</span><span class='line'>00008010 T __bss_end__
</span><span class='line'>00008010 T _bss_end__
</span><span class='line'>00008010 T __bss_start
</span><span class='line'>00008010 T __bss_start__
</span><span class='line'>00008010 T __data_start
</span><span class='line'>00008010 T _edata
</span><span class='line'>00008010 T _end
</span><span class='line'>00008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000000 t start
</span><span class='line'>         U _start
</span><span class='line'>0000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>start和stop之间由0c个字节，因为stop是在start开始后三条指令，
每条指令的长度为4个Byte，3*4=12=0xc</p>

<p>更改链接的参数将得到不同的地址分配。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 20000000
</span><span class='line'>$ arm-none-eabi-nm add.elf
</span><span class='line'>20008010 T __bss_end__
</span><span class='line'>20008010 T _bss_end__
</span><span class='line'>20008010 T __bss_start
</span><span class='line'>20008010 T __bss_start__
</span><span class='line'>20008010 T __data_start
</span><span class='line'>20008010 T _edata
</span><span class='line'>20008010 T _end
</span><span class='line'>20008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>20000000 t start
</span><span class='line'>         U _start
</span><span class='line'>2000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>ld得到的文件一般是ELF文件，在有操作系统的时候ELF可以工作的很好，但是我们将在裸机模式下(Bare
Metal)运行此程序， 因此需要将文件类型转化为更简单的binary类型。</p>

<p>GNU编译链的objcopy可以完成不同可执行文件之间的转换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary add.elf add.bin
</span><span class='line'>$ file add.bin
</span><span class='line'>add.bin: Hitachi SH big-endian COFF</span></code></pre></td></tr></table></div></figure>


<p>4. 在Qemu中执行二进制文件。</p>

<p>我们将使用connex开发板来模拟运行此程序，它把16MB的Flash放在地址0x0，而通常arm处理器重启时都会执行0x0处的代码。
因而我们需要把add.bin写入到16MB Flash文件的头部。</p>

<p>首先创建一个空的16MB Flash文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>4096+0 records in
</span><span class='line'>4096+0 records out
</span><span class='line'>16777216 bytes (17 MB) copied, 0.0153106 s, 1.1 GB/s</span></code></pre></td></tr></table></div></figure>


<p>而后，使用下列命令将add.bin放到Flash头部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'>0+1 records in
</span><span class='line'>0+1 records out
</span><span class='line'>16 bytes (16 B) copied, 0.00011154 s, 143 kB/s</span></code></pre></td></tr></table></div></figure>


<p>add.bin大小刚好为16B, notrunc参数代表no truncated，意思是直接覆盖掉原有内容。</p>

<p>用下列命令执行此改动后的flash文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information</span></code></pre></td></tr></table></div></figure>


<p>-M connex 指定connex机器， -pflash指定flash.bin代替flash闪存。</p>

<p>-pflash file    use &lsquo;file&rsquo; as a parallel flash image 并行flash镜像</p>

<p>-serial /dev/null 将connex的串口输出重定向到/dev/null</p>

<p>查看寄存器信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000005 R01=00000004 R02=00000009 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000000c
</span><span class='line'>PSR=400001d3 -Z-- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R02的值正是计算后的结果4+5=9.
R15=0000000c 猜测应该为指令寄存器，指向stop(0xc)</p>

<p>5. 更多的查看命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>help  List available commands
</span><span class='line'>quit   Quits the emulator
</span><span class='line'>xp /fmt addr   Physical memory dump from addr
</span><span class='line'>system_reset   Reset the system.</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) help xp
</span><span class='line'>xp /fmt addr -- physical memory dump starting at 'addr'
</span><span class='line'>(qemu) xp /4iw 0x0
</span><span class='line'>0x00000000:  e3a00005      mov    r0, #5  ; 0x5
</span><span class='line'>0x00000004:  e3a01004      mov    r1, #4  ; 0x4
</span><span class='line'>0x00000008:  e0812000      add    r2, r1, r0
</span><span class='line'>0x0000000c:  eafffffe      b  0xc</span></code></pre></td></tr></table></div></figure>


<p>4: 4 个条目被显示, i表示打印出指令，即内建的反汇编，
w表明条目的大小为32个bit，即一个全字。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/">在Qemu上运行Raspberry PI镜像</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T18:09:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:09 pm</span></time>
        
         | <a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载和准备镜像文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://downloads.raspberrypi.org/images/raspbian/2013-05-25-wheezy-raspbian/2013-05-25-wheezy-raspbian.zip
</span><span class='line'>$ unzip 2013-05-25-wheezy-raspbian.zip</span></code></pre></td></tr></table></div></figure>


<p>2. 查看镜像文件分区信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fdisk -l 2013-05-25-wheezy-raspbian.img 
</span><span class='line'>Disk 2013-05-25-wheezy-raspbian.img: 1939 MB, 1939865600 bytes, 3788800 sectors
</span><span class='line'>Units = sectors of 1 * 512 = 512 bytes
</span><span class='line'>Sector size (logical/physical): 512 bytes / 512 bytes
</span><span class='line'>I/O size (minimum/optimal): 512 bytes / 512 bytes
</span><span class='line'>Disk label type: dos
</span><span class='line'>Disk identifier: 0x000c7b31
</span><span class='line'>
</span><span class='line'>                         Device Boot      Start         End      Blocks   Id
</span><span class='line'>System
</span><span class='line'>2013-05-25-wheezy-raspbian.img1            8192      122879       57344    c  W95 FAT32 (LBA)
</span><span class='line'>2013-05-25-wheezy-raspbian.img2          122880     3788799     1832960   83  Linux</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看到，根文件分区的地址偏移为512*122880=62914560</p>

<p>3. 更改根分区文件里preload信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo mount ./2013-05-25-wheezy-raspbian.img -o offset=62914560 /mnt3
</span><span class='line'>$ sudo vim /mnt3/etc/ld.so.preload 
</span><span class='line'>#注释掉这一行，否则在qemu启动完系统后将自动提示配置rpi而造成系统无法登陆
</span><span class='line'>#/usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class='line'>$ sudo umount /mnt3</span></code></pre></td></tr></table></div></figure>


<p>4. 用qemu-system-arm启动raspberrypi镜像</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -kernel kernel-qemu -cpu arm1176 -m 256 -M versatilepb \
</span><span class='line'>-no-reboot -serial stdio -append "root=/dev/sda2 panic=1" -hda \
</span><span class='line'>./2013-05-25-wheezy-raspbian.img </span></code></pre></td></tr></table></div></figure>


<p>系统将启动到一个root登陆的无需密码的shell中，运行下列命令以修复文件系统:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fsck /dev/sda2
</span><span class='line'>$ shutdown -r now</span></code></pre></td></tr></table></div></figure>


<p>再次启动完毕后的登陆用户名和密码如下，接下来就等同于原机操作了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Login as pi
</span><span class='line'>Password raspberry</span></code></pre></td></tr></table></div></figure>


<p>5. ArchLinux on RaspberryPI</p>

<p>基本步骤也是一样，挂在第2块分区后，需要更改etc/fstab做下列修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;          &lt;dump&gt; &lt;pass&gt;
</span><span class='line'>/dev/sda1   /boot           vfat    defaults        0       0
</span><span class='line'>/dev/sda2   /     auto    defaults        0       0</span></code></pre></td></tr></table></div></figure>


<p>之后挂载命令一样。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/">用Qemu模拟ARM(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T16:35:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:35 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载并交叉编译u-boot。</p>

<p>新版本的u-boot我加载后总有问题，2009.11版则可以顺利通过编译和测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget ftp://ftp.denx.de/pub/u-boot/u-boot-2009.11.tar.bz2
</span><span class='line'>$ tar xjvf u-boot-2009.11.tar.bz2 
</span><span class='line'>$ cd u-boot-2009.11
</span><span class='line'>$ make versatilepb_config arch=ARM CROSS_COMPILE=arm-none-eabi-
</span><span class='line'>$ make all arch=ARM CROSS_COMPILE=arm-none-eabi- </span></code></pre></td></tr></table></div></figure>


<p>编译完成后会在目录下生成u-boot.bin和u-boot文件。</p>

<p>2. 运行u-boot.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel u-boot.bin -nographic</span></code></pre></td></tr></table></div></figure>


<p>如果采用-nographic来运行qemu-system-arm，终端将无法再响应任何系统输入譬如Ctrl+c/ctrl+d_，要终止qemu-system-arm就只能查到进程号再kill。所以我一般不带-nographic选项，启动后ctrl+alt+2去看serial0输出,保留在终端窗口直接ctrl+c杀死qemu-sytem-arm进程的权力。</p>

<p>3. 用u-boot引导镜像文件:</p>

<p>改动上一篇文章里用于构建启动镜像的linker.ld文件，因为u-boot.bin文件大小的缘故，我们需要把启动镜像的起始地址整体上移.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h u-boot.bin 
</span><span class='line'>-rwxr-xr-x 1 Trusty root 85K Jul  8 15:57 u-boot.bin</span></code></pre></td></tr></table></div></figure>


<p>linker.ld文件里， 0x100000，这个大小相比于85K显然已经足够。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>SECTIONS
</span><span class='line'>{
</span><span class='line'>. = 0x100000;
</span><span class='line'>startup : { startup.o(.text)}
</span><span class='line'>.data : {*(.data)}
</span><span class='line'>.bss : {*(.bss)}
</span><span class='line'>. = . + 0x500;
</span><span class='line'>sp_top = .;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>按上一章的编译方法生成output.bin，不再重述。</p>

<p>使用mkimage工具创建u-boot可识别的image文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkimage -A arm -C none -O linux -T kernel -d output.bin -a 0x00100000 -e 0x00100000 output.uimg
</span><span class='line'>Image Name:   
</span><span class='line'>Created:      Mon Jul  8 16:04:11 2013
</span><span class='line'>Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>Data Size:    152 Bytes = 0.15 kB = 0.00 MB
</span><span class='line'>Load Address: 00100000
</span><span class='line'>Entry Point:  00100000
</span><span class='line'>
</span><span class='line'>$ file *.uimg
</span><span class='line'>output.uimg: u-boot legacy uImage, , Linux/ARM, OS Kernel Image (Not \
</span><span class='line'>compressed), 152 bytes, Mon Jul  8 16:04:11 2013, Load Address: 0x00100000,\
</span><span class='line'>Entry Point: 0x00100000, Header CRC: 0x3C62F575, Data CRC: 0x69CE9647</span></code></pre></td></tr></table></div></figure>


<p>将u-boot.bin和output.uimg打包为一个文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat u-boot.bin output.uimg &gt;flash.bin</span></code></pre></td></tr></table></div></figure>


<p>下面这条命令用于计算output.img在使用u-boot加载完flash.bin后在内存中的地址，-kernel选项告诉qemu从0x100000开始加载镜像，即65536。
65536+u-boot.bin后的大小，即output.img在内存中的地址。printf则是用16进制的格式打印出来，以便加载.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ printf "0x%X" $(expr $(stat -c%s u-boot.bin) + 65536)
</span><span class='line'>0x2525C</span></code></pre></td></tr></table></div></figure>


<p>启动qemu-system-arm并运行自定义镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel flash.bin
</span><span class='line'># iminfo 0x2525c
</span><span class='line'>
</span><span class='line'>## Checking Image at 0002525c ...
</span><span class='line'>   Legacy image found
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Verifying Checksum ... OK
</span><span class='line'>
</span><span class='line'>VersatilePB # bootm 0x2525c
</span><span class='line'>## Booting kernel from Legacy Image at 0002525c ...
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Loading Kernel Image ... OK
</span><span class='line'>OK
</span><span class='line'>
</span><span class='line'>Starting kernel ...
</span><span class='line'>
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>u-boot可以支持的选项还有很多，包括使用NFS/TFTP启动等等，留待以后慢慢研究。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/57">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/55">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/25/awesomes-battery-indicator/">Awesome's Battery Indicator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/18/tips-on-archlinux-on-ssd-for-surfacepro/">Tips on ArchLinux on SSD for SurfacePro</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/16/spice-client/">Spice Client</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/13/win10-tips-for-using-xshell/">Win10 Tips for Using Xshell</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/13/variety/">Variety</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Dash -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dashsagittariussglory';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
