
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dash</title>
  <meta name="author" content="Dash">

  
  <meta name="description" content="Pogoplug上了debian wheezy后，想配置成VPN服务器，在最后一步配置iptables时发现无法激活NAT表。 显示结果为： 1
2
$ iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://purplepalmdash.github.io/posts/48">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/purplepalmdash/atom.xml" rel="alternate" title="Dash" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Dash</a></h1>
  
    <h2>Get busy living, or get busy dying.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/purplepalmdash/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:purplepalmdash.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/03/add-netfilter-nat-for-pogoplug/">Add Netfilter NAT for Pogoplug</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-03T16:06:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>4:06 pm</span></time>
        
         | <a href="/blog/2013/09/03/add-netfilter-nat-for-pogoplug/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Pogoplug上了debian wheezy后，想配置成VPN服务器，在最后一步配置iptables时发现无法激活NAT表。</p>

<p>显示结果为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ iptables -t nat -A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
</span><span class='line'>can't initialize iptables table 'NAT': Table does not exist (do you need to insmod?)</span></code></pre></td></tr></table></div></figure>


<p>解决方法:重新编译NetFilter模块。</p>

<p>下载Linux3.1.10内核并解压到/usr/src</p>

<p>$ make menuconfig</p>

<p><img class="img" src="/images/2013_09_03_12_53_06_868x411.jpg"></p>

<p>而后：</p>

<p><img class="img" src="/images/2013_09_03_12_54_08_749x362.jpg"></p>

<p>确保以下选项被激活：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CONFIG_NF_CONNTRACK
</span><span class='line'>CONFIG_NF_CONNTRACK_IPV4
</span><span class='line'>CONFIG_NF_NAT
</span><span class='line'>CONFIG_IP_NF_IPTABLES</span></code></pre></td></tr></table></div></figure>


<p>而后编译，由于在嵌入式系统上编译速度较慢，所以只是编译目录下对应的模块，其他的则不编：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make M=net/netfilter modules  # Make all modules in specified dir
</span><span class='line'>$ make M=net/netfilter          # Same as 'make M=dir modules'
</span><span class='line'>$ make M=net/netfilter  modules_install # Install modules</span></code></pre></td></tr></table></div></figure>


<p>这样就应该可以了，具体的验证等回家再看。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/03/using-tsocks-for-acrossing-the-company-firewall/">Using Tsocks for Acrossing the Company Firewall</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-03T09:57:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>9:57 am</span></time>
        
         | <a href="/blog/2013/09/03/using-tsocks-for-acrossing-the-company-firewall/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 在家庭主机上配置DDNS服务，可以从no-ip.com申请一个免费的动态域名。no-ip同时提供了适用于不同平台的客户端，可以在其主页下载，并在家庭主机上安装之。家里的路由器上也可以配置DDNS，国内的可以用花生壳服务，而后开放DMZ主机给内网的主机即可。家庭主机需要开启sshd服务，这方面可以参考网上的有关ssh服务器的配置攻略</p>

<p>2. 在公司主机上，使用下列命令即可建立ssh代理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -qTfnN -D 1394 xxx@xxx.no-ip.biz</span></code></pre></td></tr></table></div></figure>


<p>命令详解:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-q Quite模式
</span><span class='line'>-T 不分配伪终端
</span><span class='line'>-f ssh后台运行
</span><span class='line'>-n 将标准输入重定向到/dev/null
</span><span class='line'>-N 不执行远程命令
</span><span class='line'>-D 绑定本地端口1394</span></code></pre></td></tr></table></div></figure>


<p>接下来我们就可以使用本地的端口127.0.0.1:1394作为socket代理服务器了。</p>

<p>3. 安装tsocks, 并配置.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S tsocks
</span><span class='line'>$ vim /etc/tsocks.conf
</span><span class='line'>server = 127.0.0.1
</span><span class='line'>server_type = 5
</span><span class='line'>server_port = 1394</span></code></pre></td></tr></table></div></figure>


<p>4. 使用tsocks运行出一个完全自由的终端：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tsocks gnome-terminal</span></code></pre></td></tr></table></div></figure>


<p>在新弹出的终端内，无需设置任何代理即可自由访问各处资源，衍生于该终端的应用程序也可以直接享用家庭网络的自由权限。enjoy it!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/03/archlinux-ntp-update-time/">ArchLinux Ntp Update Time</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-03T07:47:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>7:47 am</span></time>
        
         | <a href="/blog/2013/09/03/archlinux-ntp-update-time/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 安装ntpd</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S ntpd</span></code></pre></td></tr></table></div></figure>


<p>2. 配置ntp服务器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /etc/ntp.conf
</span><span class='line'>server 0.pool.ntp.org iburst
</span><span class='line'>server 1.pool.ntp.org iburst
</span><span class='line'>server 2.pool.ntp.org iburst
</span><span class='line'>server 3.pool.ntp.org iburst</span></code></pre></td></tr></table></div></figure>


<p>3. 同步时间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ntpd -gq</span></code></pre></td></tr></table></div></figure>


<p>4. 加入守护进程运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo systemctl enable ntpd</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/28/pure-c-in-arduino/">Pure C in Arduino</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-28T17:31:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>5:31 pm</span></time>
        
         | <a href="/blog/2013/08/28/pure-c-in-arduino/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 输入.c文件，用于点亮arduino板上的LED，默认为pin 5口</p>

<figure class='code'><figcaption><span>led.c - led.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;avr/io.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;util/delay.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'> <span class="n">BLINK_DELAY_MS</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="cm">/* set pin 5 of PORTB for output*/</span>
</span><span class='line'> <span class="n">DDRB</span> <span class="o">|=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">DDB5</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/* set pin 5 high to turn led on */</span>
</span><span class='line'>  <span class="n">PORTB</span> <span class="o">|=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">PORTB5</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_delay_ms</span><span class="p">(</span><span class="n">BLINK_DELAY_MS</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* set pin 5 low to turn led off */</span>
</span><span class='line'>  <span class="n">PORTB</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_BV</span><span class="p">(</span><span class="n">PORTB5</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_delay_ms</span><span class="p">(</span><span class="n">BLINK_DELAY_MS</span><span class="p">);</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2. 编译并生成映像文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ avr-gcc -Os -DF_CPU=16000000UL -mmcu=atmega328p -c -o led.o led.c
</span><span class='line'>$ avr-gcc -mmcu=atmega328p led.o -o led
</span><span class='line'>$ avr-objcopy -O ihex -R .eeprom led led.hex</span></code></pre></td></tr></table></div></figure>


<p>3. 使用avrdude上传之</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/media/y/arduino/1.0.5/hardware/tools/avrdude -C/media/y/arduino/1.0.5/hardware/tools/avrdude.conf -v -v -v -v -patmega328p -carduino -P/dev/ttyUSB0 -b57600 -D -Uflash:w:led.hex:i</span></code></pre></td></tr></table></div></figure>


<p>上传完毕后板子会自动运行新上传的文件。
感觉用purec来开发的灵活性会比较强。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/25/olimex-refer/">Olimex Refer</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-25T16:52:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:52 pm</span></time>
        
         | <a href="/blog/2013/07/25/olimex-refer/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>It seems this board is good:</p>

<p>OpenWRT trunk for imx233-OLinuXino now have 3220 packages <a href="http://olimex.wordpress.com/2013/07/24/openwrt-for-imx233-olinuxino-trunk-now-with-3220-packages/">http://olimex.wordpress.com/2013/07/24/openwrt-for-imx233-olinuxino-trunk-now-with-3220-packages/</a> …</p>

<p>Taobao Address:
<a href="http://item.taobao.com/item.htm?spm=a230r.1.14.7.WT8tYl&amp;id=21117476143">http://item.taobao.com/item.htm?spm=a230r.1.14.7.WT8tYl&amp;id=21117476143</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/15/arduinobi-ji-2/">Arduino笔记(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-15T16:33:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:33 pm</span></time>
        
         | <a href="/blog/2013/07/15/arduinobi-ji-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. PWM概念：
PWM( Pulse Width Modulation).简单来说，在arduino中我们可以理解为就是通过调节占空比来实现不同电压输出。</p>

<p>图片：</p>

<p>2. analogWrite()</p>

<p>描述</p>

<p>从一个引脚输出模拟值（PWM）。可用于让LED以不同的亮度点亮或驱动电机以不同的速度旋转。analogWrite()输出结束后，该引脚将产生一个稳定的特殊占空比方波，直到下次调用analogWrite()（或在同一引脚调用digitalRead()或digitalWrite()）。PWM信号的频率大约是490赫兹。</p>

<p>在大多数arduino板（ATmega168或ATmega328），只有引脚3，5，6，9，10和11可以实现该功能。在aduino Mega上，引脚2到13可以实现该功能。老的Arduino板（ATmega8）的只有引脚9、10、11可以使用analogWrite()。在使用analogWrite()前，你不需要调用pinMode()来设置引脚为输出引脚。</p>

<p>analogWrite函数与模拟引脚、analogRead函数没有直接关系。</p>

<p>通过读取电位器的阻值控制LED的亮度</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ledPin = 9;  // LED连接到数字引脚9
</span><span class='line'>int analogPin = 3;  //电位器连接到模拟引脚3
</span><span class='line'>int val = 0;  //定义变量存以储读值
</span><span class='line'> 
</span><span class='line'>void setup()
</span><span class='line'> 
</span><span class='line'>{
</span><span class='line'>pinMode（ledPin,OUTPUT）;  //设置引脚为输出引脚
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>val = analogRead（analogPin）;  //从输入引脚读取数值
</span><span class='line'>analogWrite（ledPin，val / 4）;  // 以val / 4的数值点亮LED（因为analogRead读取的数值从0到1023，而analogWrite输出的数值从0到255）
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3. 调节PWM值的程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int n=0;
</span><span class='line'>void setup ()
</span><span class='line'>{
</span><span class='line'>  pinMode(4,INPUT);
</span><span class='line'>  pinMode(6,OUTPUT);      //该端口需要选择有#号标识的数字口
</span><span class='line'>  pinMode(10,INPUT);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  int up =digitalRead(4);          //读取4号口的状态
</span><span class='line'>  int down = digitalRead(10);      //读取10号口的状态   
</span><span class='line'>  if (up==HIGH)                    //判断4号口目前是否是高电平
</span><span class='line'>  { 
</span><span class='line'>   n=n+5;                         //每次累加值为5
</span><span class='line'>    if (n>=255) {
</span><span class='line'>      n=255;
</span><span class='line'>    }            //限定最大值为255   
</span><span class='line'>analogWrite(6,n);               //使用PWM控制6号口输出，变量n的取值范围是0-255 
</span><span class='line'>    delay (300);
</span><span class='line'>  }
</span><span class='line'>  if (down==HIGH)                    //减少亮度
</span><span class='line'>  {
</span><span class='line'>   n=n-5;
</span><span class='line'>    if (n&lt;=0) {
</span><span class='line'>      n=0;
</span><span class='line'>    }
</span><span class='line'> analogWrite(6,n);
</span><span class='line'>    delay (300);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>需要选择#号标识的数字口是因为这些端口需要支持PWM功能。而后在loop()函数中，将修改后的n值输出到6号端口。</p>

<p>4. analogRead()</p>

<p>描述</p>

<p>从指定的模拟引脚读取数据值。
Arduino板包含一个6通道（Mini和Nano有8个通道，Mega有16个通道），10位模拟数字转换器。这意味着它将0至5伏特之间的输入电压映射到0至1023之间的整数值。这将产生读数之间的关系：5伏特/
1024单位，或0.0049伏特（4.9
mV）每单位。输入范围和精度可以使用analogReference()改变。
它需要大约100微秒（0.0001）来读取模拟输入，所以最大的阅读速度是每秒10000次。</p>

<p>语法</p>

<p>analogRead（PIN）</p>

<p>数值的读取</p>

<p>引脚：从输入引脚（大部分板子从0到5，Mini和Nano从0到7，Mega从0到15）读取数值</p>

<p>返回</p>

<p>从0到1023的整数值</p>

<p>5. 实现呼吸灯：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup ()
</span><span class='line'>{
</span><span class='line'>  pinMode(11,OUTPUT);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  for (int a=0; a&lt;=255;a++)                //循环语句，控制PWM亮度的增加
</span><span class='line'>  {
</span><span class='line'>    analogWrite(11,a);
</span><span class='line'>    delay(16);                             //当前亮度级别维持的时间,单位毫秒            
</span><span class='line'>  }
</span><span class='line'>    for (int a=255; a>=0;a--)             //循环语句，控制PWM亮度减小
</span><span class='line'>  {
</span><span class='line'>    analogWrite(11,a);
</span><span class='line'>    delay(16);                             //当前亮度的维持的时间,单位毫秒  
</span><span class='line'>  }
</span><span class='line'>  delay(800);                             //完成一个循环后等待的时间,单位毫秒
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>或者：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int n = 0; // n 从 1 至 255，控制led亮度
</span><span class='line'>int i = 5;  // 递进数
</span><span class='line'>
</span><span class='line'>void setup()
</span><span class='line'>{
</span><span class='line'>  pinMode( 11, OUTPUT); //设置11口为PWM输出端
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  n += i;                               // n每次增加 i 
</span><span class='line'>
</span><span class='line'>  
</span><span class='line'>
</span><span class='line'>  if ( n == 255 || n == 0)
</span><span class='line'>//在n升至255或者降至0时，i进行反转。这样led灯能在亮暗间转换
</span><span class='line'>   i = -i; 
</span><span class='line'>
</span><span class='line'>  analogWrite( 11, n );
</span><span class='line'>  delay( 50 );       //延迟50ms，进行下一次亮度调整
</span><span class='line'>  
</span><span class='line'>   if( n == 0)
</span><span class='line'>     delay(1800);
</span><span class='line'>  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>6. 实现温度计</p>

<p>主要器件LM315.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup() {
</span><span class='line'> 
</span><span class='line'>  Serial.begin(9600);         //使用9600速率进行串口通讯
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void loop() {
</span><span class='line'> 
</span><span class='line'>  int n = analogRead(A0);    //读取A0口的电压值
</span><span class='line'> 
</span><span class='line'>  float vol = n * (5.0 / 1023.0*100);
</span><span class='line'>//使用浮点数存储温度数据，温度数据由电压值换算得到
</span><span class='line'> 
</span><span class='line'>  Serial.println(vol);                   //串口输出温度数据
</span><span class='line'>  delay(2000);                           //等待2秒，控制刷新速度
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Serial.begin()</p>

<p>将串行数据传输速率设置为位/秒（波特）。与计算机进行通信时，可以使用这些波特率：300，1200，2400，4800，9600，14400，19200，28800，38400，57600或115200。当然，您也可以指定其他波特率- 例如，引脚0和1和一个元件进行通信，它需要一个特定的波特率。</p>

<p>Serial.println()
打印数据到串行端口，输出人们可识别的ASCII码文本并回车 (ASCII 13, 或 &lsquo;\r&rsquo;) 及换行(ASCII 10, 或 &lsquo;\n&rsquo;)。此命令采用的形式与Serial.print ()相同 。</p>

<p>和DS18b20有什么区别？</p>

<p>DS18b20是数字的，数字的出来的是方波，用脉冲方波和协议来通讯，模拟的出来的是电压，利用AD转换（ARDUINO的模拟脚可以理解为就是数字脚+AD/DA转换模块，如果你需要大量的模拟脚但是不要求数字脚，可以直接外接AD/DA转换器来实现）来得到测量值并换算成温度</p>

<p>0-100度 对应0-5v  模拟口返回数值0-1024  所以。模拟口的值 1=0.48828125</p>

<p>7. 光敏电阻的程序改动：</p>

<p>&ldquo;达文西的手电筒"，有光才能亮，没光，绝对不会亮！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int a =300;     //此处需是环境基础亮度变量，请查看自己的亮度数值，
</span><span class='line'>                //填写到此处数值要略大于所测得的数据但小于灯光下的数据
</span><span class='line'>void setup ()
</span><span class='line'>{
</span><span class='line'>  Serial.begin(9600);
</span><span class='line'>  pinMode(13,OUTPUT);
</span><span class='line'>}
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  int n = analogRead(A0);            //读取模拟口A0数值
</span><span class='line'>  Serial.println(n);
</span><span class='line'>  if (n>= a )                   //对光线强度进行判断，如果比我们的预设值大
</span><span class='line'>就点亮LED否则就关闭
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,HIGH);
</span><span class='line'>  }
</span><span class='line'>  else
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,LOW);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>修改为符合逻辑的光控电路：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 光强度小于临界值 */
</span><span class='line'>if ( n &lt; a)
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,HIGH);        // 点亮LED
</span><span class='line'>  }
</span><span class='line'>  else
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(13,LOW);     // 超过临界值时，关闭
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p> 光敏三极管有凸起的一边为发射极，此端接A0检测口，同时并联一个10K欧姆的分压电阻到地线以扩展光敏三极管的灵敏度（此处电阻越小灵敏度越高）。另一极使用5V输入。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/15/ardiunobi-ji-1/">Arduino笔记(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-15T09:39:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:39 am</span></time>
        
         | <a href="/blog/2013/07/15/ardiunobi-ji-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 稳压IC的作用：</p>

<p>稳压器IC就是使输出电压稳定的设备中的电子元器件。所有的稳压器，都利用了相同的技术实现输出电压的稳定输出电压通过连接到误差放大器（Error Amplifier）反相输入端（Inverting Input）的分压电阻（Resistive Divider）采样（Sampled），误差放大器的同相输入端（Non-inverting Input）连接到一个参考电压Vref。 参考电压由IC内部的带隙参考源(Bandgap Reference)产生。误差放大器总是试图迫使其两端输入相等。为此，它提供负载电流以保证输出电压稳定。</p>

<p>2. ICSP(In-circuit serial programming)</p>

<p>3. FT232: USB->UART</p>

<p> The FT232BM is the 2nd generation of FTDI&rsquo;s popular USB UART device and the FT232BL is a lead free version of it.  The FT232BQ provides the same functionality as the FT232BM and FT232BL in a QFN-32 lead free package.</p>

<p>4. ATmega328P Parameters:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Parameter        Value
</span><span class='line'>Flash (Kbytes):       32 Kbytes
</span><span class='line'>Pin Count:        32
</span><span class='line'>Max. Operating Frequency: 20 MHz
</span><span class='line'>CPU:          8-bit AVR
</span><span class='line'># of Touch Channels:  16
</span><span class='line'>Hardware QTouch Acquisition: No
</span><span class='line'>Max I/O Pins:     23
</span><span class='line'>Ext Interrupts:       24
</span><span class='line'>USB Speed:        No
</span><span class='line'>USB Interface:        No
</span><span class='line'>SPI:          2
</span><span class='line'>TWI (I2C):        1
</span><span class='line'>UART:         1
</span><span class='line'>Graphic LCD:      No
</span><span class='line'>Video Decoder:        No
</span><span class='line'>Camera Interface: No
</span><span class='line'>ADC channels:     8
</span><span class='line'>ADC Resolution (bits):    10
</span><span class='line'>ADC Speed (ksps): 15
</span><span class='line'>Analog Comparators:   1
</span><span class='line'>Resistive Touch Screen:   No
</span><span class='line'>DAC Resolution (bits):    0
</span><span class='line'>Temp. Sensor:     Yes
</span><span class='line'>Crypto Engine:        No
</span><span class='line'>SRAM (Kbytes):        2
</span><span class='line'>EEPROM (Bytes):       1024
</span><span class='line'>Self Program Memory:  YES
</span><span class='line'>External Bus Interface:   0
</span><span class='line'>DRAM Memory:      No
</span><span class='line'>NAND Interface:       No
</span><span class='line'>picoPower:        Yes
</span><span class='line'>Temp. Range (deg C):  -40 to 85
</span><span class='line'>I/O Supply Class: 1.8 to 5.5
</span><span class='line'>Operating Voltage (Vcc):1.8 to 5.5
</span><span class='line'>FPU:          No
</span><span class='line'>MPU / MMU:        no / no
</span><span class='line'>Timers:           3
</span><span class='line'>Output Compare channels:  6
</span><span class='line'>Input Capture Channels:       1
</span><span class='line'>PWM Channels:     6
</span><span class='line'>32kHz RTC:        Yes
</span><span class='line'>Calibrated RC Oscillator: Yes
</span><span class='line'>Watchdog:     Yes</span></code></pre></td></tr></table></div></figure>


<p>5. ATmega328P主要特性如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>高性能、低功耗的 8 位AVR 微处理器
</span><span class='line'>先进的RISC 结构
</span><span class='line'>131 条指令 – 大多数指令执行时间为单个时钟周期
</span><span class='line'>32 个8 位通用工作寄存器
</span><span class='line'>全静态工作
</span><span class='line'>工作于20 MHz 时性能高达20 MIPS
</span><span class='line'>只需两个时钟周期的硬件乘法器
</span><span class='line'>非易失性程序和数据存储器
</span><span class='line'>32K字节的系统内可编程Flash
</span><span class='line'>擦写寿命: 10,000 次
</span><span class='line'>具有独立锁定位的可选Boot 代码区
</span><span class='line'>通过片上Boot 程序实现系统内编程
</span><span class='line'>真正的同时读写操作
</span><span class='line'>1024字节的EEPROM
</span><span class='line'>擦写寿命: 100,000 次
</span><span class='line'>2K字节的片内SRAM
</span><span class='line'>可以对锁定位进行编程以实现用户程序的加密
</span><span class='line'>外设特点
</span><span class='line'>两个具有独立预分频器和比较器功能的8位定时器/计数器
</span><span class='line'>一个具有预分频器、比较功能和捕捉功能的16位定时器/计数器
</span><span class='line'>具有独立振荡器的实时计数器RTC
</span><span class='line'>六通道PWM
</span><span class='line'>8路10 位ADC
</span><span class='line'>可编程的串行USART
</span><span class='line'>可工作于主机/ 从机模式的SPI 串行接口
</span><span class='line'>基于字节的2-wire串行接口
</span><span class='line'>具有独立片内振荡器的可编程看门狗定时器
</span><span class='line'>片内模拟比较器
</span><span class='line'>引脚电平变化可引发中断及唤醒MCU
</span><span class='line'>特殊的微控制器特点
</span><span class='line'>上电复位(POR) 以及可编程的掉电检测(BOD)
</span><span class='line'>经过校准的片内RC 振荡器
</span><span class='line'>片内、片外中断源
</span><span class='line'>6种休眠模式：空闲模式、ADC 噪声抑制模式、省电模式、掉电模式、待机模式和延长待机模式
</span><span class='line'>I/O 和封装
</span><span class='line'>23个可编程的I/O 口
</span><span class='line'>28引脚PDIP，32引脚TQFP，28引脚QFN/MLF，与32引脚QFN/MLF封装
</span><span class='line'>工作电压
</span><span class='line'>1.8 - 5.5V
</span><span class='line'>工作温度范围:
</span><span class='line'>-40℃至85℃
</span><span class='line'>工作速度等级
</span><span class='line'>0 - 20 MHz @ 1.8 - 5.5V
</span><span class='line'>超低功耗
</span><span class='line'>正常模式：
</span><span class='line'>1 MHz, 1.8V, 25°C: 0.2 mA
</span><span class='line'>掉电模式:
</span><span class='line'>1.8V, 0.1 μA
</span><span class='line'>省电模式:
</span><span class='line'>1.8V, 0.75 μA</span></code></pre></td></tr></table></div></figure>


<p>6. LED闪烁测试程序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Let the LED shinning per 1 seconds 
</span><span class='line'> */
</span><span class='line'> 
</span><span class='line'> void setup()
</span><span class='line'> {
</span><span class='line'>   // Arduino's port 13 has a LED
</span><span class='line'>   pinMode(13, OUTPUT);
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> void loop()
</span><span class='line'> {
</span><span class='line'>   digitalWrite(13, HIGH);  // LED is on
</span><span class='line'>   delay(1000);             // Last for 1 second
</span><span class='line'>   digitalWrite(13, LOW);   // LED is off
</span><span class='line'>   delay(1000);             // Last for 1 second
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>在Arduino中程序运行时将首先调用 setup() 函数。用于初始化变量、设置针脚的输出\输入类型、配置串口、引入类库文件等等。每次 Arduino 上电或重启后，setup 函数只运行一次。</p>

<p>pinMode(): 将指定的引脚配置成输出或输入。详情请见digital pins。</p>

<p>在 setup() 函数中初始化和定义了变量，然后执行 loop() 函数。顾名思义,该函数在程序运行过程中不断的循环，根据一些反馈,相应改变执行情况。通过该函数动态控制 Arduino 主控板。</p>

<p>digitalWrite() 给一个数字引脚写入HIGH或者LOW。</p>

<p>如果一个引脚已经使用pinMode()配置为OUTPUT模式，其电压将被设置为相应的值，HIGH为5V（3.3V控制板上为3.3V），LOW为0V。</p>

<p>如果引脚配置为INPUT模式，使用digitalWrite()写入HIGH值，将使内部20K上拉电阻（详见数字引脚教程）。写入LOW将会禁用上拉。上拉电阻可以点亮一个LED让其微微亮，如果LED工作，但是亮度很低，可能是因为这个原因引起的。补救的办法是 使用pinMode()函数设置为输出引脚。</p>

<p>注意：数字13号引脚难以作为数字输入使用，因为大部分的控制板上使用了一颗LED与一个电阻连接到他。如果启动了内部的20K上拉电阻，他的电压将在1.7V左右，而不是正常的5V，因为板载LED串联的电阻把他使他降了下来，这意味着他返回的值总是LOW。如果必须使用数字13号引脚的输入模式，需要使用外部上拉下拉电阻。</p>

<p>delay(): 使程序暂定设定的时间（单位毫秒）。（一秒等于1000毫秒）</p>

<p>编译并烧入到开发板后，可以看到系统的LED灯开始闪烁。</p>

<p>7. 更多的LED</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup()
</span><span class='line'>{
</span><span class='line'>  for (int i=2; i&lt;=7; i++)    //通过循环的方式设置2-7号引脚为输出状态
</span><span class='line'>  {
</span><span class='line'>    pinMode(i,OUTPUT);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  for (int x=2; x&lt;=7; x++)
</span><span class='line'>//通过循环的方式依次让每个引脚的led在1秒内完成明灭
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(x,HIGH);
</span><span class='line'>    delay(500);
</span><span class='line'>    digitalWrite(x,LOW);
</span><span class='line'>    delay(500);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/12/qemukuai-su-bao-cun-he-hui-fu-zhuang-tai/">Qemu快速保存和恢复状态</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-12T09:41:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:41 am</span></time>
        
         | <a href="/blog/2013/07/12/qemukuai-su-bao-cun-he-hui-fu-zhuang-tai/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 启动镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda hd.qcow2</span></code></pre></td></tr></table></div></figure>


<p>2. 保存当前运行状态：</p>

<p>同时按下ctrl+alt+2切换到Qemu内建命令行，输入:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) savevm booted</span></code></pre></td></tr></table></div></figure>


<p>如果需要即时回复到保存时状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) loadvm booted</span></code></pre></td></tr></table></div></figure>


<p>关闭Qemu运行窗口</p>

<p>3. 快速恢复到保存状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda hd.qcow2 -loadvm booted</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/">用Qemu和GNU编译链研究ARM汇编(4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-11T21:46:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:46 pm</span></time>
        
         | <a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 有关异常向量</p>

<p>前面的例子中存在一个大BUG，内存布局中的前8个全字是为异常向量而保留的。当异常发生时控制逻辑将转到这些位置以执行对应的异常处理代码。异常向量和它们的地址如下：</p>

<ul>
<li>Exception  Address</li>
<li>Reset  0x00</li>
<li>Undefined Instruction  0x04</li>
<li>Software Interrupt (SWI)   0x08</li>
<li>Prefetch Abort     0x0C</li>
<li>Data Abort     0x10</li>
<li>Reserved, not used     0x14</li>
<li>IRQ    0x18</li>
<li>FIQ    0x1C</li>
</ul>


<p>按理说，这些个异常向量应该对应到异常处理程序中，既然我们代码中不会有异常发生，索性就用死循环来代替，如下：</p>

<figure class='code'><figcaption><span>vector.s -vector.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span></code></pre></td></tr></table></div></figure>


<p>对应的，为了确保这些指令被放置在异常向量地址中，链接脚本也需要做相应的改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>                * (vectors);
</span><span class='line'>                * (.text);
</span><span class='line'>                ...
</span><span class='line'>        }
</span><span class='line'>        ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>异常向量需要放置在所有代码之前，这确保了代了向量是从0x0地址开始。</p>

<p>2. C启动代码</p>

<p>直接执行C代码会造成CPU直接重启，因为和汇编代码不同的是C语言需要初始化运行环境。</p>

<figure class='code'><figcaption><span>sum.c -sum.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>C语言运行环境需要设置
1. 栈
2. 全局变量： 已初始化的 &amp;&amp; 未初始化的
3. 只读数据</p>

<p>2.1 栈设置</p>

<p>栈被用来存储自动变量，传递函数变量，存储返回地址等等。ARM Architecture
Procedure Call Standard
(AAPCS)是ARM体系结构中用于生成栈的规则。r13被用于作栈指针。</p>

<p>对于特定的开发板来说，栈开始地址可能不同，对于connex开发板来说，地址可以用下面的代码来定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ldr sp, =0xA4000000</span></code></pre></td></tr></table></div></figure>


<p>2.2 全局变量</p>

<p>C代码在编译时会把已初始化的全局变量放在.data段中，因而在初始化的汇编代码中，需要把.data段从Flash搬移到RAM中。</p>

<p>C代码确保未初始化的全局变量被初始化成0.
当C程序被编译时，独立的.bss段被用作未初始化的变量。因为未初始化的值都是0,我们无需将其存储在FLASH中。只不过在搬移的时候，我们需要在程序中将它们初始化为0而已。</p>

<p>2.3 只读数据</p>

<p>const常量会被初始化为.rodata， .rodata也被用于存储字符常量。</p>

<p>.rodata在运行时不会被改变，所以它们可以被直接放置在FLASH中。</p>

<p>2.4 启动代码</p>

<p>Linker脚本需要做下面的事：
1. .bss部分代替
2.  vectors部分代替
3. .rodata部分代替</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (vectors);
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        .rodata : {
</span><span class='line'>              * (.rodata);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {
</span><span class='line'>              * (.data);
</span><span class='line'>        }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>
</span><span class='line'>        sbss = .;
</span><span class='line'>        .bss : {
</span><span class='line'>             * (.bss);
</span><span class='line'>        }
</span><span class='line'>        ebss = .;
</span><span class='line'>        bss_size = ebss - sbss;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>启动代码需要完成下列任务：
1. 中断向量设置
2. 将.data部分从FLASH拷贝到RAM
3. 将.bss置0后拷贝到RAM
4. 设置栈指针(stack pointer)
5. 分支程序到main函数</p>

<figure class='code'><figcaption><span>startup.s - startup.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Copy data to RAM.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle data_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_bss
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb   r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs   r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne    copy
</span><span class='line'>
</span><span class='line'>init_bss<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize <span class="m">.</span>bss
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>sbss
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ebss
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>bss_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle bss_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_stack
</span><span class='line'>
</span><span class='line'>        mov   r4<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>zero<span class="o">:</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   zero
</span><span class='line'>
</span><span class='line'>init_stack<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize the stack pointer
</span><span class='line'>        ldr   sp<span class="p">,</span> <span class="o">=</span><span class="mh">0xA4000000</span>
</span><span class='line'>
</span><span class='line'>        bl    main
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b     <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将直接用arm-none-eabi-gcc来编译所有程序：
    arm-none-eabi-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s
-nostdlib选项用于指定标准C不应该被链接。</p>

<p>查看符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>arm-none-eabi-nm -n csum.elf 
</span><span class='line'>00000000 t reset
</span><span class='line'>00000004 A bss_size
</span><span class='line'>00000004 t undef
</span><span class='line'>00000008 t swi
</span><span class='line'>0000000c t pabt
</span><span class='line'>00000010 t dabt
</span><span class='line'>00000018 A data_size
</span><span class='line'>00000018 t irq
</span><span class='line'>0000001c t fiq
</span><span class='line'>00000020 T main
</span><span class='line'>00000094 t start
</span><span class='line'>000000a8 t copy
</span><span class='line'>000000b8 t init_bss
</span><span class='line'>000000d0 t zero
</span><span class='line'>000000dc t init_stack
</span><span class='line'>000000e4 t stop
</span><span class='line'>00000100 r n
</span><span class='line'>00000104 R flash_sdata
</span><span class='line'>a0000000 d arr
</span><span class='line'>a0000000 D ram_sdata
</span><span class='line'>a0000018 D ram_edata
</span><span class='line'>a0000018 D sbss
</span><span class='line'>a0000018 b sum
</span><span class='line'>a000001c B ebss</span></code></pre></td></tr></table></div></figure>


<p>可以看到： 中断向量从0x0开始; 汇编代码从8个全字后开始(0x20==32==8<em>4);
只读数据n放在代码之后; arr，初始化后的数据，放在RAM中;
未初始化的数据,sum放在6个int之后6</em>4==24==0x18</p>

<p>转化成.bin二进制格式后，在Qemu中运行之，检查结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary csum.elf csum.bin  
</span><span class='line'>$ dd if=/dev/zero of=./flash.bin bs=4K count=4K
</span><span class='line'>      $ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc
</span><span class='line'>      $ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>(qemu) xp /6dw 0xa0000000
</span><span class='line'>a0000000:          1         10          4          5
</span><span class='line'>a0000010:          6          7
</span><span class='line'>(qemu) xp /1dw 0xa0000018
</span><span class='line'>a0000018:         33</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，1, 10, 4, 5, 6, 7 分别为数组元素，而结果为33,
储存在0x18的地址。如果感兴趣，我们大可查找出别的数据地址，这里就不一一述说了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/">用Qemu和GNU编译链研究ARM汇编(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T20:50:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:50 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在多个文件构成的程序中，源文件首先被编译成多个对象(object)文件(.o文件),
然后交由链接器生成最终的可执行文件，如下图所示：</p>

<p><img class="img" src="/images/linker.png"></p>

<p>在组建可执行文件时，链接器主要完成下列操作:</p>

<ul>
<li>解析符号</li>
<li>重定位</li>
</ul>


<p>1. 符号解析</p>

<p>在编译单个文件组成的程序时，所有标号的解析都可以由汇编器替代为对应的地址。而在多文件组成的程序中，如果有储存在其他文件中的符号引用，汇编器会将其标识为"unresolved"(未解析).当对象文件被传递给链接器时，链接器从这些文件中决定对应的值，并把code中的unresolved的值替代为正确的值。</p>

<p>我们用上一节的求和函数来演示链接器是如何进行符号解析的。
这两个文件汇编后，会在链接时被检查未被解析的引用。</p>

<figure class='code'><figcaption><span>main.s - main.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>main.s
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>
</span><span class='line'>        bl    sum               <span class="o">@</span> Invoke the sum subroutine
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>sum-sub.s - sum-sub.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="kp">sum</span><span class="o">-</span>sub.s
</span><span class='line'>        <span class="o">@</span> Args
</span><span class='line'>        <span class="o">@</span> r0<span class="o">:</span> Start address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span> r1<span class="o">:</span> End address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span>
</span><span class='line'>        <span class="o">@</span> Result
</span><span class='line'>        <span class="o">@</span> r3<span class="o">:</span> Sum of Array
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>global <span class="kp">sum</span>
</span><span class='line'>
</span><span class='line'><span class="kp">sum</span><span class="o">:</span>    mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *r0++    ; Get array element</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2      <span class="p">;</span> Calculate <span class="kp">sum</span>
</span><span class='line'>        cmp   r0<span class="p">,</span> r1            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r0 <span class="o">!=</span> r1<span class="p">)</span> <span class="p">;</span> Check <span class="kr">if</span> hit end<span class="o">-</span>of<span class="o">-</span><span class="kt">array</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop  <span class="p">;</span> Loop
</span><span class='line'>        mov   pc<span class="p">,</span> lr            <span class="o">@</span> pc <span class="o">=</span> lr       <span class="p">;</span> Return when done
</span></code></pre></td></tr></table></div></figure>


<p>查看.o文件符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm main.o
</span><span class='line'>00000004 t arr
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000008 t start
</span><span class='line'>00000014 t stop
</span><span class='line'>         U sum
</span><span class='line'>$ arm-none-eabi-nm sum-sub.o 
</span><span class='line'>00000004 t loop
</span><span class='line'>00000000 T sum</span></code></pre></td></tr></table></div></figure>


<p>t代表符号已经被定义了， 而u则代表符号未被定义。大写字母表示该符号是全局变量。</p>

<p>从上面的输出结果看，sum是被定义在sum-sub.o的全局变量，而该变量在main.o中未被解析到。当linker被调用时，符号引用将被解析到，对应的可执行文件将被生成。</p>

<p>总结： as程序负责把.s文件编译成object文件，而生成最终的可执行文件时，ld负责把未被定位的符号定位到实际的库函数所在的位置。</p>

<p>2. 重定位.</p>

<p>重定位用于改变已经分配给标号的地址。它包括将所有符号引用映射到新分配的内存地址。</p>

<p>合并段后的符号列表情况，可以对比于上面的main.o和sum-sub.o来看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000000
</span><span class='line'>$ arm-none-eabi-nm sum.elf
</span><span class='line'>00000004 t arr
</span><span class='line'>00008038 T __bss_end__
</span><span class='line'>00008038 T _bss_end__
</span><span class='line'>00008038 T __bss_start
</span><span class='line'>00008038 T __bss_start__
</span><span class='line'>00008038 T __data_start
</span><span class='line'>00008038 T _edata
</span><span class='line'>00008038 T _end
</span><span class='line'>00008038 T __end__
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000024 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000008 t start
</span><span class='line'>         U _start
</span><span class='line'>00000014 t stop
</span><span class='line'>00000020 T sum</span></code></pre></td></tr></table></div></figure>


<p>可以看到stop后面的sum已经被定位好了(之前是main.o中的U标记)，而loop则相应延后，被定位到了再往后的00000024。</p>

<p>地址的变更： loop原本地址为00000004, 现在是00000024, 而sum原本为0x00000000，现在为00000020, 这是因为sum-sub.o中的.text和main.o中的.text部分一起组成了sum.elf中的.text部分。</p>

<p>整体移动某个段到指定内存位置, 注意在-Ttext中我们增加的0x100的偏移量，使得地址对比于上面的结果整体上移了0x100:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x100 -o sum100.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000100
</span><span class='line'>$ arm-none-eabi-nm sum100.elf 
</span><span class='line'>00000104 t arr
</span><span class='line'>00008138 T __bss_end__
</span><span class='line'>00008138 T _bss_end__
</span><span class='line'>00008138 T __bss_start
</span><span class='line'>00008138 T __bss_start__
</span><span class='line'>00008138 T __data_start
</span><span class='line'>00008138 T _edata
</span><span class='line'>00008138 T _end
</span><span class='line'>00008138 T __end__
</span><span class='line'>00000107 t eoa
</span><span class='line'>00000124 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000108 t start
</span><span class='line'>         U _start
</span><span class='line'>00000114 t stop
</span><span class='line'>00000120 T sum</span></code></pre></td></tr></table></div></figure>


<p>3. 重定位.data到RAM中。</p>

<p>我们可以通过撰写链接脚本，将程序的.data段放置在RAM中。这也是通常嵌入式系统所谓bootloader干的活儿，从Flash中加载启动代码到RAM中而后执行。</p>

<p>例程从RAM中加载两个数值，将两者相加而后将结果写回RAM，两个值和结果都放置在.data部分。</p>

<p>代码：</p>

<figure class='code'><figcaption><span>sum_ram.s - sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.4</span>byte <span class="m">0</span>                <span class="o">@</span> <span class="m">4</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>链接脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从connex的内存布局来看，内存地址为0xa000_0000到0xa400_0000，因而A0000000刚好在内存中。</p>

<p>查看链接后的内存符号地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o sum.o sum.s
</span><span class='line'>$ arm-none-eabi-ld -T sum_link.ld -o sum.elf sum.o 
</span><span class='line'>$ arm-none-eabi-nm -n sum.elf 
</span><span class='line'>00000000 t start
</span><span class='line'>0000001c t stop
</span><span class='line'>a0000000 d val1
</span><span class='line'>a0000004 d val2
</span><span class='line'>a0000008 d result</span></code></pre></td></tr></table></div></figure>


<p>这样就完了？NO！！！！！！！！因为：RAM is Volatile! 内存是易变的！</p>

<p>RAM是易失性介质，怎可保证每次加电时就有代码洗干净PP在等着被运行？嵌入式系统里必然有非易失性存储，所有的代码和数据在加电前都需要放在这些非易失性存储介质中，例如在FLASH中。这样在加电后我们就可以利用一段启动代码把代码从FLASH搬到RAM中。</p>

<p>从这个设计思路出发，我们需要程序的.data有两个地址，一个是加载地址，另一个是运行地址。
这就是常说的：LMA(Load Memory Address)  VS    VMA(Virtual Memory Address)。</p>

<p>上面的代码需要做两个修改:</p>

<ol>
<li>需要在.data中指定load地址和运行地址</li>
<li>需要写一段代码用于将数据从FLASH读取到RAM中, 从存储地址到运行地址。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>        etext = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : AT (etext) { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>etext包含了FLASH中放置完地址后的空白地址，记住这个地址以便在接下来将这个数值传送给.data部分，以便程序将.data部分从FLASH拷贝到RAM中。etext只是符号表中的一个，本身并不占据任何内存(可以回去翻上一篇日志)。</p>

<p>关于AT关键字:  它指定了.data部分的加载地址，一个地址或符号被传递给AT关键字，以便它从该地址拷贝数据。 在这里，我们传递etext符号给AT。</p>

<p>要把代码从FLASH拷贝到RAM中，下列信息需要被提供：</p>

<ol>
<li>Flash中数据地址(flash_sdata)</li>
<li>RAM中数据地址(ram_sdata)</li>
<li>.data部分大小(data_size)</li>
</ol>


<p>拷贝代码：</p>

<figure class='code'><figcaption><span>modified_sum_ram.s - modified_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span></code></pre></td></tr></table></div></figure>


<p>由此，我们需要在链接脚本中生成这三个数值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {* (.data); }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ram_sdata为ram中数据开始地址，而ram_edata为结束地址，两者相减则为数据块大小。</p>

<p>改变后的带有copy数据的代码：</p>

<figure class='code'><figcaption><span>final_sum_ram.s - final_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.</span>space <span class="m">4</span>                <span class="o">@</span> <span class="m">1</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Copy data to RAM.
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Add and store result.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用修改过的final_sum_ram.s和link脚本编译，并生成flash.bin后，就可以在qemu-system-arm中验证结果了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information
</span><span class='line'>(qemu) info registers
</span><span class='line'>R00=a0000008 R01=a0000004 R02=0000000a R03=0000001e
</span><span class='line'>R04=00000028 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000038
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000
</span><span class='line'>
</span><span class='line'>(qemu) xp /4dw 0xA0000000
</span><span class='line'>00000000a0000000:         10         30         40          0</span></code></pre></td></tr></table></div></figure>


<p>R04包含了我们相加后的结果, 为0x28=40, R02/R03则分别为操作数10/30. 而通过显示0xA0000000也显示了内存中的值分别为val1/val2/result的值。</p>

<p>接下来的章节中，我们将讲到C代码入口。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/49">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/47">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/06/29/insert-public-key-into-cobbler-deployed-system/">Insert Public Key Into Cobbler Deployed System</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/29/linux-tips-2/">Linux Tips(2)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/25/for-deploying-148-tips/">For Deploying 148 Tips</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/24/wh-worktips-6/">WH Worktips(6)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/24/install-newest-version-of-cobbler/">Install Newest Version of Cobbler</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Dash -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dashsagittariussglory';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
