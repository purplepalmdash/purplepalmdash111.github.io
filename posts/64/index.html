
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dash</title>
  <meta name="author" content="Dash">

  
  <meta name="description" content="1. 有关异常向量 前面的例子中存在一个大BUG，内存布局中的前8个全字是为异常向量而保留的。当异常发生时控制逻辑将转到这些位置以执行对应的异常处理代码。异常向量和它们的地址如下： Exception Address
Reset 0x00
Undefined Instruction 0x04 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://purplepalmdash.github.io/posts/64">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/purplepalmdash/atom.xml" rel="alternate" title="Dash" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//fonts.googleapis.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Dash</a></h1>
  
    <h2>Get busy living, or get busy dying.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/purplepalmdash/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:purplepalmdash.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/">用Qemu和GNU编译链研究ARM汇编(4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-11T21:46:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:46 pm</span></time>
        
         | <a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 有关异常向量</p>

<p>前面的例子中存在一个大BUG，内存布局中的前8个全字是为异常向量而保留的。当异常发生时控制逻辑将转到这些位置以执行对应的异常处理代码。异常向量和它们的地址如下：</p>

<ul>
<li>Exception  Address</li>
<li>Reset  0x00</li>
<li>Undefined Instruction  0x04</li>
<li>Software Interrupt (SWI)   0x08</li>
<li>Prefetch Abort     0x0C</li>
<li>Data Abort     0x10</li>
<li>Reserved, not used     0x14</li>
<li>IRQ    0x18</li>
<li>FIQ    0x1C</li>
</ul>


<p>按理说，这些个异常向量应该对应到异常处理程序中，既然我们代码中不会有异常发生，索性就用死循环来代替，如下：</p>

<figure class='code'><figcaption><span>vector.s -vector.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span></code></pre></td></tr></table></div></figure>


<p>对应的，为了确保这些指令被放置在异常向量地址中，链接脚本也需要做相应的改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>                * (vectors);
</span><span class='line'>                * (.text);
</span><span class='line'>                ...
</span><span class='line'>        }
</span><span class='line'>        ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>异常向量需要放置在所有代码之前，这确保了代了向量是从0x0地址开始。</p>

<p>2. C启动代码</p>

<p>直接执行C代码会造成CPU直接重启，因为和汇编代码不同的是C语言需要初始化运行环境。</p>

<figure class='code'><figcaption><span>sum.c -sum.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>C语言运行环境需要设置
1. 栈
2. 全局变量： 已初始化的 &amp;&amp; 未初始化的
3. 只读数据</p>

<p>2.1 栈设置</p>

<p>栈被用来存储自动变量，传递函数变量，存储返回地址等等。ARM Architecture
Procedure Call Standard
(AAPCS)是ARM体系结构中用于生成栈的规则。r13被用于作栈指针。</p>

<p>对于特定的开发板来说，栈开始地址可能不同，对于connex开发板来说，地址可以用下面的代码来定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ldr sp, =0xA4000000</span></code></pre></td></tr></table></div></figure>


<p>2.2 全局变量</p>

<p>C代码在编译时会把已初始化的全局变量放在.data段中，因而在初始化的汇编代码中，需要把.data段从Flash搬移到RAM中。</p>

<p>C代码确保未初始化的全局变量被初始化成0.
当C程序被编译时，独立的.bss段被用作未初始化的变量。因为未初始化的值都是0,我们无需将其存储在FLASH中。只不过在搬移的时候，我们需要在程序中将它们初始化为0而已。</p>

<p>2.3 只读数据</p>

<p>const常量会被初始化为.rodata， .rodata也被用于存储字符常量。</p>

<p>.rodata在运行时不会被改变，所以它们可以被直接放置在FLASH中。</p>

<p>2.4 启动代码</p>

<p>Linker脚本需要做下面的事：
1. .bss部分代替
2.  vectors部分代替
3. .rodata部分代替</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (vectors);
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        .rodata : {
</span><span class='line'>              * (.rodata);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {
</span><span class='line'>              * (.data);
</span><span class='line'>        }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>
</span><span class='line'>        sbss = .;
</span><span class='line'>        .bss : {
</span><span class='line'>             * (.bss);
</span><span class='line'>        }
</span><span class='line'>        ebss = .;
</span><span class='line'>        bss_size = ebss - sbss;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>启动代码需要完成下列任务：
1. 中断向量设置
2. 将.data部分从FLASH拷贝到RAM
3. 将.bss置0后拷贝到RAM
4. 设置栈指针(stack pointer)
5. 分支程序到main函数</p>

<figure class='code'><figcaption><span>startup.s - startup.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Copy data to RAM.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle data_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_bss
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb   r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs   r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne    copy
</span><span class='line'>
</span><span class='line'>init_bss<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize <span class="m">.</span>bss
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>sbss
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ebss
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>bss_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle bss_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_stack
</span><span class='line'>
</span><span class='line'>        mov   r4<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>zero<span class="o">:</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   zero
</span><span class='line'>
</span><span class='line'>init_stack<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize the stack pointer
</span><span class='line'>        ldr   sp<span class="p">,</span> <span class="o">=</span><span class="mh">0xA4000000</span>
</span><span class='line'>
</span><span class='line'>        bl    main
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b     <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将直接用arm-none-eabi-gcc来编译所有程序：
    arm-none-eabi-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s
-nostdlib选项用于指定标准C不应该被链接。</p>

<p>查看符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>arm-none-eabi-nm -n csum.elf 
</span><span class='line'>00000000 t reset
</span><span class='line'>00000004 A bss_size
</span><span class='line'>00000004 t undef
</span><span class='line'>00000008 t swi
</span><span class='line'>0000000c t pabt
</span><span class='line'>00000010 t dabt
</span><span class='line'>00000018 A data_size
</span><span class='line'>00000018 t irq
</span><span class='line'>0000001c t fiq
</span><span class='line'>00000020 T main
</span><span class='line'>00000094 t start
</span><span class='line'>000000a8 t copy
</span><span class='line'>000000b8 t init_bss
</span><span class='line'>000000d0 t zero
</span><span class='line'>000000dc t init_stack
</span><span class='line'>000000e4 t stop
</span><span class='line'>00000100 r n
</span><span class='line'>00000104 R flash_sdata
</span><span class='line'>a0000000 d arr
</span><span class='line'>a0000000 D ram_sdata
</span><span class='line'>a0000018 D ram_edata
</span><span class='line'>a0000018 D sbss
</span><span class='line'>a0000018 b sum
</span><span class='line'>a000001c B ebss</span></code></pre></td></tr></table></div></figure>


<p>可以看到： 中断向量从0x0开始; 汇编代码从8个全字后开始(0x20==32==8<em>4);
只读数据n放在代码之后; arr，初始化后的数据，放在RAM中;
未初始化的数据,sum放在6个int之后6</em>4==24==0x18</p>

<p>转化成.bin二进制格式后，在Qemu中运行之，检查结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary csum.elf csum.bin  
</span><span class='line'>$ dd if=/dev/zero of=./flash.bin bs=4K count=4K
</span><span class='line'>      $ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc
</span><span class='line'>      $ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>(qemu) xp /6dw 0xa0000000
</span><span class='line'>a0000000:          1         10          4          5
</span><span class='line'>a0000010:          6          7
</span><span class='line'>(qemu) xp /1dw 0xa0000018
</span><span class='line'>a0000018:         33</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，1, 10, 4, 5, 6, 7 分别为数组元素，而结果为33,
储存在0x18的地址。如果感兴趣，我们大可查找出别的数据地址，这里就不一一述说了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/">用Qemu和GNU编译链研究ARM汇编(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T20:50:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:50 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在多个文件构成的程序中，源文件首先被编译成多个对象(object)文件(.o文件),
然后交由链接器生成最终的可执行文件，如下图所示：</p>

<p><img class="img" src="/images/linker.png"></p>

<p>在组建可执行文件时，链接器主要完成下列操作:</p>

<ul>
<li>解析符号</li>
<li>重定位</li>
</ul>


<p>1. 符号解析</p>

<p>在编译单个文件组成的程序时，所有标号的解析都可以由汇编器替代为对应的地址。而在多文件组成的程序中，如果有储存在其他文件中的符号引用，汇编器会将其标识为"unresolved"(未解析).当对象文件被传递给链接器时，链接器从这些文件中决定对应的值，并把code中的unresolved的值替代为正确的值。</p>

<p>我们用上一节的求和函数来演示链接器是如何进行符号解析的。
这两个文件汇编后，会在链接时被检查未被解析的引用。</p>

<figure class='code'><figcaption><span>main.s - main.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>main.s
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>
</span><span class='line'>        bl    sum               <span class="o">@</span> Invoke the sum subroutine
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>sum-sub.s - sum-sub.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="kp">sum</span><span class="o">-</span>sub.s
</span><span class='line'>        <span class="o">@</span> Args
</span><span class='line'>        <span class="o">@</span> r0<span class="o">:</span> Start address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span> r1<span class="o">:</span> End address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span>
</span><span class='line'>        <span class="o">@</span> Result
</span><span class='line'>        <span class="o">@</span> r3<span class="o">:</span> Sum of Array
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>global <span class="kp">sum</span>
</span><span class='line'>
</span><span class='line'><span class="kp">sum</span><span class="o">:</span>    mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *r0++    ; Get array element</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2      <span class="p">;</span> Calculate <span class="kp">sum</span>
</span><span class='line'>        cmp   r0<span class="p">,</span> r1            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r0 <span class="o">!=</span> r1<span class="p">)</span> <span class="p">;</span> Check <span class="kr">if</span> hit end<span class="o">-</span>of<span class="o">-</span><span class="kt">array</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop  <span class="p">;</span> Loop
</span><span class='line'>        mov   pc<span class="p">,</span> lr            <span class="o">@</span> pc <span class="o">=</span> lr       <span class="p">;</span> Return when done
</span></code></pre></td></tr></table></div></figure>


<p>查看.o文件符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm main.o
</span><span class='line'>00000004 t arr
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000008 t start
</span><span class='line'>00000014 t stop
</span><span class='line'>         U sum
</span><span class='line'>$ arm-none-eabi-nm sum-sub.o 
</span><span class='line'>00000004 t loop
</span><span class='line'>00000000 T sum</span></code></pre></td></tr></table></div></figure>


<p>t代表符号已经被定义了， 而u则代表符号未被定义。大写字母表示该符号是全局变量。</p>

<p>从上面的输出结果看，sum是被定义在sum-sub.o的全局变量，而该变量在main.o中未被解析到。当linker被调用时，符号引用将被解析到，对应的可执行文件将被生成。</p>

<p>总结： as程序负责把.s文件编译成object文件，而生成最终的可执行文件时，ld负责把未被定位的符号定位到实际的库函数所在的位置。</p>

<p>2. 重定位.</p>

<p>重定位用于改变已经分配给标号的地址。它包括将所有符号引用映射到新分配的内存地址。</p>

<p>合并段后的符号列表情况，可以对比于上面的main.o和sum-sub.o来看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000000
</span><span class='line'>$ arm-none-eabi-nm sum.elf
</span><span class='line'>00000004 t arr
</span><span class='line'>00008038 T __bss_end__
</span><span class='line'>00008038 T _bss_end__
</span><span class='line'>00008038 T __bss_start
</span><span class='line'>00008038 T __bss_start__
</span><span class='line'>00008038 T __data_start
</span><span class='line'>00008038 T _edata
</span><span class='line'>00008038 T _end
</span><span class='line'>00008038 T __end__
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000024 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000008 t start
</span><span class='line'>         U _start
</span><span class='line'>00000014 t stop
</span><span class='line'>00000020 T sum</span></code></pre></td></tr></table></div></figure>


<p>可以看到stop后面的sum已经被定位好了(之前是main.o中的U标记)，而loop则相应延后，被定位到了再往后的00000024。</p>

<p>地址的变更： loop原本地址为00000004, 现在是00000024, 而sum原本为0x00000000，现在为00000020, 这是因为sum-sub.o中的.text和main.o中的.text部分一起组成了sum.elf中的.text部分。</p>

<p>整体移动某个段到指定内存位置, 注意在-Ttext中我们增加的0x100的偏移量，使得地址对比于上面的结果整体上移了0x100:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x100 -o sum100.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000100
</span><span class='line'>$ arm-none-eabi-nm sum100.elf 
</span><span class='line'>00000104 t arr
</span><span class='line'>00008138 T __bss_end__
</span><span class='line'>00008138 T _bss_end__
</span><span class='line'>00008138 T __bss_start
</span><span class='line'>00008138 T __bss_start__
</span><span class='line'>00008138 T __data_start
</span><span class='line'>00008138 T _edata
</span><span class='line'>00008138 T _end
</span><span class='line'>00008138 T __end__
</span><span class='line'>00000107 t eoa
</span><span class='line'>00000124 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000108 t start
</span><span class='line'>         U _start
</span><span class='line'>00000114 t stop
</span><span class='line'>00000120 T sum</span></code></pre></td></tr></table></div></figure>


<p>3. 重定位.data到RAM中。</p>

<p>我们可以通过撰写链接脚本，将程序的.data段放置在RAM中。这也是通常嵌入式系统所谓bootloader干的活儿，从Flash中加载启动代码到RAM中而后执行。</p>

<p>例程从RAM中加载两个数值，将两者相加而后将结果写回RAM，两个值和结果都放置在.data部分。</p>

<p>代码：</p>

<figure class='code'><figcaption><span>sum_ram.s - sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.4</span>byte <span class="m">0</span>                <span class="o">@</span> <span class="m">4</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>链接脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从connex的内存布局来看，内存地址为0xa000_0000到0xa400_0000，因而A0000000刚好在内存中。</p>

<p>查看链接后的内存符号地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o sum.o sum.s
</span><span class='line'>$ arm-none-eabi-ld -T sum_link.ld -o sum.elf sum.o 
</span><span class='line'>$ arm-none-eabi-nm -n sum.elf 
</span><span class='line'>00000000 t start
</span><span class='line'>0000001c t stop
</span><span class='line'>a0000000 d val1
</span><span class='line'>a0000004 d val2
</span><span class='line'>a0000008 d result</span></code></pre></td></tr></table></div></figure>


<p>这样就完了？NO！！！！！！！！因为：RAM is Volatile! 内存是易变的！</p>

<p>RAM是易失性介质，怎可保证每次加电时就有代码洗干净PP在等着被运行？嵌入式系统里必然有非易失性存储，所有的代码和数据在加电前都需要放在这些非易失性存储介质中，例如在FLASH中。这样在加电后我们就可以利用一段启动代码把代码从FLASH搬到RAM中。</p>

<p>从这个设计思路出发，我们需要程序的.data有两个地址，一个是加载地址，另一个是运行地址。
这就是常说的：LMA(Load Memory Address)  VS    VMA(Virtual Memory Address)。</p>

<p>上面的代码需要做两个修改:</p>

<ol>
<li>需要在.data中指定load地址和运行地址</li>
<li>需要写一段代码用于将数据从FLASH读取到RAM中, 从存储地址到运行地址。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>        etext = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : AT (etext) { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>etext包含了FLASH中放置完地址后的空白地址，记住这个地址以便在接下来将这个数值传送给.data部分，以便程序将.data部分从FLASH拷贝到RAM中。etext只是符号表中的一个，本身并不占据任何内存(可以回去翻上一篇日志)。</p>

<p>关于AT关键字:  它指定了.data部分的加载地址，一个地址或符号被传递给AT关键字，以便它从该地址拷贝数据。 在这里，我们传递etext符号给AT。</p>

<p>要把代码从FLASH拷贝到RAM中，下列信息需要被提供：</p>

<ol>
<li>Flash中数据地址(flash_sdata)</li>
<li>RAM中数据地址(ram_sdata)</li>
<li>.data部分大小(data_size)</li>
</ol>


<p>拷贝代码：</p>

<figure class='code'><figcaption><span>modified_sum_ram.s - modified_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span></code></pre></td></tr></table></div></figure>


<p>由此，我们需要在链接脚本中生成这三个数值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {* (.data); }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ram_sdata为ram中数据开始地址，而ram_edata为结束地址，两者相减则为数据块大小。</p>

<p>改变后的带有copy数据的代码：</p>

<figure class='code'><figcaption><span>final_sum_ram.s - final_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.</span>space <span class="m">4</span>                <span class="o">@</span> <span class="m">1</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Copy data to RAM.
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Add and store result.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用修改过的final_sum_ram.s和link脚本编译，并生成flash.bin后，就可以在qemu-system-arm中验证结果了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information
</span><span class='line'>(qemu) info registers
</span><span class='line'>R00=a0000008 R01=a0000004 R02=0000000a R03=0000001e
</span><span class='line'>R04=00000028 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000038
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000
</span><span class='line'>
</span><span class='line'>(qemu) xp /4dw 0xA0000000
</span><span class='line'>00000000a0000000:         10         30         40          0</span></code></pre></td></tr></table></div></figure>


<p>R04包含了我们相加后的结果, 为0x28=40, R02/R03则分别为操作数10/30. 而通过显示0xA0000000也显示了内存中的值分别为val1/val2/result的值。</p>

<p>接下来的章节中，我们将讲到C代码入口。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-2/">用Qemu和GNU编译链研究ARM汇编(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T16:30:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:30 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>研究两个汇编程序, 通过研究这两个程序，初步了解ARM汇编的知识：</p>

<ul>
<li>用于求数组和的程序</li>
<li>用于计算字符串长度的程序</li>
</ul>


<p>1. 数组求和</p>

<figure class='code'><figcaption><span>sum.s - sum.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>entry<span class="o">:</span>  b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1      @ r2 = *r1++</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2
</span><span class='line'>        cmp   r1<span class="p">,</span> r0            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r1 <span class="o">!=</span> r2<span class="p">)</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>.byte声明：</p>

<p>.byte声明的变量在内存中以连续的比特存在，.2byte和.4byte与之类似，分别用于存储16位值和32位值。联想到C语言中的内建数据结构定义，不难想象char/int/long int 预编译完是哪一种类型。</p>

<p>通用语法结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.byte   exp1, exp2, ...
</span><span class='line'>.2byte  exp1, exp2, ...
</span><span class='line'>.4byte  exp1, exp2, ...</span></code></pre></td></tr></table></div></figure>


<p>你可以指定数据的格式，二进制用前缀0b/0B修饰，八进制以前缀0修饰，十进制/十六进制以0x/0X开头。整数也可以用字符常量来表示，加上单引号即可，在这种情况下ASCII码会被用到。</p>

<p>也可以用C表达式，包含文字和其他符号的组合，如下例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pattern:  .byte 0b01010101, 0b00110011, 0b00001111
</span><span class='line'>npattern: .byte npattern - pattern
</span><span class='line'>halpha:   .byte 'A', 'B', 'C', 'D', 'E', 'F'
</span><span class='line'>dummy:    .4byte 0xDEADBEEF
</span><span class='line'>nalpha:   .byte 'Z' - 'A' + 1</span></code></pre></td></tr></table></div></figure>


<p>.align声明：</p>

<p>ARM指令需要32位对齐，指令的起始内存地址需要是4的倍数，所以用.align指令来插入无用的byte，来确保下一条指令的起始地址是4的倍数。在代码中存在byte或是半字(half words)的时候，需要用到这条指令。</p>

<p>编译&amp;运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># assemble
</span><span class='line'>$ arm-none-eabi-as -o sum.o sum.s 
</span><span class='line'># link to elf file
</span><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf sum.o
</span><span class='line'># form bin file
</span><span class='line'>$ arm-none-eabi-objcopy -O binary sum.elf sum.bin
</span><span class='line'># form flash image
</span><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>$ dd if=sum.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'># emulate with flash image
</span><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'># examine the result
</span><span class='line'>R00=00000007 R01=00000007 R02=00000019 R03=00000037
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000024
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R03的值正是我们求和的结果:  0x37==55==10+20+25, 可以用一张流程图来表示程序的运行过程</p>

<p>2. 字符串长度</p>

<figure class='code'><figcaption><span>string.s - string.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start
</span><span class='line'>
</span><span class='line'>str<span class="o">:</span>    <span class="m">.</span>asciz <span class="s">&quot;Hello World&quot;</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>equ   nul<span class="p">,</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>  ldr   r0<span class="p">,</span> <span class="o">=</span>str          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>str
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *(r0++)</span>
</span><span class='line'>        add   r1<span class="p">,</span> r1<span class="p">,</span> <span class="c1">#1        @ r1 += 1</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#nul          @ if (r1 != nul)</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop
</span><span class='line'>
</span><span class='line'>        sub   r1<span class="p">,</span> r1<span class="p">,</span> <span class="c1">#1        @ r1 -= 1</span>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000010 R01=0000000b R02=00000000 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000002c
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>r1是用来存储字符串长度的，计算结果为11。</p>

<p>.asciz声明:
 .asciz声明接受一个字符串作为参数，字符串以双引号修饰的字符表示。汇编器自动在字符串后面加nul字符（即\0字符）</p>

<p>.equ声明
汇编器维持一张符号表，符号表维持键->值的格式。当汇编器遇到一个标号时，汇编器将在符号表中自动建立一个条目。以后当汇编器遇到一个关于label的引用时，将自动替换为符号表中储存的label的地址。</p>

<p>使用汇编器指令.equ，我们可以手动在符号表中插入条目。</p>

<p>.equ通常这样定义:
    .equ name, expression</p>

<p>.equ不会分配任何内存，它们只是在符号表中插入条目罢了。</p>

<p>bne的意思是(!=) , b means bit. bit not equal. ble (&lt;=), beq (==), bge (>=), bgt (>), and bne (!=).</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/">用Qemu和GNU编译链研究ARM汇编(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-09T20:42:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:42 pm</span></time>
        
         | <a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 汇编程序代码格式</p>

<p>汇编代码由一系列的声明所组成，每行一个。每条声明由下列格式组成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>label(标签):   instruction @comment(注释)</span></code></pre></td></tr></table></div></figure>


<p>说明：</p>

<ul>
<li>label:
标签的引入使得在内存中查询指令地址变得很方便，标签可以在任意一个内存地址使用，
例如分支指令中就可以用到标签, 标签可以包括字母、数字_和$符号。</li>
<li>注释：
注释内容必须在@符号之后</li>
<li>指令:
指令可以是ARM指令集或是汇编器指令，汇编器指令是需要传递给汇编器的命令，总是以.开头。</li>
</ul>


<p>2. 一个简单的汇编语言文件:</p>

<figure class='code'><figcaption><span>add.s -add.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>                       <span class="o">@</span> Label<span class="p">,</span> not really required
</span><span class='line'>        mov   r0<span class="p">,</span> <span class="c1">#5         @ Load register r0 with the value 5</span>
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#4         @ Load register r1 with the value 4</span>
</span><span class='line'>        add   r2<span class="p">,</span> r1<span class="p">,</span> r0     <span class="o">@</span> Add r0 and r1 and store <span class="kr">in</span> r2
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b stop               <span class="o">@</span> Infinite loop to stop execution
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的意思是，把立即数5载入到寄存器r0, 4载入到r1,
以r1和r0相加的结果填充r2.</p>

<p>.text是汇编器指令，用于告知汇编器需要把代码组装到code段,而不是.data段。有关section的概念在后面将被讲到。</p>

<p>3. 编译二进制文件</p>

<p>GNU的汇编器名字叫as， 用下列命令将源文件编译成.o文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o add.o add.s</span></code></pre></td></tr></table></div></figure>


<p>链接器的名字叫ld，用下列命令可以将二进制文件链接成elf文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o</span></code></pre></td></tr></table></div></figure>


<p>-Ttext指明需要分配给label的地址,
这条指令告诉链接器从地址0x0开始装载指令。我们可以用nm来查看具体的地址分配信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm add.elf 
</span><span class='line'>00008010 T __bss_end__
</span><span class='line'>00008010 T _bss_end__
</span><span class='line'>00008010 T __bss_start
</span><span class='line'>00008010 T __bss_start__
</span><span class='line'>00008010 T __data_start
</span><span class='line'>00008010 T _edata
</span><span class='line'>00008010 T _end
</span><span class='line'>00008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000000 t start
</span><span class='line'>         U _start
</span><span class='line'>0000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>start和stop之间由0c个字节，因为stop是在start开始后三条指令，
每条指令的长度为4个Byte，3*4=12=0xc</p>

<p>更改链接的参数将得到不同的地址分配。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 20000000
</span><span class='line'>$ arm-none-eabi-nm add.elf
</span><span class='line'>20008010 T __bss_end__
</span><span class='line'>20008010 T _bss_end__
</span><span class='line'>20008010 T __bss_start
</span><span class='line'>20008010 T __bss_start__
</span><span class='line'>20008010 T __data_start
</span><span class='line'>20008010 T _edata
</span><span class='line'>20008010 T _end
</span><span class='line'>20008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>20000000 t start
</span><span class='line'>         U _start
</span><span class='line'>2000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>ld得到的文件一般是ELF文件，在有操作系统的时候ELF可以工作的很好，但是我们将在裸机模式下(Bare
Metal)运行此程序， 因此需要将文件类型转化为更简单的binary类型。</p>

<p>GNU编译链的objcopy可以完成不同可执行文件之间的转换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary add.elf add.bin
</span><span class='line'>$ file add.bin
</span><span class='line'>add.bin: Hitachi SH big-endian COFF</span></code></pre></td></tr></table></div></figure>


<p>4. 在Qemu中执行二进制文件。</p>

<p>我们将使用connex开发板来模拟运行此程序，它把16MB的Flash放在地址0x0，而通常arm处理器重启时都会执行0x0处的代码。
因而我们需要把add.bin写入到16MB Flash文件的头部。</p>

<p>首先创建一个空的16MB Flash文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>4096+0 records in
</span><span class='line'>4096+0 records out
</span><span class='line'>16777216 bytes (17 MB) copied, 0.0153106 s, 1.1 GB/s</span></code></pre></td></tr></table></div></figure>


<p>而后，使用下列命令将add.bin放到Flash头部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'>0+1 records in
</span><span class='line'>0+1 records out
</span><span class='line'>16 bytes (16 B) copied, 0.00011154 s, 143 kB/s</span></code></pre></td></tr></table></div></figure>


<p>add.bin大小刚好为16B, notrunc参数代表no truncated，意思是直接覆盖掉原有内容。</p>

<p>用下列命令执行此改动后的flash文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information</span></code></pre></td></tr></table></div></figure>


<p>-M connex 指定connex机器， -pflash指定flash.bin代替flash闪存。</p>

<p>-pflash file    use &lsquo;file&rsquo; as a parallel flash image 并行flash镜像</p>

<p>-serial /dev/null 将connex的串口输出重定向到/dev/null</p>

<p>查看寄存器信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000005 R01=00000004 R02=00000009 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000000c
</span><span class='line'>PSR=400001d3 -Z-- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R02的值正是计算后的结果4+5=9.
R15=0000000c 猜测应该为指令寄存器，指向stop(0xc)</p>

<p>5. 更多的查看命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>help  List available commands
</span><span class='line'>quit   Quits the emulator
</span><span class='line'>xp /fmt addr   Physical memory dump from addr
</span><span class='line'>system_reset   Reset the system.</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) help xp
</span><span class='line'>xp /fmt addr -- physical memory dump starting at 'addr'
</span><span class='line'>(qemu) xp /4iw 0x0
</span><span class='line'>0x00000000:  e3a00005      mov    r0, #5  ; 0x5
</span><span class='line'>0x00000004:  e3a01004      mov    r1, #4  ; 0x4
</span><span class='line'>0x00000008:  e0812000      add    r2, r1, r0
</span><span class='line'>0x0000000c:  eafffffe      b  0xc</span></code></pre></td></tr></table></div></figure>


<p>4: 4 个条目被显示, i表示打印出指令，即内建的反汇编，
w表明条目的大小为32个bit，即一个全字。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/">在Qemu上运行Raspberry PI镜像</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T18:09:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:09 pm</span></time>
        
         | <a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载和准备镜像文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://downloads.raspberrypi.org/images/raspbian/2013-05-25-wheezy-raspbian/2013-05-25-wheezy-raspbian.zip
</span><span class='line'>$ unzip 2013-05-25-wheezy-raspbian.zip</span></code></pre></td></tr></table></div></figure>


<p>2. 查看镜像文件分区信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fdisk -l 2013-05-25-wheezy-raspbian.img 
</span><span class='line'>Disk 2013-05-25-wheezy-raspbian.img: 1939 MB, 1939865600 bytes, 3788800 sectors
</span><span class='line'>Units = sectors of 1 * 512 = 512 bytes
</span><span class='line'>Sector size (logical/physical): 512 bytes / 512 bytes
</span><span class='line'>I/O size (minimum/optimal): 512 bytes / 512 bytes
</span><span class='line'>Disk label type: dos
</span><span class='line'>Disk identifier: 0x000c7b31
</span><span class='line'>
</span><span class='line'>                         Device Boot      Start         End      Blocks   Id
</span><span class='line'>System
</span><span class='line'>2013-05-25-wheezy-raspbian.img1            8192      122879       57344    c  W95 FAT32 (LBA)
</span><span class='line'>2013-05-25-wheezy-raspbian.img2          122880     3788799     1832960   83  Linux</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看到，根文件分区的地址偏移为512*122880=62914560</p>

<p>3. 更改根分区文件里preload信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo mount ./2013-05-25-wheezy-raspbian.img -o offset=62914560 /mnt3
</span><span class='line'>$ sudo vim /mnt3/etc/ld.so.preload 
</span><span class='line'>#注释掉这一行，否则在qemu启动完系统后将自动提示配置rpi而造成系统无法登陆
</span><span class='line'>#/usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class='line'>$ sudo umount /mnt3</span></code></pre></td></tr></table></div></figure>


<p>4. 用qemu-system-arm启动raspberrypi镜像</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -kernel kernel-qemu -cpu arm1176 -m 256 -M versatilepb \
</span><span class='line'>-no-reboot -serial stdio -append "root=/dev/sda2 panic=1" -hda \
</span><span class='line'>./2013-05-25-wheezy-raspbian.img </span></code></pre></td></tr></table></div></figure>


<p>系统将启动到一个root登陆的无需密码的shell中，运行下列命令以修复文件系统:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fsck /dev/sda2
</span><span class='line'>$ shutdown -r now</span></code></pre></td></tr></table></div></figure>


<p>再次启动完毕后的登陆用户名和密码如下，接下来就等同于原机操作了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Login as pi
</span><span class='line'>Password raspberry</span></code></pre></td></tr></table></div></figure>


<p>5. ArchLinux on RaspberryPI</p>

<p>基本步骤也是一样，挂在第2块分区后，需要更改etc/fstab做下列修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;          &lt;dump&gt; &lt;pass&gt;
</span><span class='line'>/dev/sda1   /boot           vfat    defaults        0       0
</span><span class='line'>/dev/sda2   /     auto    defaults        0       0</span></code></pre></td></tr></table></div></figure>


<p>之后挂载命令一样。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/">用Qemu模拟ARM(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T16:35:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:35 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载并交叉编译u-boot。</p>

<p>新版本的u-boot我加载后总有问题，2009.11版则可以顺利通过编译和测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget ftp://ftp.denx.de/pub/u-boot/u-boot-2009.11.tar.bz2
</span><span class='line'>$ tar xjvf u-boot-2009.11.tar.bz2 
</span><span class='line'>$ cd u-boot-2009.11
</span><span class='line'>$ make versatilepb_config arch=ARM CROSS_COMPILE=arm-none-eabi-
</span><span class='line'>$ make all arch=ARM CROSS_COMPILE=arm-none-eabi- </span></code></pre></td></tr></table></div></figure>


<p>编译完成后会在目录下生成u-boot.bin和u-boot文件。</p>

<p>2. 运行u-boot.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel u-boot.bin -nographic</span></code></pre></td></tr></table></div></figure>


<p>如果采用-nographic来运行qemu-system-arm，终端将无法再响应任何系统输入譬如Ctrl+c/ctrl+d_，要终止qemu-system-arm就只能查到进程号再kill。所以我一般不带-nographic选项，启动后ctrl+alt+2去看serial0输出,保留在终端窗口直接ctrl+c杀死qemu-sytem-arm进程的权力。</p>

<p>3. 用u-boot引导镜像文件:</p>

<p>改动上一篇文章里用于构建启动镜像的linker.ld文件，因为u-boot.bin文件大小的缘故，我们需要把启动镜像的起始地址整体上移.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h u-boot.bin 
</span><span class='line'>-rwxr-xr-x 1 Trusty root 85K Jul  8 15:57 u-boot.bin</span></code></pre></td></tr></table></div></figure>


<p>linker.ld文件里， 0x100000，这个大小相比于85K显然已经足够。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>SECTIONS
</span><span class='line'>{
</span><span class='line'>. = 0x100000;
</span><span class='line'>startup : { startup.o(.text)}
</span><span class='line'>.data : {*(.data)}
</span><span class='line'>.bss : {*(.bss)}
</span><span class='line'>. = . + 0x500;
</span><span class='line'>sp_top = .;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>按上一章的编译方法生成output.bin，不再重述。</p>

<p>使用mkimage工具创建u-boot可识别的image文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkimage -A arm -C none -O linux -T kernel -d output.bin -a 0x00100000 -e 0x00100000 output.uimg
</span><span class='line'>Image Name:   
</span><span class='line'>Created:      Mon Jul  8 16:04:11 2013
</span><span class='line'>Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>Data Size:    152 Bytes = 0.15 kB = 0.00 MB
</span><span class='line'>Load Address: 00100000
</span><span class='line'>Entry Point:  00100000
</span><span class='line'>
</span><span class='line'>$ file *.uimg
</span><span class='line'>output.uimg: u-boot legacy uImage, , Linux/ARM, OS Kernel Image (Not \
</span><span class='line'>compressed), 152 bytes, Mon Jul  8 16:04:11 2013, Load Address: 0x00100000,\
</span><span class='line'>Entry Point: 0x00100000, Header CRC: 0x3C62F575, Data CRC: 0x69CE9647</span></code></pre></td></tr></table></div></figure>


<p>将u-boot.bin和output.uimg打包为一个文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat u-boot.bin output.uimg &gt;flash.bin</span></code></pre></td></tr></table></div></figure>


<p>下面这条命令用于计算output.img在使用u-boot加载完flash.bin后在内存中的地址，-kernel选项告诉qemu从0x100000开始加载镜像，即65536。
65536+u-boot.bin后的大小，即output.img在内存中的地址。printf则是用16进制的格式打印出来，以便加载.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ printf "0x%X" $(expr $(stat -c%s u-boot.bin) + 65536)
</span><span class='line'>0x2525C</span></code></pre></td></tr></table></div></figure>


<p>启动qemu-system-arm并运行自定义镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel flash.bin
</span><span class='line'># iminfo 0x2525c
</span><span class='line'>
</span><span class='line'>## Checking Image at 0002525c ...
</span><span class='line'>   Legacy image found
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Verifying Checksum ... OK
</span><span class='line'>
</span><span class='line'>VersatilePB # bootm 0x2525c
</span><span class='line'>## Booting kernel from Legacy Image at 0002525c ...
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Loading Kernel Image ... OK
</span><span class='line'>OK
</span><span class='line'>
</span><span class='line'>Starting kernel ...
</span><span class='line'>
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>u-boot可以支持的选项还有很多，包括使用NFS/TFTP启动等等，留待以后慢慢研究。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-2/">用Qemu模拟ARM(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T15:18:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>3:18 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 关于Bootloader:</p>

<p>(引导程序)位于电脑或其他计算机应用上，是指引导操作系统启动的程序。引导程序启动方式和程序视应用机型种类而不同。例如在普通的个人电脑上，引导程序通常分为两部分：第一阶段引导程序位于主引导记录（MBR），用以引导位于某个分区上的第二阶段引导程序，如NTLDR、GNU
GRUB等。</p>

<p> 嵌入式系统中常见的Bootloader主要有以下几种:</p>

<ul>
<li>Das U-Boot
是一个主要用于嵌入式系统的开机载入程序，可以支持多种不同的计算机系统结构，包括PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。</li>
<li>vivi是由mizi公司设计为ARM处理器系列设计的一个bootloader.</li>
<li>Redboot (Red Hat Embedded Debug and Bootstrap)是Red
Hat公司开发的一个独立运行在嵌入式系统上的BootLoader程序，是目前比较流行的一个功能、可移植性好的BootLoader。</li>
</ul>


<p>2. 关于“裸机编程(Bare-Metal)”:</p>

<p>微控制器开发人员很熟悉这个概念，
Bare-Metal是指的你的程序和处理器之间没有任何东西&mdash;-你写的程序将直接运行在处理器上,
换言之，开发人员是在直接操控硬件。在裸机编程的场景中，需要由开发人员检查并排除任何一个可以导致系统崩溃的风险。</p>

<p>&ldquo;Bare-Metal"要求开发人员了解关于硬件的细节，所以接下来我们将对编译链和qemu本身进行分析。</p>

<p>3. 下载qemu源码包并查询相关硬件信息：</p>

<p>ArchLinux采用ABS(Arch Build
System)来管理源码包，下面的步骤将qemu源码包下载到本地，更详细的关于ABS的操作可以在ArchLinux的Wiki中找到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S abs
</span><span class='line'>$ pacman -Ss qemu
</span><span class='line'>extra/qemu 1.4.2-2 [installed]
</span><span class='line'>$ abs extra/qemu 
</span><span class='line'>$ cp -r /var/abs/extra/qemu/ ~/abs 
</span><span class='line'>$ cd ~/abs && makepkg -s --asroot -o</span></code></pre></td></tr></table></div></figure>


<p>得到versatilepb开发板的CPU型号, 可以看到"arm926"是我们要的结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grep "arm" src/qemu-1.4.2/hw/versatilepb.c 
</span><span class='line'>#include "arm-misc.h"
</span><span class='line'>static struct arm_boot_info versatile_binfo;
</span><span class='line'>        args-&gt;cpu_model = "arm926";
</span><span class='line'>    cpu = cpu_arm_init(args-&gt;cpu_model);
</span><span class='line'>    cpu_pic = arm_pic_init_cpu(cpu);
</span><span class='line'>    arm_load_kernel(cpu, &versatile_binfo);</span></code></pre></td></tr></table></div></figure>


<p>得到versatilepb开发板的串口寄存器硬件信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grep "UART*" src/qemu-1.4.2/hw/versatilepb.c 
</span><span class='line'>    /*  0x10009000 UART3.  */
</span><span class='line'>    /*  0x101f1000 UART0.  */
</span><span class='line'>    /*  0x101f2000 UART1.  */
</span><span class='line'>    /*  0x101f3000 UART2.  */</span></code></pre></td></tr></table></div></figure>


<p>所以说开源是王道嘛，很快就查到了每一个需要了解的细节。UART0在内存中map到的地址是0x101f1000,
我们直接往这个地址写数据，就可以在终端上看到数据输出了。</p>

<p>4. 查看编译链支持的平台：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat ~/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/share/doc/arm-arm-none-eabi/info/gcc.info | grep arm926
</span><span class='line'>     `arm926ej-s', `arm940t', `arm9tdmi', `arm10tdmi', `arm1020t',</span></code></pre></td></tr></table></div></figure>


<p>arm926ej-s是被支持的，因此我们可以用这套编译链来生成需要的裸机调试代码。</p>

<p>5. 启动应用程序init.c的编写:</p>

<p>首先创建应用程序init.c：</p>

<figure class='code'><figcaption><span>init.c - init.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">UART0_PTR</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0101f1000</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">string</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span><span class='line'>        <span class="o">*</span><span class="n">UART0_PTR</span> <span class="o">=</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">my_init</span><span class="p">(){</span>
</span><span class='line'>    <span class="n">display</span><span class="p">(</span><span class="s">&quot;Hello Open World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>init.c中，我们首先声明一个volatile变UART0_PTR,volatile关键字用于告知编译器此变量是用于直接访问内存映像设备的，即串口0内存地址</p>

<p>display()函数则是用于将字符串中的字符按顺序输出到串口0, 直到遇到字符串结尾。</p>

<p>my_init()调用了display(), 接下来我们将把它作为C入口函数.</p>

<p>预编译init.c:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-gcc -c -mcpu=arm926ej-s init.c -o init.o</span></code></pre></td></tr></table></div></figure>


<p>6. 启动代码start.s编写：</p>

<figure class='code'><figcaption><span>start.s - start.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="m">.</span>global _Start
</span><span class='line'>_Start<span class="o">:</span>
</span><span class='line'>LDR sp<span class="p">,</span> <span class="o">=</span> sp_top
</span><span class='line'>BL my_init
</span><span class='line'>B <span class="m">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理器加电后，将跳转到指定的内存地址,从此地址开始读入并执行代码。</p>

<p>_Start被声明为全局函数，_Start的实现中，首先将栈地址指向sp_top, LDR(load),
sp是栈地址寄存器(stack pointer),</p>

<p>BL则是跳转指令，跳转到my_init函数，事实上你可以跳转到任何一个你想跳转的函数，临时写一个their_init()跳转过去也行。Debug时常更改这里以调试不同的子系统功能。</p>

<p>&ldquo;B."可以理解为汇编里的while(1)或for(;;)循环，处理器空转，什么也不做。如果不调用它，系统就会崩溃。所谓嵌入式编程的一个基本理念就是，代码无限循环。</p>

<p>预编译汇编文件start.s:
    $ arm-none-eabi-as -mcpu=arm926ej-s startup.s -o startup.o</p>

<p>7. 接下来我们需要用一个可以被编译器识别的链接脚本链接两文件, linker.ld:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>  SECTIONS
</span><span class='line'>  {
</span><span class='line'>  . = 0x10000;
</span><span class='line'>  startup : { startup.o(.text)}
</span><span class='line'>  .data : {*(.data)}
</span><span class='line'>  .bss : {*(.bss)}
</span><span class='line'>  . = . + 0x500;
</span><span class='line'>  sp_top = .;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>ENTRY(_Start)用于告知链接器程序的入口点(entry point)是_Start(start.s中定义).
Qemu模拟器如果加上-kernel选项时，将自动从0x10000开始执行，所以我们必须将代码放到这个地址。所以第四行我们指定".
= 0x10000". SECTIONS就是用于定义程序的不同部分的。</p>

<p>startup.o组成了代码的text部分，然后是data部分和bss部分，最后一步则定义了栈指针(sp,
stack pointer)地址. 栈通常是向下增长的，所以最好给它一个比较安全的地址， . =
.+0x500就是用于避免栈被改写的。sp_top用于存储栈顶地址。</p>

<p>有关程序结构：</p>

<ul>
<li>BSS段:  在采用段式内存管理的架构中，BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。.bss section的空间结构类似于stack, 主要用于存储静态变量、未显式初始化、在变量使用前由运行时初始化为零。</li>
<li>数据段(data segment): 通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>代码段(code segment/text segment): 通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许程序自修改。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>


<p>编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -T linker.ld init.o startup.o -o output.elf
</span><span class='line'>$ file output.elf 
</span><span class='line'>output.elf: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),statically linked, not stripped
</span><span class='line'>$  arm-none-eabi-objcopy -O binary output.elf output.bin
</span><span class='line'>$ file output.bin 
</span><span class='line'>output.bin: data</span></code></pre></td></tr></table></div></figure>


<p>8. 使用qemu-system-arm运行output.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm --help | grep nographic 
</span><span class='line'>-nographic      disable graphical output and redirect serial I/Os to console.
</span><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>9. Play more tricks:
改动init.c里的串口输出地址为串口1：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>volatile unsigned char * const UART0_PTR = (unsigned char *)0x0101f2000;
</span><span class='line'>  // 0x101f1000  --&gt; 0x101f2000</span></code></pre></td></tr></table></div></figure>


<p>按照步骤3～7里重新编译，并运行以查看结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 没有反应！
</span><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
</span><span class='line'># 终端有输出字符。
</span><span class='line'>$ qemu-system-arm -M versatilepb -kernel output.bin -serial vc:800x600 -serial stdio
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>同样你也可以把字符输出到第三个串口，只不过前两个-serial的重定向需要指定到别的设备而已。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-1/">用Qemu模拟ARM(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T10:45:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>10:45 am</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前面已经安装并配置了编译链和qemu，现在可以用qemu来模拟arm平台了。</p>

<p>1. Hello, Qemu!</p>

<p>输入下面的代码:</p>

<figure class='code'><figcaption><span>hello.c - hello.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, Qemu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-linux-gnueabi-gcc -o hello hello.c -static
</span><span class='line'>$ qemu-arm ./hello
</span><span class='line'>$ file hello
</span><span class='line'>hello: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), \
</span><span class='line'> statically linked, for GNU/Linux 2.6.16, not stripped</span></code></pre></td></tr></table></div></figure>


<p>不加-static变量的话，运行时则需要使用-L选项链接到相应的运行库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-arm -L /home/Trusty/CodeSourcery/\
</span><span class='line'>Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/\
</span><span class='line'>arm-none-linux-gnueabi/libc/  ./hello_1 
</span><span class='line'>Hello, Qemu!
</span><span class='line'>$ file hello_1
</span><span class='line'>hello_1: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),\
</span><span class='line'> dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped</span></code></pre></td></tr></table></div></figure>


<p>动态编译和静态编译生成的文件大小差别：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h
</span><span class='line'>total 656K
</span><span class='line'>-rwxr-xr-x 1 Trusty root 640K Jul  7 18:46 hello
</span><span class='line'>-rwxr-xr-x 1 Trusty root 6.6K Jul  7 18:48 hello_1</span></code></pre></td></tr></table></div></figure>


<h3>小插曲1：</h3>

<p>系统里安装了两套编译链arm-none-eabi-和arm-none-linux-eabi-,很容易让人混淆，可参考编译链的命名规则：</p>

<p>arch(架构)-vendor(厂商名)-(os(操作系统名)-)abi(Application Binary
Interface，应用程序二进制接口)</p>

<p>举例说明：</p>

<ul>
<li>x86_64-w64-mingw32 = x86_64 &ldquo;arch"字段 (=AMD64), w64 (=mingw-w64
是"vendor"字段), mingw32 (=GCC所见的win32 API)</li>
<li>i686-unknown-linux-gnu = 32位 GNU/linux编译链</li>
<li>arm-none-linux-gnueabi = ARM 架构, 无vendor字段, linux 系统, gnueabi ABI.</li>
<li>arm-none-eabi = ARM架构, 无厂商, eabi ABI(embedded abi)</li>
</ul>


<p>两种编译链的主要区别在于库的差别，前者没有后者的库多，后者主要用于在有操作系统的时候编译APP用的。前者不包括标准输入输出库在内的很多C标准库，适合于做面向硬件的类似单片机那样的开发。因而如果采用arm-none-eabi-gcc来编译hello.c会出现链接错误。</p>

<h3>小插曲2：</h3>

<p>qemu-arm和qemu-system-arm的区别：</p>

<ul>
<li>qemu-arm是用户模式的模拟器(更精确的表述应该是系统调用模拟器)，而qemu-system-arm则是系统模拟器，它可以模拟出整个机器并运行操作系统</li>
<li>qemu-arm仅可用来运行二进制文件，因此你可以交叉编译完例如hello
world之类的程序然后交给qemu-arm来运行，简单而高效。而qemu-system-arm则需要你把hello
world程序下载到客户机操作系统能访问到的硬盘里才能运行。</li>
</ul>


<p>2. 使用qemu-system-arm运行Linux内核</p>

<p>从www.kernel.org下载最新内核,而后解压</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tar xJf linux-3.10.tar.xz
</span><span class='line'>$ cd linux-3.10
</span><span class='line'>$ make ARCH=arm versatile_defconfig
</span><span class='line'>$ make menuconfig ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-</span></code></pre></td></tr></table></div></figure>


<p>上面的命令指定内核架构为arm，交叉编译链为arm-none-linux-gnueabi,
需要在make menuconfig弹出的窗口中选择到 “Kernel Features”, 激活“Use the ARM
EABI to compile the kernel”,
如果不激活这个选项的话，内核将无法加载接下来要制作的initramfs。</p>

<p>如果需要在u-boot上加载内核，就要编译为uImage的格式，uImage通过mkimage程序来压缩的，ArchLinux的yaourt仓库里可以找到这个包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yaourt -S mkimage</span></code></pre></td></tr></table></div></figure>


<p>安装好mkimage后，开始编译内核，因为CPU有4核，所以开启了-j8选项以加速编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- all -j8 uImage </span></code></pre></td></tr></table></div></figure>


<p>接下来我们可以在qemu-system-arm中测试我们的内核了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -m 128M -kernel ./arch/arm/boot/uImage</span></code></pre></td></tr></table></div></figure>


<p>在弹出的窗口中可以内核运行到了kernel
panic状态，这是因为内核无法加载root镜像的缘故，我们将制作一个最简单的hello
world的文件系统，告知kernel运行之。</p>

<figure class='code'><figcaption><span>init.c - init.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并制作启动镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-linux-gnueabi-gcc -o init init.c -static
</span><span class='line'>$ echo init |cpio -o --format=newc &gt; initramfs
</span><span class='line'>1280 blocks
</span><span class='line'>$ file initramfs 
</span><span class='line'>initramfs: ASCII cpio archive (SVR4 with no CRC)</span></code></pre></td></tr></table></div></figure>


<p>接下来我们回到编译目录下执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel ./arch/arm/boot/uImage  -initrd
</span><span class='line'>../initramfs -serial stdio -append "console=tty1"</span></code></pre></td></tr></table></div></figure>


<p>这时候可以看到，kernel运行并在Qemu自带的终端里打印出"Hello World!&ldquo;。</p>

<p>如果我们改变console变量为ttyAMA0, 将在启动qemu-system-arm的本终端上打印出qemu的输出。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/07/qemukuai-su-shang-shou/">Qemu快速上手</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-07T15:19:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>3:19 pm</span></time>
        
         | <a href="/blog/2013/07/07/qemukuai-su-shang-shou/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 安装Qemu</p>

<p>ArchLinux的仓库里包含有qemu已编译好的包:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Ss qemu
</span><span class='line'>extra/qemu 1.4.2-2 [installed]
</span><span class='line'>    A generic and open source processor emulator which achieves a good \
</span><span class='line'>emulation speed by using dynamic translation.
</span><span class='line'>$ pacman -S qemu</span></code></pre></td></tr></table></div></figure>


<p>会根据默认配置安装好几乎所有平台支持的Qemu.</p>

<p>或者你可以手动下载源码包进行编译:官方下载地址在<a href="http://wiki.qemu.org/Download">http://wiki.qemu.org/Download</a></p>

<p>安装完qemu后运行qemu-system-i386, 如果弹出窗口，则说明qemu安装正确。</p>

<p>2. 创建新虚拟机磁盘镜像</p>

<p>创建虚拟机的第一步是创建一个新的磁盘镜像，qemu提供了对多种磁盘镜像格式的支持，如raw、qcow2、qed、vdi等，qemu-img的帮助里介绍qcow2是最多才多艺(Versatile)的格式，支持压缩、加密等功能，还能最大程度节省磁盘空间。我们选择它来做磁盘镜像(Virtualbox可以直接读取qcow2格式的虚拟机镜像)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-img create -f qcow2 ubuntu.qcow2 16G
</span><span class='line'>Formatting 'ubuntu.qcow2', fmt=qcow2 size=17179869184 encryption=off \
</span><span class='line'>cluster_size=65536 lazy_refcounts=off </span></code></pre></td></tr></table></div></figure>


<p>3. 启动并安装虚拟机:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda ubuntu.qcow2 -boot d -cdrom \
</span><span class='line'>./ubuntu-13.04-desktop-i386.iso -m 1024 -enable-kvm</span></code></pre></td></tr></table></div></figure>


<p>-boot d代表优先从光驱启动，对应的选项有a, b (软驱 1 和 2), c (硬盘优先), d (光盘优先), n-p(支持Etherboot的网卡1-4).</p>

<p>安装ubuntu的步骤很直观，这里就不用篇幅描述了。安装完毕后，使用下列命令启动安装好的虚拟机镜像</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda ubuntu.qcow2 -m 1024 -enable-kvm</span></code></pre></td></tr></table></div></figure>


<p>4. 配置虚拟机网络：</p>

<p>4.1 使用桥接网络</p>

<p>这种方法需要改动系统配置，使用bridge-utils来创建虚拟网卡和实际网卡之间的桥接。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Ss bridge-utils
</span><span class='line'>core/bridge-utils 1.5-2
</span><span class='line'>    Utilities for configuring the Linux ethernet bridge
</span><span class='line'>$ pacman -S bridge-utils</span></code></pre></td></tr></table></div></figure>


<p>创建桥接设备(br0)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ modprobe bridge
</span><span class='line'>$ brctl addbr br0</span></code></pre></td></tr></table></div></figure>


<p>出现add bridge failed: Package not installed时的解决方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brctl addbr br0
</span><span class='line'>add bridge failed: Package not installed
</span><span class='line'># 查看kernel中关于bridge配置选项
</span><span class='line'>$ zcat /proc/config.gz | grep CONFIG_BRIDGE=
</span><span class='line'>CONFIG_BRIDGE=m
</span><span class='line'># 查看是否存在ko文件
</span><span class='line'>$ ls /usr/lib/modules/`uname -r`/kernel/net/bridge
</span><span class='line'>bridge.ko.gz  netfilter
</span><span class='line'># 加载bridge内核模块
</span><span class='line'>$ modprobe bridge
</span><span class='line'># 检查内核模块是否被加载
</span><span class='line'>$ lsmod | grep ^bridge
</span><span class='line'>bridge                 93187  0 </span></code></pre></td></tr></table></div></figure>


<p>若modprobe bridge后lsmod看不到bridge模块，有可能是因为更新完系统安装到新的kernel version后没有重启，ArchLinux是一个非常激进的发行版，内核往往几天一升级，习惯休眠或长期不关机的用户可能会碰到这个问题。</p>

<p>检查bridge网络</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brctl show br0
</span><span class='line'>bridge name   bridge id       STP enabled interfaces
</span><span class='line'>br0       8000.000000000000   no</span></code></pre></td></tr></table></div></figure>


<p>关于STP:
Spanning Tree Protocol (STP) is a Layer 2 protocol that runs on bridges and
switches. The specification for STP is IEEE 802.1D. The main purpose of STP is
to ensure that you do not create loops when you have redundant paths in your
network. Loops are deadly to a network.
生成树协议运行于bridge或交换机上，主要目的为确保在存在冗余路径时网络中不会生成回路，回路会造成网络的死循环。</p>

<p>用下列命令查看网口信息, 或者ifconfig -a直接查看也可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ifconfig -s | awk '{print $1}' | grep -v "Iface\|lo"
</span><span class='line'>enp0s25</span></code></pre></td></tr></table></div></figure>


<p>将enp0s25加入到br0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /sbin/ifconfig enp0s25 down
</span><span class='line'>$ /sbin/ifconfig enp0s25 0.0.0.0 promisc up
</span><span class='line'>$ brctl addif br0 enp0s25
</span><span class='line'>$ dhcpcd br0</span></code></pre></td></tr></table></div></figure>


<p>查看bridge端口信息,发现enp0s25已经被加入了br0：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brctl show br0
</span><span class='line'>bridge name   bridge id       STP enabled interfaces
</span><span class='line'>br0       8000.c8cbb8b48913   no      enp0s25</span></code></pre></td></tr></table></div></figure>


<p>有关bridge网络的dhcp相关配置，可以参考<a href="http://Tomcat.no-ip.biz/blog/2013/07/07/archlinuxwang-luo-pei-zhi-wen-ti/">ArchLinux网络配置问题</a>。</p>

<p>创建qemu启动脚本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /etc/qemu-ifup
</span><span class='line'>#!/bin/sh
</span><span class='line'>  
</span><span class='line'>echo "Executing /etc/qemu-ifup"
</span><span class='line'>echo "Bringing up $1 for bridged mode..."
</span><span class='line'>sudo /usr/bin/ip link set $1 up promisc on
</span><span class='line'>echo "Adding $1 to br0..."
</span><span class='line'>sudo /usr/bin/brctl addif br0 $1
</span><span class='line'>sleep 2</span></code></pre></td></tr></table></div></figure>


<p>更改脚本权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ chmod 750 /etc/qemu-ifup 
</span><span class='line'>$ chown -R root /etc/qemu-ifup 
</span><span class='line'>$ chgrp kvm /etc/qemu-ifup </span></code></pre></td></tr></table></div></figure>


<p>创建qemu结束脚本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /etc/qemu-ifdown
</span><span class='line'>#!/bin/sh
</span><span class='line'> 
</span><span class='line'>echo "Executing /etc/qemu-ifdown"
</span><span class='line'>sudo /usr/bin/ip link set $1 down
</span><span class='line'>sudo /usr/bin/brctl delif br0 $1
</span><span class='line'>sudo /usr/bin/ip link delete dev $1</span></code></pre></td></tr></table></div></figure>


<p>更改脚本权限:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ chmod 750 /etc/qemu-ifdown 
</span><span class='line'>$ chown -R root /etc/qemu-ifdown 
</span><span class='line'>$ chgrp kvm /etc/qemu-ifdown </span></code></pre></td></tr></table></div></figure>


<p>添加当前用户到kvm用户组并在visudo中开放对应命令的权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ usermod -a -G kvm Trusty
</span><span class='line'>$ visudo
</span><span class='line'>Cmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
</span><span class='line'>%kvm     ALL=NOPASSWD: QEMU</span></code></pre></td></tr></table></div></figure>


<p>建立run-qemu文件，并添加到系统路径中.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim /bin/run-qemu
</span><span class='line'>#!/bin/bash
</span><span class='line'>USERID=`whoami`
</span><span class='line'>precreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
</span><span class='line'>sudo /usr/bin/ip tuntap add user $USERID mode tap
</span><span class='line'>postcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
</span><span class='line'>IFACE=$(comm -13 &lt;(echo "$precreationg") &lt;(echo "$postcreation"))
</span><span class='line'>
</span><span class='line'># This line creates a random mac address. The downside is the dhcp server will
</span><span class='line'>assign a different ip each time
</span><span class='line'>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM & 0xff)) $(( $RANDOM &
</span><span class='line'>0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff ))
</span><span class='line'># Instead, uncomment and edit this line to set an static mac address. The
</span><span class='line'>benefit is that the dhcp server will assign the same ip.
</span><span class='line'># macaddr='52:54:be:36:42:a9'
</span><span class='line'>  
</span><span class='line'>qemu-system-i386 -enable-kvm -net nic,macaddr=$macaddr -net tap,ifname="$IFACE"
</span><span class='line'>$*
</span><span class='line'>  
</span><span class='line'>sudo ip link set dev $IFACE down &&gt; /dev/null
</span><span class='line'>sudo ip tuntap del $IFACE mode tap &&gt; /dev/null 
</span><span class='line'>$ sudo chmod a+w /bin/run-qemu</span></code></pre></td></tr></table></div></figure>


<p>使用下列命令来运行qemu</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /bin/run-qemu -hda ./ubuntu.qcow2 -m 1024 -vga std</span></code></pre></td></tr></table></div></figure>


<p>运行多个run-qemu实例后的网络信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ifconfig -s
</span><span class='line'>Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
</span><span class='line'>br0       1500    70676      0      0 0         64334      0      0      0 BMRU
</span><span class='line'>enp0s25   1500   103814      0      0 0         75661      0      0      0 BMPRU
</span><span class='line'>lo       65536      983      0      0 0           983      0      0      0 LRU
</span><span class='line'>tap0      1500        3      0      0 0            11      0      0      0 BMPRU
</span><span class='line'>tap1      1500        3      0      0 0            11      0      0      0 BMPRU</span></code></pre></td></tr></table></div></figure>


<p>4.2 使用VDE(Virtual Distrubuted Ethernet)创建Qemu网络，这种方法无需改变系统配置。</p>

<p>有关VDE的配置可以参考前面写过的<a href="http://Tomcat.no-ip.biz/blog/2013/07/04/zai-centosshang-an-zhuang-ji-yu-qemude-xu-ni-ji/">在CentOS上安装基于Qemu的虚拟机</a>一文。</p>

<p>值得注意的是, vdeswitch和slirpvde都可以在ArchLinux的软件库中找到:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -Ss vde
</span><span class='line'>extra/vde2 2.3.2-4 [installed]
</span><span class='line'>    Virtual Distributed Ethernet for emulators like qemu</span></code></pre></td></tr></table></div></figure>


<p>使用VDE创建的网络对外是不可见的，它使用由slirpvde分配的dhcp地址，通常以10.0.0开头，VDE配置的网络也可以在VirtualBox中看到，VirtualBox中关于NAT的网络配置就是基于VDE的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/07/archlinuxwang-luo-pei-zhi-wen-ti/">ArchLinux DHCP配置问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-07T12:10:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:10 pm</span></time>
        
         | <a href="/blog/2013/07/07/archlinuxwang-luo-pei-zhi-wen-ti/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>安装完ArchLinux后，发现网卡无法从路由器通过dhcp得到地址，ArchLinux的dhcp客户端是dhcpcd,默认配置文件。路由器型号是TP-link WR340G v5, 2010年入手的。</p>

<p>手动调用dhcpcd时候发现LOG里有NAK消息爆出。</p>

<p>翻了下Arch的论坛，这个问题是由于dhcpcd的参数配置引发的，某些dhcpcd向路由器请求的参数无法得到而导致，个人觉得大约是WR340G版本够老，无法提供这些个参数。</p>

<h2>解决方案一：</h2>

<p>编辑/etc/dhcpcd.conf， 注释掉classless_static_routes 和 interface_mtu即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># option classless_static_routes
</span><span class='line'>
</span><span class='line'># Respect the network MTU.
</span><span class='line'># option interface_mtu</span></code></pre></td></tr></table></div></figure>


<p>而后我们可以用systemd在每次启动的时候自动调用dhcpcd绑定地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ systemctl enable dhcpcd@enp0s25
</span><span class='line'>$ systemctl start dhcpcd@enp0s25</span></code></pre></td></tr></table></div></figure>


<h2>解决方案二:</h2>

<p>安装dhclient:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S dhclient
</span><span class='line'>$ dhclient enp0s25</span></code></pre></td></tr></table></div></figure>


<p>这种方法需要每次手动输入，不过我们可以使用netctl包来自动管理网络接口信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cp /etc/netctl/examples/ethernet-dhcp /etc/netctl/ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>由netctl.profile查到指定dhcp客户端的字段，而后在/etc/netctl/ethernet-dhcp文件中添加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DHCPClient=dhclient
</span><span class='line'># !!! 别忘了修改dhcp侦听的设备地址：
</span><span class='line'># Interface=eth0
</span><span class='line'>Interface=enp0s25</span></code></pre></td></tr></table></div></figure>


<p>把ethernet-dhcp作为netctl的默认启动配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ netctl enable ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>立即开启netctl:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ netctl start ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>查看netctl服务运行情况，我的网络是桥接的，和依据上面步骤配出来的字段会有所不同</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ systemctl list-units -t service | grep netctl
</span><span class='line'>netctl@bridge.service        loaded active exited  Example Bridge connection</span></code></pre></td></tr></table></div></figure>


<p>如果切换了网络环境，例如如果在待机唤醒时处于另一网络中，则需要用下列命令重新配置网络:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ netctl restart ethernet-dhcp</span></code></pre></td></tr></table></div></figure>


<p>两种方法各有千秋，前者比较灵活，但是遇到复杂网络配置的时候可能会很棘手，譬如多网卡/桥接等模型时容易把人弄晕。后者配置选项很多，但一劳永逸。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/65">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/63">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/05/09/working-tips-on-mesos-slash-ansible/">Working Tips on Mesos/Ansible</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/06/working-tips-on-ansible-cobbler-2/">Working Tips on Ansible-cobbler(2)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/04/linux-tips-5/">Linux Tips(5)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/04/working-tips-on-ansible-cobbler/">Working Tips on Ansible-cobbler</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/24/tipsonosexperiment/">TipsOnOSExperiment</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Dash -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dashsagittariussglory';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
