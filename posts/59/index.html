
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dash</title>
  <meta name="author" content="Dash">

  
  <meta name="description" content="1. 稳压IC的作用： 稳压器IC就是使输出电压稳定的设备中的电子元器件。所有的稳压器，都利用了相同的技术实现输出电压的稳定输出电压通过连接到误差放大器（Error Amplifier）反相输入端（Inverting Input）的分压电阻（Resistive Divider）采样（Sampled &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://purplepalmdash.github.io/posts/59">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/purplepalmdash/atom.xml" rel="alternate" title="Dash" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//fonts.googleapis.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Dash</a></h1>
  
    <h2>Get busy living, or get busy dying.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/purplepalmdash/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:purplepalmdash.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/15/ardiunobi-ji-1/">Arduino笔记(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-15T09:39:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:39 am</span></time>
        
         | <a href="/blog/2013/07/15/ardiunobi-ji-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 稳压IC的作用：</p>

<p>稳压器IC就是使输出电压稳定的设备中的电子元器件。所有的稳压器，都利用了相同的技术实现输出电压的稳定输出电压通过连接到误差放大器（Error Amplifier）反相输入端（Inverting Input）的分压电阻（Resistive Divider）采样（Sampled），误差放大器的同相输入端（Non-inverting Input）连接到一个参考电压Vref。 参考电压由IC内部的带隙参考源(Bandgap Reference)产生。误差放大器总是试图迫使其两端输入相等。为此，它提供负载电流以保证输出电压稳定。</p>

<p>2. ICSP(In-circuit serial programming)</p>

<p>3. FT232: USB->UART</p>

<p> The FT232BM is the 2nd generation of FTDI&rsquo;s popular USB UART device and the FT232BL is a lead free version of it.  The FT232BQ provides the same functionality as the FT232BM and FT232BL in a QFN-32 lead free package.</p>

<p>4. ATmega328P Parameters:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Parameter        Value
</span><span class='line'>Flash (Kbytes):       32 Kbytes
</span><span class='line'>Pin Count:        32
</span><span class='line'>Max. Operating Frequency: 20 MHz
</span><span class='line'>CPU:          8-bit AVR
</span><span class='line'># of Touch Channels:  16
</span><span class='line'>Hardware QTouch Acquisition: No
</span><span class='line'>Max I/O Pins:     23
</span><span class='line'>Ext Interrupts:       24
</span><span class='line'>USB Speed:        No
</span><span class='line'>USB Interface:        No
</span><span class='line'>SPI:          2
</span><span class='line'>TWI (I2C):        1
</span><span class='line'>UART:         1
</span><span class='line'>Graphic LCD:      No
</span><span class='line'>Video Decoder:        No
</span><span class='line'>Camera Interface: No
</span><span class='line'>ADC channels:     8
</span><span class='line'>ADC Resolution (bits):    10
</span><span class='line'>ADC Speed (ksps): 15
</span><span class='line'>Analog Comparators:   1
</span><span class='line'>Resistive Touch Screen:   No
</span><span class='line'>DAC Resolution (bits):    0
</span><span class='line'>Temp. Sensor:     Yes
</span><span class='line'>Crypto Engine:        No
</span><span class='line'>SRAM (Kbytes):        2
</span><span class='line'>EEPROM (Bytes):       1024
</span><span class='line'>Self Program Memory:  YES
</span><span class='line'>External Bus Interface:   0
</span><span class='line'>DRAM Memory:      No
</span><span class='line'>NAND Interface:       No
</span><span class='line'>picoPower:        Yes
</span><span class='line'>Temp. Range (deg C):  -40 to 85
</span><span class='line'>I/O Supply Class: 1.8 to 5.5
</span><span class='line'>Operating Voltage (Vcc):1.8 to 5.5
</span><span class='line'>FPU:          No
</span><span class='line'>MPU / MMU:        no / no
</span><span class='line'>Timers:           3
</span><span class='line'>Output Compare channels:  6
</span><span class='line'>Input Capture Channels:       1
</span><span class='line'>PWM Channels:     6
</span><span class='line'>32kHz RTC:        Yes
</span><span class='line'>Calibrated RC Oscillator: Yes
</span><span class='line'>Watchdog:     Yes</span></code></pre></td></tr></table></div></figure>


<p>5. ATmega328P主要特性如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>高性能、低功耗的 8 位AVR 微处理器
</span><span class='line'>先进的RISC 结构
</span><span class='line'>131 条指令 – 大多数指令执行时间为单个时钟周期
</span><span class='line'>32 个8 位通用工作寄存器
</span><span class='line'>全静态工作
</span><span class='line'>工作于20 MHz 时性能高达20 MIPS
</span><span class='line'>只需两个时钟周期的硬件乘法器
</span><span class='line'>非易失性程序和数据存储器
</span><span class='line'>32K字节的系统内可编程Flash
</span><span class='line'>擦写寿命: 10,000 次
</span><span class='line'>具有独立锁定位的可选Boot 代码区
</span><span class='line'>通过片上Boot 程序实现系统内编程
</span><span class='line'>真正的同时读写操作
</span><span class='line'>1024字节的EEPROM
</span><span class='line'>擦写寿命: 100,000 次
</span><span class='line'>2K字节的片内SRAM
</span><span class='line'>可以对锁定位进行编程以实现用户程序的加密
</span><span class='line'>外设特点
</span><span class='line'>两个具有独立预分频器和比较器功能的8位定时器/计数器
</span><span class='line'>一个具有预分频器、比较功能和捕捉功能的16位定时器/计数器
</span><span class='line'>具有独立振荡器的实时计数器RTC
</span><span class='line'>六通道PWM
</span><span class='line'>8路10 位ADC
</span><span class='line'>可编程的串行USART
</span><span class='line'>可工作于主机/ 从机模式的SPI 串行接口
</span><span class='line'>基于字节的2-wire串行接口
</span><span class='line'>具有独立片内振荡器的可编程看门狗定时器
</span><span class='line'>片内模拟比较器
</span><span class='line'>引脚电平变化可引发中断及唤醒MCU
</span><span class='line'>特殊的微控制器特点
</span><span class='line'>上电复位(POR) 以及可编程的掉电检测(BOD)
</span><span class='line'>经过校准的片内RC 振荡器
</span><span class='line'>片内、片外中断源
</span><span class='line'>6种休眠模式：空闲模式、ADC 噪声抑制模式、省电模式、掉电模式、待机模式和延长待机模式
</span><span class='line'>I/O 和封装
</span><span class='line'>23个可编程的I/O 口
</span><span class='line'>28引脚PDIP，32引脚TQFP，28引脚QFN/MLF，与32引脚QFN/MLF封装
</span><span class='line'>工作电压
</span><span class='line'>1.8 - 5.5V
</span><span class='line'>工作温度范围:
</span><span class='line'>-40℃至85℃
</span><span class='line'>工作速度等级
</span><span class='line'>0 - 20 MHz @ 1.8 - 5.5V
</span><span class='line'>超低功耗
</span><span class='line'>正常模式：
</span><span class='line'>1 MHz, 1.8V, 25°C: 0.2 mA
</span><span class='line'>掉电模式:
</span><span class='line'>1.8V, 0.1 μA
</span><span class='line'>省电模式:
</span><span class='line'>1.8V, 0.75 μA</span></code></pre></td></tr></table></div></figure>


<p>6. LED闪烁测试程序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Let the LED shinning per 1 seconds 
</span><span class='line'> */
</span><span class='line'> 
</span><span class='line'> void setup()
</span><span class='line'> {
</span><span class='line'>   // Arduino's port 13 has a LED
</span><span class='line'>   pinMode(13, OUTPUT);
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> void loop()
</span><span class='line'> {
</span><span class='line'>   digitalWrite(13, HIGH);  // LED is on
</span><span class='line'>   delay(1000);             // Last for 1 second
</span><span class='line'>   digitalWrite(13, LOW);   // LED is off
</span><span class='line'>   delay(1000);             // Last for 1 second
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>在Arduino中程序运行时将首先调用 setup() 函数。用于初始化变量、设置针脚的输出\输入类型、配置串口、引入类库文件等等。每次 Arduino 上电或重启后，setup 函数只运行一次。</p>

<p>pinMode(): 将指定的引脚配置成输出或输入。详情请见digital pins。</p>

<p>在 setup() 函数中初始化和定义了变量，然后执行 loop() 函数。顾名思义,该函数在程序运行过程中不断的循环，根据一些反馈,相应改变执行情况。通过该函数动态控制 Arduino 主控板。</p>

<p>digitalWrite() 给一个数字引脚写入HIGH或者LOW。</p>

<p>如果一个引脚已经使用pinMode()配置为OUTPUT模式，其电压将被设置为相应的值，HIGH为5V（3.3V控制板上为3.3V），LOW为0V。</p>

<p>如果引脚配置为INPUT模式，使用digitalWrite()写入HIGH值，将使内部20K上拉电阻（详见数字引脚教程）。写入LOW将会禁用上拉。上拉电阻可以点亮一个LED让其微微亮，如果LED工作，但是亮度很低，可能是因为这个原因引起的。补救的办法是 使用pinMode()函数设置为输出引脚。</p>

<p>注意：数字13号引脚难以作为数字输入使用，因为大部分的控制板上使用了一颗LED与一个电阻连接到他。如果启动了内部的20K上拉电阻，他的电压将在1.7V左右，而不是正常的5V，因为板载LED串联的电阻把他使他降了下来，这意味着他返回的值总是LOW。如果必须使用数字13号引脚的输入模式，需要使用外部上拉下拉电阻。</p>

<p>delay(): 使程序暂定设定的时间（单位毫秒）。（一秒等于1000毫秒）</p>

<p>编译并烧入到开发板后，可以看到系统的LED灯开始闪烁。</p>

<p>7. 更多的LED</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setup()
</span><span class='line'>{
</span><span class='line'>  for (int i=2; i&lt;=7; i++)    //通过循环的方式设置2-7号引脚为输出状态
</span><span class='line'>  {
</span><span class='line'>    pinMode(i,OUTPUT);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>void loop()
</span><span class='line'>{
</span><span class='line'>  for (int x=2; x&lt;=7; x++)
</span><span class='line'>//通过循环的方式依次让每个引脚的led在1秒内完成明灭
</span><span class='line'>  {
</span><span class='line'>    digitalWrite(x,HIGH);
</span><span class='line'>    delay(500);
</span><span class='line'>    digitalWrite(x,LOW);
</span><span class='line'>    delay(500);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/12/qemukuai-su-bao-cun-he-hui-fu-zhuang-tai/">Qemu快速保存和恢复状态</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-12T09:41:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:41 am</span></time>
        
         | <a href="/blog/2013/07/12/qemukuai-su-bao-cun-he-hui-fu-zhuang-tai/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 启动镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda hd.qcow2</span></code></pre></td></tr></table></div></figure>


<p>2. 保存当前运行状态：</p>

<p>同时按下ctrl+alt+2切换到Qemu内建命令行，输入:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) savevm booted</span></code></pre></td></tr></table></div></figure>


<p>如果需要即时回复到保存时状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) loadvm booted</span></code></pre></td></tr></table></div></figure>


<p>关闭Qemu运行窗口</p>

<p>3. 快速恢复到保存状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-i386 -hda hd.qcow2 -loadvm booted</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/">用Qemu和GNU编译链研究ARM汇编(4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-11T21:46:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:46 pm</span></time>
        
         | <a href="/blog/2013/07/11/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-4/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 有关异常向量</p>

<p>前面的例子中存在一个大BUG，内存布局中的前8个全字是为异常向量而保留的。当异常发生时控制逻辑将转到这些位置以执行对应的异常处理代码。异常向量和它们的地址如下：</p>

<ul>
<li>Exception  Address</li>
<li>Reset  0x00</li>
<li>Undefined Instruction  0x04</li>
<li>Software Interrupt (SWI)   0x08</li>
<li>Prefetch Abort     0x0C</li>
<li>Data Abort     0x10</li>
<li>Reserved, not used     0x14</li>
<li>IRQ    0x18</li>
<li>FIQ    0x1C</li>
</ul>


<p>按理说，这些个异常向量应该对应到异常处理程序中，既然我们代码中不会有异常发生，索性就用死循环来代替，如下：</p>

<figure class='code'><figcaption><span>vector.s -vector.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span></code></pre></td></tr></table></div></figure>


<p>对应的，为了确保这些指令被放置在异常向量地址中，链接脚本也需要做相应的改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>                * (vectors);
</span><span class='line'>                * (.text);
</span><span class='line'>                ...
</span><span class='line'>        }
</span><span class='line'>        ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>异常向量需要放置在所有代码之前，这确保了代了向量是从0x0地址开始。</p>

<p>2. C启动代码</p>

<p>直接执行C代码会造成CPU直接重启，因为和汇编代码不同的是C语言需要初始化运行环境。</p>

<figure class='code'><figcaption><span>sum.c -sum.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>C语言运行环境需要设置
1. 栈
2. 全局变量： 已初始化的 &amp;&amp; 未初始化的
3. 只读数据</p>

<p>2.1 栈设置</p>

<p>栈被用来存储自动变量，传递函数变量，存储返回地址等等。ARM Architecture
Procedure Call Standard
(AAPCS)是ARM体系结构中用于生成栈的规则。r13被用于作栈指针。</p>

<p>对于特定的开发板来说，栈开始地址可能不同，对于connex开发板来说，地址可以用下面的代码来定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ldr sp, =0xA4000000</span></code></pre></td></tr></table></div></figure>


<p>2.2 全局变量</p>

<p>C代码在编译时会把已初始化的全局变量放在.data段中，因而在初始化的汇编代码中，需要把.data段从Flash搬移到RAM中。</p>

<p>C代码确保未初始化的全局变量被初始化成0.
当C程序被编译时，独立的.bss段被用作未初始化的变量。因为未初始化的值都是0,我们无需将其存储在FLASH中。只不过在搬移的时候，我们需要在程序中将它们初始化为0而已。</p>

<p>2.3 只读数据</p>

<p>const常量会被初始化为.rodata， .rodata也被用于存储字符常量。</p>

<p>.rodata在运行时不会被改变，所以它们可以被直接放置在FLASH中。</p>

<p>2.4 启动代码</p>

<p>Linker脚本需要做下面的事：
1. .bss部分代替
2.  vectors部分代替
3. .rodata部分代替</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (vectors);
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        .rodata : {
</span><span class='line'>              * (.rodata);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {
</span><span class='line'>              * (.data);
</span><span class='line'>        }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>
</span><span class='line'>        sbss = .;
</span><span class='line'>        .bss : {
</span><span class='line'>             * (.bss);
</span><span class='line'>        }
</span><span class='line'>        ebss = .;
</span><span class='line'>        bss_size = ebss - sbss;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>启动代码需要完成下列任务：
1. 中断向量设置
2. 将.data部分从FLASH拷贝到RAM
3. 将.bss置0后拷贝到RAM
4. 设置栈指针(stack pointer)
5. 分支程序到main函数</p>

<figure class='code'><figcaption><span>startup.s - startup.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>section <span class="s">&quot;vectors&quot;</span>
</span><span class='line'>reset<span class="o">:</span>  b     start
</span><span class='line'>undef<span class="o">:</span>  b     undef
</span><span class='line'>swi<span class="o">:</span>    b     swi
</span><span class='line'>pabt<span class="o">:</span>   b     pabt
</span><span class='line'>dabt<span class="o">:</span>   b     dabt
</span><span class='line'>        nop
</span><span class='line'>irq<span class="o">:</span>    b     irq
</span><span class='line'>fiq<span class="o">:</span>    b     fiq
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Copy data to RAM.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle data_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_bss
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb   r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs   r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne    copy
</span><span class='line'>
</span><span class='line'>init_bss<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize <span class="m">.</span>bss
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>sbss
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ebss
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>bss_size
</span><span class='line'>
</span><span class='line'>        <span class="o">@@</span> Handle bss_size <span class="o">==</span> <span class="m">0</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>        beq   init_stack
</span><span class='line'>
</span><span class='line'>        mov   r4<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>zero<span class="o">:</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   zero
</span><span class='line'>
</span><span class='line'>init_stack<span class="o">:</span>
</span><span class='line'>        <span class="o">@@</span> Initialize the stack pointer
</span><span class='line'>        ldr   sp<span class="p">,</span> <span class="o">=</span><span class="mh">0xA4000000</span>
</span><span class='line'>
</span><span class='line'>        bl    main
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b     <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将直接用arm-none-eabi-gcc来编译所有程序：
    arm-none-eabi-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s
-nostdlib选项用于指定标准C不应该被链接。</p>

<p>查看符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>arm-none-eabi-nm -n csum.elf 
</span><span class='line'>00000000 t reset
</span><span class='line'>00000004 A bss_size
</span><span class='line'>00000004 t undef
</span><span class='line'>00000008 t swi
</span><span class='line'>0000000c t pabt
</span><span class='line'>00000010 t dabt
</span><span class='line'>00000018 A data_size
</span><span class='line'>00000018 t irq
</span><span class='line'>0000001c t fiq
</span><span class='line'>00000020 T main
</span><span class='line'>00000094 t start
</span><span class='line'>000000a8 t copy
</span><span class='line'>000000b8 t init_bss
</span><span class='line'>000000d0 t zero
</span><span class='line'>000000dc t init_stack
</span><span class='line'>000000e4 t stop
</span><span class='line'>00000100 r n
</span><span class='line'>00000104 R flash_sdata
</span><span class='line'>a0000000 d arr
</span><span class='line'>a0000000 D ram_sdata
</span><span class='line'>a0000018 D ram_edata
</span><span class='line'>a0000018 D sbss
</span><span class='line'>a0000018 b sum
</span><span class='line'>a000001c B ebss</span></code></pre></td></tr></table></div></figure>


<p>可以看到： 中断向量从0x0开始; 汇编代码从8个全字后开始(0x20==32==8<em>4);
只读数据n放在代码之后; arr，初始化后的数据，放在RAM中;
未初始化的数据,sum放在6个int之后6</em>4==24==0x18</p>

<p>转化成.bin二进制格式后，在Qemu中运行之，检查结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary csum.elf csum.bin  
</span><span class='line'>$ dd if=/dev/zero of=./flash.bin bs=4K count=4K
</span><span class='line'>      $ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc
</span><span class='line'>      $ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>(qemu) xp /6dw 0xa0000000
</span><span class='line'>a0000000:          1         10          4          5
</span><span class='line'>a0000010:          6          7
</span><span class='line'>(qemu) xp /1dw 0xa0000018
</span><span class='line'>a0000018:         33</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，1, 10, 4, 5, 6, 7 分别为数组元素，而结果为33,
储存在0x18的地址。如果感兴趣，我们大可查找出别的数据地址，这里就不一一述说了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/">用Qemu和GNU编译链研究ARM汇编(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T20:50:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:50 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在多个文件构成的程序中，源文件首先被编译成多个对象(object)文件(.o文件),
然后交由链接器生成最终的可执行文件，如下图所示：</p>

<p><img class="img" src="/images/linker.png"></p>

<p>在组建可执行文件时，链接器主要完成下列操作:</p>

<ul>
<li>解析符号</li>
<li>重定位</li>
</ul>


<p>1. 符号解析</p>

<p>在编译单个文件组成的程序时，所有标号的解析都可以由汇编器替代为对应的地址。而在多文件组成的程序中，如果有储存在其他文件中的符号引用，汇编器会将其标识为"unresolved"(未解析).当对象文件被传递给链接器时，链接器从这些文件中决定对应的值，并把code中的unresolved的值替代为正确的值。</p>

<p>我们用上一节的求和函数来演示链接器是如何进行符号解析的。
这两个文件汇编后，会在链接时被检查未被解析的引用。</p>

<figure class='code'><figcaption><span>main.s - main.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>main.s
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>
</span><span class='line'>        bl    sum               <span class="o">@</span> Invoke the sum subroutine
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>sum-sub.s - sum-sub.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="kp">sum</span><span class="o">-</span>sub.s
</span><span class='line'>        <span class="o">@</span> Args
</span><span class='line'>        <span class="o">@</span> r0<span class="o">:</span> Start address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span> r1<span class="o">:</span> End address of <span class="kt">array</span>
</span><span class='line'>        <span class="o">@</span>
</span><span class='line'>        <span class="o">@</span> Result
</span><span class='line'>        <span class="o">@</span> r3<span class="o">:</span> Sum of Array
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>global <span class="kp">sum</span>
</span><span class='line'>
</span><span class='line'><span class="kp">sum</span><span class="o">:</span>    mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *r0++    ; Get array element</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2      <span class="p">;</span> Calculate <span class="kp">sum</span>
</span><span class='line'>        cmp   r0<span class="p">,</span> r1            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r0 <span class="o">!=</span> r1<span class="p">)</span> <span class="p">;</span> Check <span class="kr">if</span> hit end<span class="o">-</span>of<span class="o">-</span><span class="kt">array</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop  <span class="p">;</span> Loop
</span><span class='line'>        mov   pc<span class="p">,</span> lr            <span class="o">@</span> pc <span class="o">=</span> lr       <span class="p">;</span> Return when done
</span></code></pre></td></tr></table></div></figure>


<p>查看.o文件符号信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm main.o
</span><span class='line'>00000004 t arr
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000008 t start
</span><span class='line'>00000014 t stop
</span><span class='line'>         U sum
</span><span class='line'>$ arm-none-eabi-nm sum-sub.o 
</span><span class='line'>00000004 t loop
</span><span class='line'>00000000 T sum</span></code></pre></td></tr></table></div></figure>


<p>t代表符号已经被定义了， 而u则代表符号未被定义。大写字母表示该符号是全局变量。</p>

<p>从上面的输出结果看，sum是被定义在sum-sub.o的全局变量，而该变量在main.o中未被解析到。当linker被调用时，符号引用将被解析到，对应的可执行文件将被生成。</p>

<p>总结： as程序负责把.s文件编译成object文件，而生成最终的可执行文件时，ld负责把未被定位的符号定位到实际的库函数所在的位置。</p>

<p>2. 重定位.</p>

<p>重定位用于改变已经分配给标号的地址。它包括将所有符号引用映射到新分配的内存地址。</p>

<p>合并段后的符号列表情况，可以对比于上面的main.o和sum-sub.o来看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000000
</span><span class='line'>$ arm-none-eabi-nm sum.elf
</span><span class='line'>00000004 t arr
</span><span class='line'>00008038 T __bss_end__
</span><span class='line'>00008038 T _bss_end__
</span><span class='line'>00008038 T __bss_start
</span><span class='line'>00008038 T __bss_start__
</span><span class='line'>00008038 T __data_start
</span><span class='line'>00008038 T _edata
</span><span class='line'>00008038 T _end
</span><span class='line'>00008038 T __end__
</span><span class='line'>00000007 t eoa
</span><span class='line'>00000024 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000008 t start
</span><span class='line'>         U _start
</span><span class='line'>00000014 t stop
</span><span class='line'>00000020 T sum</span></code></pre></td></tr></table></div></figure>


<p>可以看到stop后面的sum已经被定位好了(之前是main.o中的U标记)，而loop则相应延后，被定位到了再往后的00000024。</p>

<p>地址的变更： loop原本地址为00000004, 现在是00000024, 而sum原本为0x00000000，现在为00000020, 这是因为sum-sub.o中的.text和main.o中的.text部分一起组成了sum.elf中的.text部分。</p>

<p>整体移动某个段到指定内存位置, 注意在-Ttext中我们增加的0x100的偏移量，使得地址对比于上面的结果整体上移了0x100:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x100 -o sum100.elf main.o sum-sub.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000100
</span><span class='line'>$ arm-none-eabi-nm sum100.elf 
</span><span class='line'>00000104 t arr
</span><span class='line'>00008138 T __bss_end__
</span><span class='line'>00008138 T _bss_end__
</span><span class='line'>00008138 T __bss_start
</span><span class='line'>00008138 T __bss_start__
</span><span class='line'>00008138 T __data_start
</span><span class='line'>00008138 T _edata
</span><span class='line'>00008138 T _end
</span><span class='line'>00008138 T __end__
</span><span class='line'>00000107 t eoa
</span><span class='line'>00000124 t loop
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000108 t start
</span><span class='line'>         U _start
</span><span class='line'>00000114 t stop
</span><span class='line'>00000120 T sum</span></code></pre></td></tr></table></div></figure>


<p>3. 重定位.data到RAM中。</p>

<p>我们可以通过撰写链接脚本，将程序的.data段放置在RAM中。这也是通常嵌入式系统所谓bootloader干的活儿，从Flash中加载启动代码到RAM中而后执行。</p>

<p>例程从RAM中加载两个数值，将两者相加而后将结果写回RAM，两个值和结果都放置在.data部分。</p>

<p>代码：</p>

<figure class='code'><figcaption><span>sum_ram.s - sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.4</span>byte <span class="m">0</span>                <span class="o">@</span> <span class="m">4</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>链接脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从connex的内存布局来看，内存地址为0xa000_0000到0xa400_0000，因而A0000000刚好在内存中。</p>

<p>查看链接后的内存符号地址:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o sum.o sum.s
</span><span class='line'>$ arm-none-eabi-ld -T sum_link.ld -o sum.elf sum.o 
</span><span class='line'>$ arm-none-eabi-nm -n sum.elf 
</span><span class='line'>00000000 t start
</span><span class='line'>0000001c t stop
</span><span class='line'>a0000000 d val1
</span><span class='line'>a0000004 d val2
</span><span class='line'>a0000008 d result</span></code></pre></td></tr></table></div></figure>


<p>这样就完了？NO！！！！！！！！因为：RAM is Volatile! 内存是易变的！</p>

<p>RAM是易失性介质，怎可保证每次加电时就有代码洗干净PP在等着被运行？嵌入式系统里必然有非易失性存储，所有的代码和数据在加电前都需要放在这些非易失性存储介质中，例如在FLASH中。这样在加电后我们就可以利用一段启动代码把代码从FLASH搬到RAM中。</p>

<p>从这个设计思路出发，我们需要程序的.data有两个地址，一个是加载地址，另一个是运行地址。
这就是常说的：LMA(Load Memory Address)  VS    VMA(Virtual Memory Address)。</p>

<p>上面的代码需要做两个修改:</p>

<ol>
<li>需要在.data中指定load地址和运行地址</li>
<li>需要写一段代码用于将数据从FLASH读取到RAM中, 从存储地址到运行地址。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : { * (.text); }
</span><span class='line'>        etext = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        .data : AT (etext) { * (.data); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>etext包含了FLASH中放置完地址后的空白地址，记住这个地址以便在接下来将这个数值传送给.data部分，以便程序将.data部分从FLASH拷贝到RAM中。etext只是符号表中的一个，本身并不占据任何内存(可以回去翻上一篇日志)。</p>

<p>关于AT关键字:  它指定了.data部分的加载地址，一个地址或符号被传递给AT关键字，以便它从该地址拷贝数据。 在这里，我们传递etext符号给AT。</p>

<p>要把代码从FLASH拷贝到RAM中，下列信息需要被提供：</p>

<ol>
<li>Flash中数据地址(flash_sdata)</li>
<li>RAM中数据地址(ram_sdata)</li>
<li>.data部分大小(data_size)</li>
</ol>


<p>拷贝代码：</p>

<figure class='code'><figcaption><span>modified_sum_ram.s - modified_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span></code></pre></td></tr></table></div></figure>


<p>由此，我们需要在链接脚本中生成这三个数值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SECTIONS {
</span><span class='line'>        . = 0x00000000;
</span><span class='line'>        .text : {
</span><span class='line'>              * (.text);
</span><span class='line'>        }
</span><span class='line'>        flash_sdata = .;
</span><span class='line'>
</span><span class='line'>        . = 0xA0000000;
</span><span class='line'>        ram_sdata = .;
</span><span class='line'>        .data : AT (flash_sdata) {* (.data); }
</span><span class='line'>        ram_edata = .;
</span><span class='line'>        data_size = ram_edata - ram_sdata;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ram_sdata为ram中数据开始地址，而ram_edata为结束地址，两者相减则为数据块大小。</p>

<p>改变后的带有copy数据的代码：</p>

<figure class='code'><figcaption><span>final_sum_ram.s - final_sum_ram.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>data
</span><span class='line'>val1<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">10</span>               <span class="o">@</span> First number
</span><span class='line'>val2<span class="o">:</span>   <span class="m">.4</span>byte <span class="m">30</span>               <span class="o">@</span> Second number
</span><span class='line'>result<span class="o">:</span> <span class="m">.</span>space <span class="m">4</span>                <span class="o">@</span> <span class="m">1</span> byte space <span class="kr">for</span> result
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>text
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Copy data to RAM.
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>flash_sdata
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>ram_sdata
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="o">=</span>data_size
</span><span class='line'>
</span><span class='line'>copy<span class="o">:</span>
</span><span class='line'>        ldrb  r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        strb  r4<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1</span>
</span><span class='line'>        subs  r2<span class="p">,</span> r2<span class="p">,</span> <span class="c1">#1</span>
</span><span class='line'>        bne   copy
</span><span class='line'>
</span><span class='line'>        <span class="p">;;</span> Add and store result.
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>val1         <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>val1
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>val2         <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>val2
</span><span class='line'>
</span><span class='line'>        ldr   r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> r2 <span class="o">=</span> <span class="o">*</span>r0
</span><span class='line'>        ldr   r3<span class="p">,</span> <span class="p">[</span>r1<span class="p">]</span>          <span class="o">@</span> r3 <span class="o">=</span> <span class="o">*</span>r1
</span><span class='line'>
</span><span class='line'>        add   r4<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r4 <span class="o">=</span> r2 <span class="o">+</span> r3
</span><span class='line'>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>result       <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>result
</span><span class='line'>        str   r4<span class="p">,</span> <span class="p">[</span>r0<span class="p">]</span>          <span class="o">@</span> <span class="o">*</span>r0 <span class="o">=</span> r4
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用修改过的final_sum_ram.s和link脚本编译，并生成flash.bin后，就可以在qemu-system-arm中验证结果了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information
</span><span class='line'>(qemu) info registers
</span><span class='line'>R00=a0000008 R01=a0000004 R02=0000000a R03=0000001e
</span><span class='line'>R04=00000028 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000038
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000
</span><span class='line'>
</span><span class='line'>(qemu) xp /4dw 0xA0000000
</span><span class='line'>00000000a0000000:         10         30         40          0</span></code></pre></td></tr></table></div></figure>


<p>R04包含了我们相加后的结果, 为0x28=40, R02/R03则分别为操作数10/30. 而通过显示0xA0000000也显示了内存中的值分别为val1/val2/result的值。</p>

<p>接下来的章节中，我们将讲到C代码入口。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-2/">用Qemu和GNU编译链研究ARM汇编(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-10T16:30:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:30 pm</span></time>
        
         | <a href="/blog/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>研究两个汇编程序, 通过研究这两个程序，初步了解ARM汇编的知识：</p>

<ul>
<li>用于求数组和的程序</li>
<li>用于计算字符串长度的程序</li>
</ul>


<p>1. 数组求和</p>

<figure class='code'><figcaption><span>sum.s - sum.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>entry<span class="o">:</span>  b start                 <span class="o">@</span> Skip over the data
</span><span class='line'>arr<span class="o">:</span>    <span class="m">.</span>byte <span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">25</span>        <span class="o">@</span> Read<span class="o">-</span>only <span class="kt">array</span> of bytes
</span><span class='line'>eoa<span class="o">:</span>                            <span class="o">@</span> Address of end of <span class="kt">array</span> <span class="o">+</span> <span class="m">1</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>
</span><span class='line'>        ldr   r0<span class="p">,</span> <span class="o">=</span>eoa          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>eoa
</span><span class='line'>        ldr   r1<span class="p">,</span> <span class="o">=</span>arr          <span class="o">@</span> r1 <span class="o">=</span> <span class="o">&amp;</span>arr
</span><span class='line'>        mov   r3<span class="p">,</span> <span class="c1">#0            @ r3 = 0</span>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r1<span class="p">],</span> <span class="c1">#1      @ r2 = *r1++</span>
</span><span class='line'>        add   r3<span class="p">,</span> r2<span class="p">,</span> r3        <span class="o">@</span> r3 <span class="o">+=</span> r2
</span><span class='line'>        cmp   r1<span class="p">,</span> r0            <span class="o">@</span> <span class="kr">if</span> <span class="p">(</span>r1 <span class="o">!=</span> r2<span class="p">)</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>.byte声明：</p>

<p>.byte声明的变量在内存中以连续的比特存在，.2byte和.4byte与之类似，分别用于存储16位值和32位值。联想到C语言中的内建数据结构定义，不难想象char/int/long int 预编译完是哪一种类型。</p>

<p>通用语法结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.byte   exp1, exp2, ...
</span><span class='line'>.2byte  exp1, exp2, ...
</span><span class='line'>.4byte  exp1, exp2, ...</span></code></pre></td></tr></table></div></figure>


<p>你可以指定数据的格式，二进制用前缀0b/0B修饰，八进制以前缀0修饰，十进制/十六进制以0x/0X开头。整数也可以用字符常量来表示，加上单引号即可，在这种情况下ASCII码会被用到。</p>

<p>也可以用C表达式，包含文字和其他符号的组合，如下例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pattern:  .byte 0b01010101, 0b00110011, 0b00001111
</span><span class='line'>npattern: .byte npattern - pattern
</span><span class='line'>halpha:   .byte 'A', 'B', 'C', 'D', 'E', 'F'
</span><span class='line'>dummy:    .4byte 0xDEADBEEF
</span><span class='line'>nalpha:   .byte 'Z' - 'A' + 1</span></code></pre></td></tr></table></div></figure>


<p>.align声明：</p>

<p>ARM指令需要32位对齐，指令的起始内存地址需要是4的倍数，所以用.align指令来插入无用的byte，来确保下一条指令的起始地址是4的倍数。在代码中存在byte或是半字(half words)的时候，需要用到这条指令。</p>

<p>编译&amp;运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># assemble
</span><span class='line'>$ arm-none-eabi-as -o sum.o sum.s 
</span><span class='line'># link to elf file
</span><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf sum.o
</span><span class='line'># form bin file
</span><span class='line'>$ arm-none-eabi-objcopy -O binary sum.elf sum.bin
</span><span class='line'># form flash image
</span><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>$ dd if=sum.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'># emulate with flash image
</span><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'># examine the result
</span><span class='line'>R00=00000007 R01=00000007 R02=00000019 R03=00000037
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=00000024
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R03的值正是我们求和的结果:  0x37==55==10+20+25, 可以用一张流程图来表示程序的运行过程</p>

<p>2. 字符串长度</p>

<figure class='code'><figcaption><span>string.s - string.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>        b start
</span><span class='line'>
</span><span class='line'>str<span class="o">:</span>    <span class="m">.</span>asciz <span class="s">&quot;Hello World&quot;</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>equ   nul<span class="p">,</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>        <span class="m">.</span>align
</span><span class='line'>start<span class="o">:</span>  ldr   r0<span class="p">,</span> <span class="o">=</span>str          <span class="o">@</span> r0 <span class="o">=</span> <span class="o">&amp;</span>str
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#0</span>
</span><span class='line'>
</span><span class='line'>loop<span class="o">:</span>   ldrb  r2<span class="p">,</span> <span class="p">[</span>r0<span class="p">],</span> <span class="c1">#1      @ r2 = *(r0++)</span>
</span><span class='line'>        add   r1<span class="p">,</span> r1<span class="p">,</span> <span class="c1">#1        @ r1 += 1</span>
</span><span class='line'>        cmp   r2<span class="p">,</span> <span class="c1">#nul          @ if (r1 != nul)</span>
</span><span class='line'>        bne   loop              <span class="o">@</span>    goto loop
</span><span class='line'>
</span><span class='line'>        sub   r1<span class="p">,</span> r1<span class="p">,</span> <span class="c1">#1        @ r1 -= 1</span>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b <span class="kp">stop</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000010 R01=0000000b R02=00000000 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000002c
</span><span class='line'>PSR=600001d3 -ZC- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>r1是用来存储字符串长度的，计算结果为11。</p>

<p>.asciz声明:
 .asciz声明接受一个字符串作为参数，字符串以双引号修饰的字符表示。汇编器自动在字符串后面加nul字符（即\0字符）</p>

<p>.equ声明
汇编器维持一张符号表，符号表维持键->值的格式。当汇编器遇到一个标号时，汇编器将在符号表中自动建立一个条目。以后当汇编器遇到一个关于label的引用时，将自动替换为符号表中储存的label的地址。</p>

<p>使用汇编器指令.equ，我们可以手动在符号表中插入条目。</p>

<p>.equ通常这样定义:
    .equ name, expression</p>

<p>.equ不会分配任何内存，它们只是在符号表中插入条目罢了。</p>

<p>bne的意思是(!=) , b means bit. bit not equal. ble (&lt;=), beq (==), bge (>=), bgt (>), and bne (!=).</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/">用Qemu和GNU编译链研究ARM汇编(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-09T20:42:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:42 pm</span></time>
        
         | <a href="/blog/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 汇编程序代码格式</p>

<p>汇编代码由一系列的声明所组成，每行一个。每条声明由下列格式组成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>label(标签):   instruction @comment(注释)</span></code></pre></td></tr></table></div></figure>


<p>说明：</p>

<ul>
<li>label:
标签的引入使得在内存中查询指令地址变得很方便，标签可以在任意一个内存地址使用，
例如分支指令中就可以用到标签, 标签可以包括字母、数字_和$符号。</li>
<li>注释：
注释内容必须在@符号之后</li>
<li>指令:
指令可以是ARM指令集或是汇编器指令，汇编器指令是需要传递给汇编器的命令，总是以.开头。</li>
</ul>


<p>2. 一个简单的汇编语言文件:</p>

<figure class='code'><figcaption><span>add.s -add.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'>        <span class="m">.</span>text
</span><span class='line'>start<span class="o">:</span>                       <span class="o">@</span> Label<span class="p">,</span> not really required
</span><span class='line'>        mov   r0<span class="p">,</span> <span class="c1">#5         @ Load register r0 with the value 5</span>
</span><span class='line'>        mov   r1<span class="p">,</span> <span class="c1">#4         @ Load register r1 with the value 4</span>
</span><span class='line'>        add   r2<span class="p">,</span> r1<span class="p">,</span> r0     <span class="o">@</span> Add r0 and r1 and store <span class="kr">in</span> r2
</span><span class='line'>
</span><span class='line'><span class="kp">stop</span><span class="o">:</span>   b stop               <span class="o">@</span> Infinite loop to stop execution
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的意思是，把立即数5载入到寄存器r0, 4载入到r1,
以r1和r0相加的结果填充r2.</p>

<p>.text是汇编器指令，用于告知汇编器需要把代码组装到code段,而不是.data段。有关section的概念在后面将被讲到。</p>

<p>3. 编译二进制文件</p>

<p>GNU的汇编器名字叫as， 用下列命令将源文件编译成.o文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-as -o add.o add.s</span></code></pre></td></tr></table></div></figure>


<p>链接器的名字叫ld，用下列命令可以将二进制文件链接成elf文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o</span></code></pre></td></tr></table></div></figure>


<p>-Ttext指明需要分配给label的地址,
这条指令告诉链接器从地址0x0开始装载指令。我们可以用nm来查看具体的地址分配信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-nm add.elf 
</span><span class='line'>00008010 T __bss_end__
</span><span class='line'>00008010 T _bss_end__
</span><span class='line'>00008010 T __bss_start
</span><span class='line'>00008010 T __bss_start__
</span><span class='line'>00008010 T __data_start
</span><span class='line'>00008010 T _edata
</span><span class='line'>00008010 T _end
</span><span class='line'>00008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>00000000 t start
</span><span class='line'>         U _start
</span><span class='line'>0000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>start和stop之间由0c个字节，因为stop是在start开始后三条指令，
每条指令的长度为4个Byte，3*4=12=0xc</p>

<p>更改链接的参数将得到不同的地址分配。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
</span><span class='line'>arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 20000000
</span><span class='line'>$ arm-none-eabi-nm add.elf
</span><span class='line'>20008010 T __bss_end__
</span><span class='line'>20008010 T _bss_end__
</span><span class='line'>20008010 T __bss_start
</span><span class='line'>20008010 T __bss_start__
</span><span class='line'>20008010 T __data_start
</span><span class='line'>20008010 T _edata
</span><span class='line'>20008010 T _end
</span><span class='line'>20008010 T __end__
</span><span class='line'>00080000 T _stack
</span><span class='line'>20000000 t start
</span><span class='line'>         U _start
</span><span class='line'>2000000c t stop</span></code></pre></td></tr></table></div></figure>


<p>ld得到的文件一般是ELF文件，在有操作系统的时候ELF可以工作的很好，但是我们将在裸机模式下(Bare
Metal)运行此程序， 因此需要将文件类型转化为更简单的binary类型。</p>

<p>GNU编译链的objcopy可以完成不同可执行文件之间的转换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-objcopy -O binary add.elf add.bin
</span><span class='line'>$ file add.bin
</span><span class='line'>add.bin: Hitachi SH big-endian COFF</span></code></pre></td></tr></table></div></figure>


<p>4. 在Qemu中执行二进制文件。</p>

<p>我们将使用connex开发板来模拟运行此程序，它把16MB的Flash放在地址0x0，而通常arm处理器重启时都会执行0x0处的代码。
因而我们需要把add.bin写入到16MB Flash文件的头部。</p>

<p>首先创建一个空的16MB Flash文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=/dev/zero of=flash.bin bs=4k count=4k
</span><span class='line'>4096+0 records in
</span><span class='line'>4096+0 records out
</span><span class='line'>16777216 bytes (17 MB) copied, 0.0153106 s, 1.1 GB/s</span></code></pre></td></tr></table></div></figure>


<p>而后，使用下列命令将add.bin放到Flash头部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
</span><span class='line'>0+1 records in
</span><span class='line'>0+1 records out
</span><span class='line'>16 bytes (16 B) copied, 0.00011154 s, 143 kB/s</span></code></pre></td></tr></table></div></figure>


<p>add.bin大小刚好为16B, notrunc参数代表no truncated，意思是直接覆盖掉原有内容。</p>

<p>用下列命令执行此改动后的flash文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
</span><span class='line'>QEMU 1.4.2 monitor - type 'help' for more information</span></code></pre></td></tr></table></div></figure>


<p>-M connex 指定connex机器， -pflash指定flash.bin代替flash闪存。</p>

<p>-pflash file    use &lsquo;file&rsquo; as a parallel flash image 并行flash镜像</p>

<p>-serial /dev/null 将connex的串口输出重定向到/dev/null</p>

<p>查看寄存器信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) info registers
</span><span class='line'>R00=00000005 R01=00000004 R02=00000009 R03=00000000
</span><span class='line'>R04=00000000 R05=00000000 R06=00000000 R07=00000000
</span><span class='line'>R08=00000000 R09=00000000 R10=00000000 R11=00000000
</span><span class='line'>R12=00000000 R13=00000000 R14=00000000 R15=0000000c
</span><span class='line'>PSR=400001d3 -Z-- A svc32
</span><span class='line'>FPSCR: 00000000</span></code></pre></td></tr></table></div></figure>


<p>R02的值正是计算后的结果4+5=9.
R15=0000000c 猜测应该为指令寄存器，指向stop(0xc)</p>

<p>5. 更多的查看命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>help  List available commands
</span><span class='line'>quit   Quits the emulator
</span><span class='line'>xp /fmt addr   Physical memory dump from addr
</span><span class='line'>system_reset   Reset the system.</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(qemu) help xp
</span><span class='line'>xp /fmt addr -- physical memory dump starting at 'addr'
</span><span class='line'>(qemu) xp /4iw 0x0
</span><span class='line'>0x00000000:  e3a00005      mov    r0, #5  ; 0x5
</span><span class='line'>0x00000004:  e3a01004      mov    r1, #4  ; 0x4
</span><span class='line'>0x00000008:  e0812000      add    r2, r1, r0
</span><span class='line'>0x0000000c:  eafffffe      b  0xc</span></code></pre></td></tr></table></div></figure>


<p>4: 4 个条目被显示, i表示打印出指令，即内建的反汇编，
w表明条目的大小为32个bit，即一个全字。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/">在Qemu上运行Raspberry PI镜像</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T18:09:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:09 pm</span></time>
        
         | <a href="/blog/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载和准备镜像文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget http://downloads.raspberrypi.org/images/raspbian/2013-05-25-wheezy-raspbian/2013-05-25-wheezy-raspbian.zip
</span><span class='line'>$ unzip 2013-05-25-wheezy-raspbian.zip</span></code></pre></td></tr></table></div></figure>


<p>2. 查看镜像文件分区信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fdisk -l 2013-05-25-wheezy-raspbian.img 
</span><span class='line'>Disk 2013-05-25-wheezy-raspbian.img: 1939 MB, 1939865600 bytes, 3788800 sectors
</span><span class='line'>Units = sectors of 1 * 512 = 512 bytes
</span><span class='line'>Sector size (logical/physical): 512 bytes / 512 bytes
</span><span class='line'>I/O size (minimum/optimal): 512 bytes / 512 bytes
</span><span class='line'>Disk label type: dos
</span><span class='line'>Disk identifier: 0x000c7b31
</span><span class='line'>
</span><span class='line'>                         Device Boot      Start         End      Blocks   Id
</span><span class='line'>System
</span><span class='line'>2013-05-25-wheezy-raspbian.img1            8192      122879       57344    c  W95 FAT32 (LBA)
</span><span class='line'>2013-05-25-wheezy-raspbian.img2          122880     3788799     1832960   83  Linux</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看到，根文件分区的地址偏移为512*122880=62914560</p>

<p>3. 更改根分区文件里preload信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo mount ./2013-05-25-wheezy-raspbian.img -o offset=62914560 /mnt3
</span><span class='line'>$ sudo vim /mnt3/etc/ld.so.preload 
</span><span class='line'>#注释掉这一行，否则在qemu启动完系统后将自动提示配置rpi而造成系统无法登陆
</span><span class='line'>#/usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class='line'>$ sudo umount /mnt3</span></code></pre></td></tr></table></div></figure>


<p>4. 用qemu-system-arm启动raspberrypi镜像</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -kernel kernel-qemu -cpu arm1176 -m 256 -M versatilepb \
</span><span class='line'>-no-reboot -serial stdio -append "root=/dev/sda2 panic=1" -hda \
</span><span class='line'>./2013-05-25-wheezy-raspbian.img </span></code></pre></td></tr></table></div></figure>


<p>系统将启动到一个root登陆的无需密码的shell中，运行下列命令以修复文件系统:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ fsck /dev/sda2
</span><span class='line'>$ shutdown -r now</span></code></pre></td></tr></table></div></figure>


<p>再次启动完毕后的登陆用户名和密码如下，接下来就等同于原机操作了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Login as pi
</span><span class='line'>Password raspberry</span></code></pre></td></tr></table></div></figure>


<p>5. ArchLinux on RaspberryPI</p>

<p>基本步骤也是一样，挂在第2块分区后，需要更改etc/fstab做下列修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;          &lt;dump&gt; &lt;pass&gt;
</span><span class='line'>/dev/sda1   /boot           vfat    defaults        0       0
</span><span class='line'>/dev/sda2   /     auto    defaults        0       0</span></code></pre></td></tr></table></div></figure>


<p>之后挂载命令一样。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/">用Qemu模拟ARM(3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T16:35:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>4:35 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 下载并交叉编译u-boot。</p>

<p>新版本的u-boot我加载后总有问题，2009.11版则可以顺利通过编译和测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ wget ftp://ftp.denx.de/pub/u-boot/u-boot-2009.11.tar.bz2
</span><span class='line'>$ tar xjvf u-boot-2009.11.tar.bz2 
</span><span class='line'>$ cd u-boot-2009.11
</span><span class='line'>$ make versatilepb_config arch=ARM CROSS_COMPILE=arm-none-eabi-
</span><span class='line'>$ make all arch=ARM CROSS_COMPILE=arm-none-eabi- </span></code></pre></td></tr></table></div></figure>


<p>编译完成后会在目录下生成u-boot.bin和u-boot文件。</p>

<p>2. 运行u-boot.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel u-boot.bin -nographic</span></code></pre></td></tr></table></div></figure>


<p>如果采用-nographic来运行qemu-system-arm，终端将无法再响应任何系统输入譬如Ctrl+c/ctrl+d_，要终止qemu-system-arm就只能查到进程号再kill。所以我一般不带-nographic选项，启动后ctrl+alt+2去看serial0输出,保留在终端窗口直接ctrl+c杀死qemu-sytem-arm进程的权力。</p>

<p>3. 用u-boot引导镜像文件:</p>

<p>改动上一篇文章里用于构建启动镜像的linker.ld文件，因为u-boot.bin文件大小的缘故，我们需要把启动镜像的起始地址整体上移.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h u-boot.bin 
</span><span class='line'>-rwxr-xr-x 1 Trusty root 85K Jul  8 15:57 u-boot.bin</span></code></pre></td></tr></table></div></figure>


<p>linker.ld文件里， 0x100000，这个大小相比于85K显然已经足够。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>SECTIONS
</span><span class='line'>{
</span><span class='line'>. = 0x100000;
</span><span class='line'>startup : { startup.o(.text)}
</span><span class='line'>.data : {*(.data)}
</span><span class='line'>.bss : {*(.bss)}
</span><span class='line'>. = . + 0x500;
</span><span class='line'>sp_top = .;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>按上一章的编译方法生成output.bin，不再重述。</p>

<p>使用mkimage工具创建u-boot可识别的image文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkimage -A arm -C none -O linux -T kernel -d output.bin -a 0x00100000 -e 0x00100000 output.uimg
</span><span class='line'>Image Name:   
</span><span class='line'>Created:      Mon Jul  8 16:04:11 2013
</span><span class='line'>Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>Data Size:    152 Bytes = 0.15 kB = 0.00 MB
</span><span class='line'>Load Address: 00100000
</span><span class='line'>Entry Point:  00100000
</span><span class='line'>
</span><span class='line'>$ file *.uimg
</span><span class='line'>output.uimg: u-boot legacy uImage, , Linux/ARM, OS Kernel Image (Not \
</span><span class='line'>compressed), 152 bytes, Mon Jul  8 16:04:11 2013, Load Address: 0x00100000,\
</span><span class='line'>Entry Point: 0x00100000, Header CRC: 0x3C62F575, Data CRC: 0x69CE9647</span></code></pre></td></tr></table></div></figure>


<p>将u-boot.bin和output.uimg打包为一个文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat u-boot.bin output.uimg &gt;flash.bin</span></code></pre></td></tr></table></div></figure>


<p>下面这条命令用于计算output.img在使用u-boot加载完flash.bin后在内存中的地址，-kernel选项告诉qemu从0x100000开始加载镜像，即65536。
65536+u-boot.bin后的大小，即output.img在内存中的地址。printf则是用16进制的格式打印出来，以便加载.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ printf "0x%X" $(expr $(stat -c%s u-boot.bin) + 65536)
</span><span class='line'>0x2525C</span></code></pre></td></tr></table></div></figure>


<p>启动qemu-system-arm并运行自定义镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel flash.bin
</span><span class='line'># iminfo 0x2525c
</span><span class='line'>
</span><span class='line'>## Checking Image at 0002525c ...
</span><span class='line'>   Legacy image found
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Verifying Checksum ... OK
</span><span class='line'>
</span><span class='line'>VersatilePB # bootm 0x2525c
</span><span class='line'>## Booting kernel from Legacy Image at 0002525c ...
</span><span class='line'>   Image Name:   
</span><span class='line'>   Image Type:   ARM Linux Kernel Image (uncompressed)
</span><span class='line'>   Data Size:    152 Bytes =  0.1 kB
</span><span class='line'>   Load Address: 00100000
</span><span class='line'>   Entry Point:  00100000
</span><span class='line'>   Loading Kernel Image ... OK
</span><span class='line'>OK
</span><span class='line'>
</span><span class='line'>Starting kernel ...
</span><span class='line'>
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>u-boot可以支持的选项还有很多，包括使用NFS/TFTP启动等等，留待以后慢慢研究。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-2/">用Qemu模拟ARM(2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T15:18:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>3:18 pm</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1. 关于Bootloader:</p>

<p>(引导程序)位于电脑或其他计算机应用上，是指引导操作系统启动的程序。引导程序启动方式和程序视应用机型种类而不同。例如在普通的个人电脑上，引导程序通常分为两部分：第一阶段引导程序位于主引导记录（MBR），用以引导位于某个分区上的第二阶段引导程序，如NTLDR、GNU
GRUB等。</p>

<p> 嵌入式系统中常见的Bootloader主要有以下几种:</p>

<ul>
<li>Das U-Boot
是一个主要用于嵌入式系统的开机载入程序，可以支持多种不同的计算机系统结构，包括PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。</li>
<li>vivi是由mizi公司设计为ARM处理器系列设计的一个bootloader.</li>
<li>Redboot (Red Hat Embedded Debug and Bootstrap)是Red
Hat公司开发的一个独立运行在嵌入式系统上的BootLoader程序，是目前比较流行的一个功能、可移植性好的BootLoader。</li>
</ul>


<p>2. 关于“裸机编程(Bare-Metal)”:</p>

<p>微控制器开发人员很熟悉这个概念，
Bare-Metal是指的你的程序和处理器之间没有任何东西&mdash;-你写的程序将直接运行在处理器上,
换言之，开发人员是在直接操控硬件。在裸机编程的场景中，需要由开发人员检查并排除任何一个可以导致系统崩溃的风险。</p>

<p>&ldquo;Bare-Metal"要求开发人员了解关于硬件的细节，所以接下来我们将对编译链和qemu本身进行分析。</p>

<p>3. 下载qemu源码包并查询相关硬件信息：</p>

<p>ArchLinux采用ABS(Arch Build
System)来管理源码包，下面的步骤将qemu源码包下载到本地，更详细的关于ABS的操作可以在ArchLinux的Wiki中找到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pacman -S abs
</span><span class='line'>$ pacman -Ss qemu
</span><span class='line'>extra/qemu 1.4.2-2 [installed]
</span><span class='line'>$ abs extra/qemu 
</span><span class='line'>$ cp -r /var/abs/extra/qemu/ ~/abs 
</span><span class='line'>$ cd ~/abs && makepkg -s --asroot -o</span></code></pre></td></tr></table></div></figure>


<p>得到versatilepb开发板的CPU型号, 可以看到"arm926"是我们要的结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grep "arm" src/qemu-1.4.2/hw/versatilepb.c 
</span><span class='line'>#include "arm-misc.h"
</span><span class='line'>static struct arm_boot_info versatile_binfo;
</span><span class='line'>        args-&gt;cpu_model = "arm926";
</span><span class='line'>    cpu = cpu_arm_init(args-&gt;cpu_model);
</span><span class='line'>    cpu_pic = arm_pic_init_cpu(cpu);
</span><span class='line'>    arm_load_kernel(cpu, &versatile_binfo);</span></code></pre></td></tr></table></div></figure>


<p>得到versatilepb开发板的串口寄存器硬件信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grep "UART*" src/qemu-1.4.2/hw/versatilepb.c 
</span><span class='line'>    /*  0x10009000 UART3.  */
</span><span class='line'>    /*  0x101f1000 UART0.  */
</span><span class='line'>    /*  0x101f2000 UART1.  */
</span><span class='line'>    /*  0x101f3000 UART2.  */</span></code></pre></td></tr></table></div></figure>


<p>所以说开源是王道嘛，很快就查到了每一个需要了解的细节。UART0在内存中map到的地址是0x101f1000,
我们直接往这个地址写数据，就可以在终端上看到数据输出了。</p>

<p>4. 查看编译链支持的平台：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat ~/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/share/doc/arm-arm-none-eabi/info/gcc.info | grep arm926
</span><span class='line'>     `arm926ej-s', `arm940t', `arm9tdmi', `arm10tdmi', `arm1020t',</span></code></pre></td></tr></table></div></figure>


<p>arm926ej-s是被支持的，因此我们可以用这套编译链来生成需要的裸机调试代码。</p>

<p>5. 启动应用程序init.c的编写:</p>

<p>首先创建应用程序init.c：</p>

<figure class='code'><figcaption><span>init.c - init.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">UART0_PTR</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0101f1000</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">){</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">string</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span><span class='line'>        <span class="o">*</span><span class="n">UART0_PTR</span> <span class="o">=</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">my_init</span><span class="p">(){</span>
</span><span class='line'>    <span class="n">display</span><span class="p">(</span><span class="s">&quot;Hello Open World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>init.c中，我们首先声明一个volatile变UART0_PTR,volatile关键字用于告知编译器此变量是用于直接访问内存映像设备的，即串口0内存地址</p>

<p>display()函数则是用于将字符串中的字符按顺序输出到串口0, 直到遇到字符串结尾。</p>

<p>my_init()调用了display(), 接下来我们将把它作为C入口函数.</p>

<p>预编译init.c:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-gcc -c -mcpu=arm926ej-s init.c -o init.o</span></code></pre></td></tr></table></div></figure>


<p>6. 启动代码start.s编写：</p>

<figure class='code'><figcaption><span>start.s - start.s </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='s'><span class='line'><span class="m">.</span>global _Start
</span><span class='line'>_Start<span class="o">:</span>
</span><span class='line'>LDR sp<span class="p">,</span> <span class="o">=</span> sp_top
</span><span class='line'>BL my_init
</span><span class='line'>B <span class="m">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理器加电后，将跳转到指定的内存地址,从此地址开始读入并执行代码。</p>

<p>_Start被声明为全局函数，_Start的实现中，首先将栈地址指向sp_top, LDR(load),
sp是栈地址寄存器(stack pointer),</p>

<p>BL则是跳转指令，跳转到my_init函数，事实上你可以跳转到任何一个你想跳转的函数，临时写一个their_init()跳转过去也行。Debug时常更改这里以调试不同的子系统功能。</p>

<p>&ldquo;B."可以理解为汇编里的while(1)或for(;;)循环，处理器空转，什么也不做。如果不调用它，系统就会崩溃。所谓嵌入式编程的一个基本理念就是，代码无限循环。</p>

<p>预编译汇编文件start.s:
    $ arm-none-eabi-as -mcpu=arm926ej-s startup.s -o startup.o</p>

<p>7. 接下来我们需要用一个可以被编译器识别的链接脚本链接两文件, linker.ld:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(_Start)
</span><span class='line'>  SECTIONS
</span><span class='line'>  {
</span><span class='line'>  . = 0x10000;
</span><span class='line'>  startup : { startup.o(.text)}
</span><span class='line'>  .data : {*(.data)}
</span><span class='line'>  .bss : {*(.bss)}
</span><span class='line'>  . = . + 0x500;
</span><span class='line'>  sp_top = .;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>ENTRY(_Start)用于告知链接器程序的入口点(entry point)是_Start(start.s中定义).
Qemu模拟器如果加上-kernel选项时，将自动从0x10000开始执行，所以我们必须将代码放到这个地址。所以第四行我们指定".
= 0x10000". SECTIONS就是用于定义程序的不同部分的。</p>

<p>startup.o组成了代码的text部分，然后是data部分和bss部分，最后一步则定义了栈指针(sp,
stack pointer)地址. 栈通常是向下增长的，所以最好给它一个比较安全的地址， . =
.+0x500就是用于避免栈被改写的。sp_top用于存储栈顶地址。</p>

<p>有关程序结构：</p>

<ul>
<li>BSS段:  在采用段式内存管理的架构中，BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。.bss section的空间结构类似于stack, 主要用于存储静态变量、未显式初始化、在变量使用前由运行时初始化为零。</li>
<li>数据段(data segment): 通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>代码段(code segment/text segment): 通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许程序自修改。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>


<p>编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-eabi-ld -T linker.ld init.o startup.o -o output.elf
</span><span class='line'>$ file output.elf 
</span><span class='line'>output.elf: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),statically linked, not stripped
</span><span class='line'>$  arm-none-eabi-objcopy -O binary output.elf output.bin
</span><span class='line'>$ file output.bin 
</span><span class='line'>output.bin: data</span></code></pre></td></tr></table></div></figure>


<p>8. 使用qemu-system-arm运行output.bin:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm --help | grep nographic 
</span><span class='line'>-nographic      disable graphical output and redirect serial I/Os to console.
</span><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>9. Play more tricks:
改动init.c里的串口输出地址为串口1：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>volatile unsigned char * const UART0_PTR = (unsigned char *)0x0101f2000;
</span><span class='line'>  // 0x101f1000  --&gt; 0x101f2000</span></code></pre></td></tr></table></div></figure>


<p>按照步骤3～7里重新编译，并运行以查看结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 没有反应！
</span><span class='line'>$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
</span><span class='line'># 终端有输出字符。
</span><span class='line'>$ qemu-system-arm -M versatilepb -kernel output.bin -serial vc:800x600 -serial stdio
</span><span class='line'>Hello Open World</span></code></pre></td></tr></table></div></figure>


<p>同样你也可以把字符输出到第三个串口，只不过前两个-serial的重定向需要指定到别的设备而已。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/08/yong-qemumo-ni-arm-1/">用Qemu模拟ARM(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-07-08T10:45:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>10:45 am</span></time>
        
         | <a href="/blog/2013/07/08/yong-qemumo-ni-arm-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前面已经安装并配置了编译链和qemu，现在可以用qemu来模拟arm平台了。</p>

<p>1. Hello, Qemu!</p>

<p>输入下面的代码:</p>

<figure class='code'><figcaption><span>hello.c - hello.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, Qemu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-linux-gnueabi-gcc -o hello hello.c -static
</span><span class='line'>$ qemu-arm ./hello
</span><span class='line'>$ file hello
</span><span class='line'>hello: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), \
</span><span class='line'> statically linked, for GNU/Linux 2.6.16, not stripped</span></code></pre></td></tr></table></div></figure>


<p>不加-static变量的话，运行时则需要使用-L选项链接到相应的运行库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-arm -L /home/Trusty/CodeSourcery/\
</span><span class='line'>Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/\
</span><span class='line'>arm-none-linux-gnueabi/libc/  ./hello_1 
</span><span class='line'>Hello, Qemu!
</span><span class='line'>$ file hello_1
</span><span class='line'>hello_1: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),\
</span><span class='line'> dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped</span></code></pre></td></tr></table></div></figure>


<p>动态编译和静态编译生成的文件大小差别：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls -l -h
</span><span class='line'>total 656K
</span><span class='line'>-rwxr-xr-x 1 Trusty root 640K Jul  7 18:46 hello
</span><span class='line'>-rwxr-xr-x 1 Trusty root 6.6K Jul  7 18:48 hello_1</span></code></pre></td></tr></table></div></figure>


<h3>小插曲1：</h3>

<p>系统里安装了两套编译链arm-none-eabi-和arm-none-linux-eabi-,很容易让人混淆，可参考编译链的命名规则：</p>

<p>arch(架构)-vendor(厂商名)-(os(操作系统名)-)abi(Application Binary
Interface，应用程序二进制接口)</p>

<p>举例说明：</p>

<ul>
<li>x86_64-w64-mingw32 = x86_64 &ldquo;arch"字段 (=AMD64), w64 (=mingw-w64
是"vendor"字段), mingw32 (=GCC所见的win32 API)</li>
<li>i686-unknown-linux-gnu = 32位 GNU/linux编译链</li>
<li>arm-none-linux-gnueabi = ARM 架构, 无vendor字段, linux 系统, gnueabi ABI.</li>
<li>arm-none-eabi = ARM架构, 无厂商, eabi ABI(embedded abi)</li>
</ul>


<p>两种编译链的主要区别在于库的差别，前者没有后者的库多，后者主要用于在有操作系统的时候编译APP用的。前者不包括标准输入输出库在内的很多C标准库，适合于做面向硬件的类似单片机那样的开发。因而如果采用arm-none-eabi-gcc来编译hello.c会出现链接错误。</p>

<h3>小插曲2：</h3>

<p>qemu-arm和qemu-system-arm的区别：</p>

<ul>
<li>qemu-arm是用户模式的模拟器(更精确的表述应该是系统调用模拟器)，而qemu-system-arm则是系统模拟器，它可以模拟出整个机器并运行操作系统</li>
<li>qemu-arm仅可用来运行二进制文件，因此你可以交叉编译完例如hello
world之类的程序然后交给qemu-arm来运行，简单而高效。而qemu-system-arm则需要你把hello
world程序下载到客户机操作系统能访问到的硬盘里才能运行。</li>
</ul>


<p>2. 使用qemu-system-arm运行Linux内核</p>

<p>从www.kernel.org下载最新内核,而后解压</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ tar xJf linux-3.10.tar.xz
</span><span class='line'>$ cd linux-3.10
</span><span class='line'>$ make ARCH=arm versatile_defconfig
</span><span class='line'>$ make menuconfig ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-</span></code></pre></td></tr></table></div></figure>


<p>上面的命令指定内核架构为arm，交叉编译链为arm-none-linux-gnueabi,
需要在make menuconfig弹出的窗口中选择到 “Kernel Features”, 激活“Use the ARM
EABI to compile the kernel”,
如果不激活这个选项的话，内核将无法加载接下来要制作的initramfs。</p>

<p>如果需要在u-boot上加载内核，就要编译为uImage的格式，uImage通过mkimage程序来压缩的，ArchLinux的yaourt仓库里可以找到这个包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ yaourt -S mkimage</span></code></pre></td></tr></table></div></figure>


<p>安装好mkimage后，开始编译内核，因为CPU有4核，所以开启了-j8选项以加速编译:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- all -j8 uImage </span></code></pre></td></tr></table></div></figure>


<p>接下来我们可以在qemu-system-arm中测试我们的内核了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -m 128M -kernel ./arch/arm/boot/uImage</span></code></pre></td></tr></table></div></figure>


<p>在弹出的窗口中可以内核运行到了kernel
panic状态，这是因为内核无法加载root镜像的缘故，我们将制作一个最简单的hello
world的文件系统，告知kernel运行之。</p>

<figure class='code'><figcaption><span>init.c - init.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并制作启动镜像:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ arm-none-linux-gnueabi-gcc -o init init.c -static
</span><span class='line'>$ echo init |cpio -o --format=newc &gt; initramfs
</span><span class='line'>1280 blocks
</span><span class='line'>$ file initramfs 
</span><span class='line'>initramfs: ASCII cpio archive (SVR4 with no CRC)</span></code></pre></td></tr></table></div></figure>


<p>接下来我们回到编译目录下执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ qemu-system-arm -M versatilepb -kernel ./arch/arm/boot/uImage  -initrd
</span><span class='line'>../initramfs -serial stdio -append "console=tty1"</span></code></pre></td></tr></table></div></figure>


<p>这时候可以看到，kernel运行并在Qemu自带的终端里打印出"Hello World!&ldquo;。</p>

<p>如果我们改变console变量为ttyAMA0, 将在启动qemu-system-arm的本终端上打印出qemu的输出。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/60">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/58">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/18/tips-on-setup-mesos-cluster/">Tips on Setup Mesos Cluster</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/15/linux-tips-4/">Linux Tips(4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/15/vlan-experiment/">Vlan Experiment</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/14/cloudstackshi-yong-lxcyao-dian/">CloudStack使用LXC要点</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/install-cloudstack-mgmt-server-on-centos7/">Install CloudStack Mgmt Server on CentOS7</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Dash -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dashsagittariussglory';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
