<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>后台开发读书笔记 &middot; Dash</title>

  
  <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/poole.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/hyde.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/poole-overrides.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/hyde-overrides.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/hyde-a.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/custom-additions.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/highlight/googlecode.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/8.5/styles/docco.min.css">
  <script type="text/javascript" src="//cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
  <script type="text/javascript" src="/js/html2canvas.js"></script>
  <script type='text/javascript'>
  function genPostShot() { 
          var rightNow = new Date();
          var imageName = rightNow.toISOString().slice(0,16).replace(/(-)|(:)|(T)/g,"");
          imageName += '.jpg'
          html2canvas(document.getElementsByClassName('post'), {
              background :'#FFFFFF',
              onrendered: function(canvas) {
  		
          	$('#test').attr('href', canvas.toDataURL("image/jpeg"));
          	$('#test').attr('download',imageName);
          	$('#test')[0].click();
              }
          });
  }; 
  
  </script>
  <script src="//cdn.bootcss.com/highlight.js/8.5/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://purplepalmdash.github.io/touch-icon-144-precomposed.png?ref=abc124">
  <link href="http://purplepalmdash.github.io/favicon.png?ref=abc124" rel="icon">

  
  
  
  

  <meta name="description" content="ReadingDigestsOnServerSideDevelopment">
  <meta name="keywords" content="Reading">
  
  
</head>
<body class="theme-base-0c">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <img src="http://purplepalmdash.github.io/images/mylogo.jpeg" alt="gravatar">
      <h1><a href="http://purplepalmdash.github.io/">Get busy living, or get busy dying.</a></h1>
      <a href="http://purplepalmdash.github.io/"><p>Dash</p></a>
    </div>

    <ul class="sidebar-nav">
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/">First Page</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/post/">All Posts</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/categories/linux/">Linux</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/categories/embedded/">Embedded System</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/categories/virtualization">Virtualization</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/purplepalmdash"><i class="fa fa-github-square fa-3x"></i></a>
      
      <a href="https://cn.linkedin.com/in/yang-feipeng-1b909319"><i class="fa fa-linkedin-square fa-3x"></i></a>
      <a href="https://plus.google.com/u/0/106572959364703833986"><i class="fa fa-google-plus-square fa-3x"></i></a>
      <a href="https://www.facebook.com/yang.feipeng"><i class="fa fa-facebook-square fa-3x"></i></a>
      <a href="https://twitter.com/dashwillfly"><i class="fa fa-twitter-square fa-3x"></i></a>
      
      <a href="" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>

    

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1>后台开发读书笔记</h1>
    <p align="right">
    <a href="javascript:genPostShot()">
	    TurnToJPG --> <i class="fa fa-camera-retro fa-2x"></i>
    </a>
    <a id="test"></a>
    </p>
    <hr>
    <span class="post-date">Jan 10, 2017 
    
    <br/>
    
          <a class="a_cat" href="http://purplepalmdash.github.io/categories/reading">Reading</a>
      
      

    
    </span>
      <div id="_toc" class="toc">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#第一章">第一章</a>
<ul>
<li><a href="#函数模板-函数重载">函数模板/函数重载</a></li>
<li><a href="#字符数组">字符数组</a></li>
<li><a href="#函数与指针">函数与指针</a></li>
<li><a href="#结构体-共用体-枚举">结构体/共用体/枚举</a></li>
<li><a href="#占用字节数的计算">占用字节数的计算</a></li>
<li><a href="#do-while-0-的使用">do&hellip;while(0)的使用</a></li>
<li><a href="#extern-c">extern &ldquo;C&rdquo;</a></li>
</ul></li>
<li><a href="#第二章">第二章</a>
<ul>
<li><a href="#类与结构体">类与结构体</a></li>
<li><a href="#类的封装性">类的封装性</a></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#静态数据成员">静态数据成员</a></li>
<li><a href="#对象存储空间">对象存储空间</a></li>
<li><a href="#类模板">类模板</a></li>
<li><a href="#虚函数-纯虚函数">虚函数/纯虚函数</a></li>
<li><a href="#单例模式">单例模式</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
      </div>
    

<p>从图书馆借回来不少书，其中有一本腾讯工程师写的《后台开发核心技术与应用实践》，这本书的内容很浅显易懂，
基本上涵盖了Linux下C++开发在一般公司能用到的范畴。作者也说了，她写书的初衷在于用最短的篇幅讲解实际后台
用到的核心知识点以便读者能快速进入到实际开发中。扫了扫，前两张用来复习准备面试中有关C++的内容不错。</p>

<p>想提升的就算了，这本书的代码和调试手段都比较初级，实际工作中，需要更多的借助Google和开源社区来完成。</p>

<p>这里记录的主要是本人对该书里提到的一些概念的理解.</p>

<h3 id="第一章">第一章</h3>

<h4 id="函数模板-函数重载">函数模板/函数重载</h4>

<p>1.2函数章节里，关于函数重载和函数模板的理解可以用下面的代码来解释，左边是用函数重载的情形，可以看到一个
同名函数可以有多个参数版本，而右边的函数模板则引用了模板的概念，大大节约了代码行。</p>

<pre><code>#include&lt;iostream&gt;      					#include&lt;iostream&gt;
using namespace std;    					using namespace std;
int min(int a, int b, int c){   			      |	template&lt;typename T&gt;
							      &gt;	T min(T a,T b,T c){
    if(a&gt;b)a=b; 						    if(a&gt;b)a=b;
    if(a&gt;c)a=c; 						    if(a&gt;c)a=c;
    return a;   						    return a;
}       							}
long long min(long long a,long long b, long long c){          &lt;
    if(a&gt;b)a=b; 					      &lt;
    if(a&gt;c)a=c; 					      &lt;
    return a;   					      &lt;
}       						      &lt;
double min(double a, double b){ //�������������ϵĲ�����ֻ��      &lt;
    if(a-b&gt;(1e-5))a=b;  				      &lt;
    return a;   					      &lt;
}       						      &lt;
int main(){     						int main(){
    int a=1,b=2,c=3;    				      |	   int a=1,b=2,c=3;
    cout&lt;&lt;min(a,b,c)&lt;&lt;endl;     			      |	   cout&lt;&lt;min(a,b,c)&lt;&lt;endl;
    long long a1=100,b1=200,c1=300;     		      |	   long long a1=1000000000,b1=2000000000,c1=3000000000;
    cout&lt;&lt;min(a1,b1,c1)&lt;&lt;endl;  			      |	   cout&lt;&lt;min(a1,b1,c1)&lt;&lt;endl;
    double a2=1.1,b2=2.2;       			      |	   return 0;
    cout&lt;&lt;min(a2,b2)&lt;&lt;endl;     			      &lt;
    return 0;   					      &lt;
}       							}
</code></pre>

<h4 id="字符数组">字符数组</h4>

<p>字符数组中，关于strlen()和sizeof()可以作为面试中的题目来问面试者。</p>

<h4 id="函数与指针">函数与指针</h4>

<p>函数指针的情形, 注意这里对函数的引用是直接将函数的地址赋给f.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int Mmin(int x,int y){
     if(x&lt;y)return x;
     return y;
}
int Mmax(int x,int y){
    if(x&gt;y)return x;
    return y;
}
int main(){
    int (*f)(int x,int y);
    int a=10,b=20;
    f=Mmin;   //��Mmin���������ڵ�ַ����f
    cout &lt;&lt; (*f)(a,b)&lt;&lt;endl;
    f=Mmax;  //��Mmax���������ڵ�ַ����f
    cout &lt;&lt; (*f)(a,b)&lt;&lt;endl;
    return 0;
}
</code></pre>

<h4 id="结构体-共用体-枚举">结构体/共用体/枚举</h4>

<p>共用体的定义可以回忆一下：用关键字union来定义，是一种特殊的类。在一个共用体里可以定义多种
不同的数据类型，这些数据类型共享一段内存，在不同的时间里保存不同的数据类型和长度的变量。但是，
同一时间内只能存储一种类型的数据。其存在的目的是为了节省空间。</p>

<p>判断大小端的程序有点意思:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
union TEST{
    short a;
    char b[sizeof(short)];
};
int main(){
    TEST test;
    test.a=0x0102;// �������ù�����������ֻ�����ù����������еĳ�Ա��
    if(test.b[0]==0x01&amp;&amp;test.b[1]==0x02){
        cout&lt;&lt;&quot;big endian.&quot;&lt;&lt;endl;
    }
    else if(test.b[0]==0x02&amp;&amp;test.b[1]==0x01){
        cout&lt;&lt;&quot;small endian.&quot;&lt;&lt;endl;
    }
    else{
        cout&lt;&lt;&quot;unknown&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre>

<p>枚举要注意类似于下面的题目:</p>

<pre><code>enum fruits{apple=3,orange,banana=7,bear};
结果为: 3, 4, 7, 8
</code></pre>

<h4 id="占用字节数的计算">占用字节数的计算</h4>

<p>鉴于这个题材经常在面试中被问到，单独拎出来写一段：</p>

<p>Union：</p>

<pre><code>#include&lt;iostream&gt;
using namespace std; 
union A{
   int a[5];
   char b;
   double c;
};
int main(){
   cout&lt;&lt;sizeof(A)&lt;&lt;endl;
   return 0;
}
</code></pre>

<p>最长的double(8Byte)对齐，因而占用的大小应该是<code>int(4Byte)*5=20</code>, 而8字节对齐应该是3x8=24。因而运行结果为24</p>

<p>Struct:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std; 
struct B{
  char a;
  double b;
  int c;
}test_struct_b;
int main(){
   cout&lt;&lt;sizeof(test_struct_b)&lt;&lt;endl;
   return 0;
}
</code></pre>

<p>计算方法是：</p>

<pre><code>char a , 1
补充7
double b, 8
int c, 4
补充4
</code></pre>

<p>所以结果为1+7+8+4+4=24.</p>

<p>混合结构体:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
typedef union{
    long i;
    int k[5];
    char c;
} UDATE; 
struct data{
    int cat;
    UDATE cow;
    double dog;
}too; 
UDATE temp; 
int main(){
    cout&lt;&lt;sizeof(struct data)+sizeof(temp)&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>原书有错：</p>

<p>sizeof(temp)大小为24, 因为temp是UDATA类型结构。<br />
sizeof(struct data)的计算则是结构体大小变化，每个变量需要占据各自独立的空间，依次为:</p>

<pre><code>int cat: 4
4字节填充(参照double 8字节对齐)
UPDATE cow: 24
double dog: 8
一共为: 4+4+24+8=40
</code></pre>

<p>综上所述，结果为40+24=64.</p>

<h4 id="do-while-0-的使用">do&hellip;while(0)的使用</h4>

<p>这个问题可以在面试的时候问面试者。</p>

<p>例程:</p>

<pre><code># define Foo(x) do{\
    statement one;\
    statement two;\
}while(0)
</code></pre>

<p>在宏替换时这样的写法不会破坏以下的情形:</p>

<pre><code>if(condition)
    statement one;
    statement two;
else
    //.....
</code></pre>

<p>如果去掉do&hellip;while(0)则会导致else语句孤立而出现编译错误，加了以后，则使得宏展开后，仍然保留了
原始的语义，从而保证程序的正确性。</p>

<h4 id="extern-c">extern &ldquo;C&rdquo;</h4>

<p>加这个是为了让编译器将其当成C语言处理。</p>

<pre><code>#ifdef __cpluscplus
    extern &quot;C&quot; {
#endif 
</code></pre>

<h3 id="第二章">第二章</h3>

<h4 id="类与结构体">类与结构体</h4>

<p>定义的异同:</p>

<pre><code>class CStudent{         				      |	struct SStudent{
    int num;    					      |	public:
    char name[20];      				      &lt;
    int age;           //��Щ�����ݳ�Ա��Ҳ��Ϊ��Ա����             &lt;
    void display(){   //���ǳ�Ա����      			    void display(){   //���ǳ�Ա����
        cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;				        cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;
        cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;      			        cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
        cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;				        cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;
    }   						      |	    }                  //����û�зֺ�
};      						      |	private:
CStudent cstu1,cstu2;//������2������    		      |	    int num;
							      &gt;	    char name[20];
							      &gt;	    int age;
							      &gt;	};

</code></pre>

<h4 id="类的封装性">类的封装性</h4>

<p>源代码如下:</p>

<pre><code>➜  0205 cat student.h
class CStudent{
public:
    void display();
private:
    int num;
    char name[20];
    int age;
};
➜  0205 cat main.cpp 
#include&lt;iostream&gt;
#include &quot;student.h&quot; //ע��������˫����
int main(){
    CStudent stu1;//����stu1����
    stu1.display();//ָ��stu1�����ĳ�Ա����
    return 0;
}
➜  0205 cat student.cpp 
#include&lt;iostream&gt;
#include &quot;student.h&quot; //������Ҫinclude����ͷ�ļ��������޷��ҵ�Student��
using namespace std; 
void CStudent::display(){  //����Ҫע����Student����
    cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;
    cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;
}
</code></pre>

<p>运行结果:</p>

<pre><code>num:4196688
name:
age:0
</code></pre>

<p>这样的结果是因为没有对数据成员进行初始化而导致的。</p>

<h4 id="构造函数">构造函数</h4>

<p>更改上面的代码:</p>

<pre><code>➜  0205_1 cat student.h
class CStudent{
public:
    CStudent() {
      num = 0;
      age = 0;
    }
    void display();
private:
    int num;
    char name[20];
    int age;
};
➜  0205_1 ./test 
num:0
name:
age:0
</code></pre>

<h4 id="静态数据成员">静态数据成员</h4>

<p>例子:</p>

<pre><code>➜  chapter02 cat ./0212.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    static int var;
};
int Base::var=10;
class Derived:public Base{
};
int main(){
    Base base1;
    base1.var++;//ͨ������������
    cout&lt;&lt;base1.var&lt;&lt;endl;//����11
    Base base2;
    base2.var++;
    cout&lt;&lt;base2.var&lt;&lt;endl;//����12
    Derived derived1;
    derived1.var++; 
    cout&lt;&lt;derived1.var&lt;&lt;endl;//����13
    Base::var++;//ͨ����������
    cout&lt;&lt;derived1.var&lt;&lt;endl;//����14
    return 0;
}
➜  chapter02 ./0212
11
12
13
14
</code></pre>

<h4 id="对象存储空间">对象存储空间</h4>

<p>这个和第一章的存储空间可以结合起来看。</p>

<p>空类的存储空间为1:</p>

<pre><code>➜  chapter02 cat 0214.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;//����1
    return 0;
}
➜  chapter02 ./0214
1
</code></pre>

<p>有成员变量的类的存储空间:</p>

<pre><code>➜  chapter02 cat 0215.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int length,width,height;
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0215
12
</code></pre>

<p>有静态成员变量时，静态成员变量不占据对象的内存空间:</p>

<pre><code>➜  chapter02 cat 0216.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int length,width,height;
    static int count;
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0216
12
</code></pre>

<p>成员函数不占据空间:</p>

<pre><code>➜  chapter02 cat 0217.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int foo();
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0217
1
</code></pre>

<p>构造函数与析构函数也不占据空间:</p>

<pre><code>class CBox{
public:
    CBox(){};
    ~CBox(){};
};
大小为1
</code></pre>

<p>虚析构函数，占用大小为8:</p>

<pre><code>class CBox{
public:
    CBox(){};
    virtual ~CBox(){};
};
大小为8
</code></pre>

<h4 id="类模板">类模板</h4>

<p>操作整数的类与操作浮点数的类:</p>

<pre><code>class Operation_int{    				      |	class Operation_double{
public: 							public:
    Operation_int(int a,int b):x(a),y(b){}      	      |	    Operation_double(double a, double b):x(a),y(b){}
    int add(){  					      |	    double add(){
        return x+y;     					        return x+y;
    }   							    }
    int subtract(){     				      |	    double subtract(){
        return x-y;     					        return x-y;
    }   							    }
private:							private:
    int x,y;    					      |	    double x,y;
};      							};

</code></pre>

<p>用类模板来抽象:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
template&lt;class T&gt;//����һ��ģ�壬����������ΪT
class Operation {
public:
    Operation (T a, T b):x(a),y(b){}
    T add(){
        return x+y;
    }
    T subtract(){
        return x-y;
    }
private:
    T x,y;
};
int main(){
    Operation &lt;int&gt; op_int(1,2);
    cout&lt;&lt;op_int.add()&lt;&lt;&quot; &quot;&lt;&lt;op_int.subtract()&lt;&lt;endl;//����3��-1
    Operation &lt;double&gt; op_double(1.2,2.3);
    cout&lt;&lt;op_double.add()&lt;&lt;&quot; &quot;&lt;&lt;op_double.subtract()&lt;&lt;endl;//����3.5��-1.1
    return 0;
}
➜  chapter02 ./0224
3 -1
3.5 -1.1
</code></pre>

<h4 id="虚函数-纯虚函数">虚函数/纯虚函数</h4>

<p>虚函数可以使得基类指针访问派生类中的同名函数:<br />
而纯虚函数则是因为：用基类本身生成对象不合情理，例如用动物作为基类来抽象具体的动物，而动物这个基类
本身是不能被实例化的。</p>

<p>析构函数不是虚函数时，容易引发内存泄漏:</p>

<pre><code>➜  chapter02 ./0231
Base::Base()
Derive::Derive()
Base::~Base()
➜  chapter02 cat 0231.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    Base(){ std::cout&lt;&lt;&quot;Base::Base()&quot;&lt;&lt;std::endl; }
    ~Base(){ std::cout&lt;&lt;&quot;Base::~Base()&quot;&lt;&lt;std::endl; }
};
class Derive:public Base{
public:
    Derive(){ std::cout&lt;&lt;&quot;Derive::Derive()&quot;&lt;&lt;std::endl; }
    ~Derive(){ std::cout&lt;&lt;&quot;Derive::~Derive()&quot;&lt;&lt;std::endl; }
};
int main(){
    Base* pBase = new Derive(); 
    /*����base classed������Ŀ����Ϊ������&quot;ͨ��base class�ӿڴ���derived class����&quot;*/
    delete pBase;
    return 0;
}
</code></pre>

<p>这是由C++的定义指出的：如果一个派生类对象经由一个基类指针被删除，而该基类带有一个非虚析构函数，则会导致
派生类中的成分没被销毁。</p>

<p>所以，需要把析构函数定义为虚函数。</p>

<pre><code>➜  chapter02 ./0232
Base::Base()
Derive::Derive()
Derive::~Derive()
Base::~Base()
➜  chapter02 cat 0232.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    Base(){ std::cout&lt;&lt;&quot;Base::Base()&quot;&lt;&lt;std::endl; }
    virtual ~Base(){ std::cout&lt;&lt;&quot;Base::~Base()&quot;&lt;&lt;std::endl; }
};

class Derive:public Base{
public:
    Derive(){ std::cout&lt;&lt;&quot;Derive::Derive()&quot;&lt;&lt;std::endl; }
    ~Derive(){ std::cout&lt;&lt;&quot;Derive::~Derive()&quot;&lt;&lt;std::endl; }
};

int main(){
    Base* pBase = new Derive();
    delete pBase;
    return 0;
}
</code></pre>

<h4 id="单例模式">单例模式</h4>

<p>理解：一台计算机上可以连好几台打印机，但是打印程序只能有一个，这里就可以通过单例模式来避免两个打印作业
被同时输出到打印机中。</p>

<pre><code>➜  chapter02 ./0233
s1=s2
➜  chapter02 cat 0233.cpp 
#include&lt;iostream&gt;
using namespace std;
class CSingleton{
private:
	CSingleton(){   //构造函数是私有的
	}
	static CSingleton *m_pInstance;
public:
	static CSingleton * GetInstance(){
        if(m_pInstance == NULL)  //判断是否是第一次调用
	        m_pInstance = new CSingleton();
	    return m_pInstance;
	}
};
CSingleton * CSingleton::m_pInstance=NULL;//初始化静态成员变量
int main(){
    CSingleton *s1= CSingleton::GetInstance();
    CSingleton *s2= CSingleton::GetInstance();
    if(s1==s2){
        cout&lt;&lt;&quot;s1=s2&quot;&lt;&lt;endl; 
    }
    return 0;
}
</code></pre>

<p>单例类的特点：</p>

<pre><code>1. 有指向唯一实例的静态指针m_pInstance，且为私有。   
2. 有一个公有函数用于获取唯一的实例。
3. 构造函数是私有的，不能在别处创建该类的实例.
</code></pre>

  </div>
  
</div>






<script src="http://purplepalmdash.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

