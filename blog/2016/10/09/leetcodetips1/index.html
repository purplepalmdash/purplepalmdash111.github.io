<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>LeetCodeTips1 &middot; Dash</title>

  
  <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/poole.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/hyde.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/poole-overrides.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/hyde-overrides.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/hyde-a.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/custom-additions.css?ref=abc124">
  <link rel="stylesheet" href="http://purplepalmdash.github.io/css/highlight/googlecode.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/8.5/styles/docco.min.css">
  <script type="text/javascript" src="//cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
  <script type="text/javascript" src="/js/html2canvas.js"></script>
  <script type='text/javascript'>
  function genPostShot() { 
          var rightNow = new Date();
          var imageName = rightNow.toISOString().slice(0,16).replace(/(-)|(:)|(T)/g,"");
          imageName += '.jpg'
          html2canvas(document.getElementsByClassName('post'), {
              background :'#FFFFFF',
              onrendered: function(canvas) {
  		
          	$('#test').attr('href', canvas.toDataURL("image/jpeg"));
          	$('#test').attr('download',imageName);
          	$('#test')[0].click();
              }
          });
  }; 
  
  </script>
  <script src="//cdn.bootcss.com/highlight.js/8.5/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://purplepalmdash.github.io/touch-icon-144-precomposed.png?ref=abc124">
  <link href="http://purplepalmdash.github.io/favicon.png?ref=abc124" rel="icon">

  
  
  
  

  <meta name="description" content="LeetCode Problems">
  <meta name="keywords" content="LeetCode">
  
  
</head>
<body class="theme-base-0c">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <img src="http://purplepalmdash.github.io/images/mylogo.jpeg" alt="gravatar">
      <h1><a href="http://purplepalmdash.github.io/">Get busy living, or get busy dying.</a></h1>
      <a href="http://purplepalmdash.github.io/"><p>Dash</p></a>
    </div>

    <ul class="sidebar-nav">
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/">First Page</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/post/">All Posts</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/categories/linux/">Linux</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/categories/embedded/">Embedded System</a></li>
      
      <li class="sidebar-nav-item"><a href="http://purplepalmdash.github.io/categories/virtualization">Virtualization</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/purplepalmdash"><i class="fa fa-github-square fa-3x"></i></a>
      
      <a href="https://cn.linkedin.com/in/yang-feipeng-1b909319"><i class="fa fa-linkedin-square fa-3x"></i></a>
      <a href="https://plus.google.com/u/0/106572959364703833986"><i class="fa fa-google-plus-square fa-3x"></i></a>
      <a href="https://www.facebook.com/yang.feipeng"><i class="fa fa-facebook-square fa-3x"></i></a>
      <a href="https://twitter.com/dashwillfly"><i class="fa fa-twitter-square fa-3x"></i></a>
      
      <a href="" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>

    

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1>LeetCodeTips1</h1>
    <p align="right">
    <a href="javascript:genPostShot()">
	    TurnToJPG --> <i class="fa fa-camera-retro fa-2x"></i>
    </a>
    <a id="test"></a>
    </p>
    <hr>
    <span class="post-date">Oct 9, 2016 
    
    <br/>
    
          <a class="a_cat" href="http://purplepalmdash.github.io/categories/programming">Programming</a>
      
      

    
    </span>
      <div id="_toc" class="toc">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1-two-sum">1. Two Sum</a>
<ul>
<li><a href="#c语言版">C语言版</a></li>
<li><a href="#python版">Python版</a></li>
<li><a href="#引入的bug">引入的bug</a></li>
<li><a href="#python-hash">Python Hash</a></li>
</ul></li>
<li><a href="#2-add-two-numbers">2. Add Two Numbers</a></li>
<li><a href="#longest-substr">Longest substr</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
      </div>
    

<p>又到了一年一度的跳Cao准备期间了，来刷刷LeetCode，提升一下编程技巧，准备可能的鄙视或者是
被鄙视。</p>

<h3 id="1-two-sum">1. Two Sum</h3>

<p>问题:<br />
给定一个整型数组，编写一函数，返回值为两个数组的下标，两个下标所在的数组元素相加的和为
给定的数值。例如:</p>

<pre><code>给定 nums = [2,7,11,15], targe = 9,     
因为nums[0] + nums[1] = 2 + 7 = 9,
返回的数组应为[0, 1].
</code></pre>

<h4 id="c语言版">C语言版</h4>

<p>用C语言我的解决方案如下:</p>

<pre><code class="language-c">/* Given nums = [2, 7, 11, 15], target = 9,
 *
 * Because nums[0] + nums[1] = 2 + 7 = 9,
 * return [0, 1].
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int* twoSum(int* nums, int numsSize, int target) {
	int i, j;

	for (i = 0; i &lt; numsSize; i++)
	{
		for(j = i+1; j &lt; numsSize; j++)
		{
			if(nums[i] + nums[j] == target)
			{
				// Call malloc() for return value.
				int* returnArray = malloc(2*sizeof(int));
				returnArray[0] = i;
				returnArray[1] = j;
				return returnArray;
			}
		}
	}
	// Not found, comes here.
	return NULL;
}

int main(void)
{
	int nums[4] = {2, 7, 11, 15};

	int *result = twoSum(nums, 4, 9);
	if(result != NULL)
	{
	        printf(&quot;result is %d, %d \n&quot;, result[0], result[1]);
	}

	// Call malloc in function twoSum(), so now will call free()
	if(result != NULL)
	{
	        free(result);
	}
        return 0;
}

</code></pre>

<p>心得1: malloc()/free()的调用需要在不同函数体中进行，因而可能存在内存泄漏的风险，使用
valgrind来检测可以看到，有两次请求两次释放动作，并没有内存泄漏:</p>

<pre><code>$ valgrind -v --leak-check=full ./TwoSum
......
==3283== HEAP SUMMARY:
==3283==     in use at exit: 0 bytes in 0 blocks
==3283==   total heap usage: 2 allocs, 2 frees, 1,032 bytes allocated
==3283== 
==3283== All heap blocks were freed -- no leaks are possible
==3283== 
==3283== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==3283== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>

<p>心得2: 算法复杂度为O(n^2)， 因为有嵌套的for()循环. 官方给出的有通过哈希来做的，在C语言
中内建数据类型并不包括map，因而在后面用python来实现。</p>

<p>心得3: 对函数的返回值需要检测，如free()掉一个NULL的地址。StackOverFlow上关于free(NULL)
的讨论如下：<br />
<a href="http://stackoverflow.com/questions/1938735/does-freeptr-where-ptr-is-null-corrupt-memory">http://stackoverflow.com/questions/1938735/does-freeptr-where-ptr-is-null-corrupt-memory</a></p>

<p>看起来也不会有什么严重的后果。</p>

<h4 id="python版">Python版</h4>

<p>自己写的Python版本实现如下:</p>

<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        returnvalue = []
        for num in nums:
            for left in nums[nums.index(num)+1:]:
                if (num + left == target):
                    returnvalue.append(nums.index(num))
                    returnvalue.append(nums.index(left))
        return returnvalue

print (Solution().twoSum([5, 4, 11, 17], 9))
</code></pre>

<p>心得1: 类(class)的用法.<br />
心得2: 数组的一点点小小的使用。</p>

<p>基本逻辑和C语言实现的差不多，算法复杂度也一样。</p>

<h4 id="引入的bug">引入的bug</h4>

<p>设置的test case中，我们的代码在遇到[0,4,3,0]这样的输入时，会报错。原因在于nums.index(0)
总是返回第一个0所在的下标(0)，而不是第二个0所在的下标(3)，修改后的代码如下:</p>

<pre><code>class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        returnvalue = []
        index = 0
        for num in nums:
            index += 1
            for left in nums[index:]:
                if (num + left == target):
                    returnvalue.append(nums.index(num))
                    returnvalue.append(nums[index:].index(left)+index)
        return returnvalue

print (Solution().twoSum([0,4,3,0], 0))
</code></pre>

<p>运行后的结果，不是那么理想，只击败了34%左右的提交结果:</p>

<p><img src="/images/2016_10_10_16_34_33_1195x858.jpg" alt="/images/2016_10_10_16_34_33_1195x858.jpg" /></p>

<h4 id="python-hash">Python Hash</h4>

<p>经过几番修改以后的代码如下，只循环一次，因而算法复杂度为O(n):</p>

<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        # Use a dictionary for holding nums
        num_dic = {}
        for i in range(len(nums)):
            if target - nums[i] in num_dic.keys():
                return [num_dic[target - nums[i]],i]
            else:
                # directly put it into the num_dic
                num_dic[nums[i]] = i
        return []

print (Solution().twoSum([0,4,3,0], 0))
print (Solution().twoSum([3, 4, 2], 6))
</code></pre>

<p>速度稍微提升了一些:</p>

<p><img src="/images/2016_10_10_20_05_31_508x380.jpg" alt="/images/2016_10_10_20_05_31_508x380.jpg" /></p>

<p>更好的方案，优化:</p>

<pre><code>class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        # Use a dictionary for holding nums
        num_dic = {}
        for i,v in enumerate(nums):
            if v in num_dic.keys():
                return [num_dic[v],i]
            num_dic[target-v] = i

print (Solution().twoSum([0,4,3,0], 0))
print (Solution().twoSum([3, 4, 2], 6))
</code></pre>

<p>这个代码大概能跑到击败80%左右的提交答案。</p>

<p>思考1： enumerate()函数调用减少了时间。<br />
思考2： 原代码中有两次减法，而修改后的代码中，只是在写入hash的时候，有一次target-v的减法操作。<br />
思考3： 去掉了一次不必要的return操作。</p>

<p>总结：<br />
Python里对于这个问题的优化大概就到这里了。可以看到，简单的问题也是需要认真思考了，认认真真的来
做leetcode吧。</p>

<h3 id="2-add-two-numbers">2. Add Two Numbers</h3>

<p>题目说明:</p>

<pre><code>给定两个用链表表示的非负数。数字存储是reverse order， 每个节点存有一个数字。将节点上的数字
相加，以得到一个新的链表
Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre>

<p>Oct10晚上的测试框架写成这样：</p>

<pre><code class="language-c">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


// Definition of the ListNode
struct ListNode {
    int val;
    struct ListNode *next;
};

// create_list()
struct ListNode* create_list(int val)
{
	printf(&quot;\n Creating list with headnode as [%d]\n&quot;, val);
	struct ListNode *ptr = (struct ListNode*)malloc(sizeof(struct ListNode));
	if(NULL == ptr)
	{
		printf(&quot;\n Node creation failed \n&quot;);
		return NULL;
	}
	ptr-&gt;val = val;
	ptr-&gt;next = NULL;

	return ptr;
}

// print the list
void print_list(struct ListNode* head)
{
	struct ListNode*  current = head;

	while(current != NULL)
	{
		printf(&quot;%d -&gt;&quot;, current-&gt;val);
		current = current-&gt;next;
	}
	printf(&quot;NULL\n&quot;);
}

int shiftnumber = 0;

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
	printf(&quot;\nJust Called this function!\n&quot;);
	
	struct ListNode* currentl1 = l1;
	struct ListNode* currentl2 = l2;
	// Holding the return value
	struct ListNode* ptr = (struct ListNode*)malloc(sizeof(struct ListNode));
	struct ListNode* head = ptr;
	ptr-&gt;next = NULL;
	shiftnumber = 0;


	// First calculate the longest Linked List
	int lenl1 = 0;
	int lenl2 = 0;

	while(currentl1 != NULL)
	{
		lenl1++;
		currentl1 = currentl1-&gt;next;
	}
	while(currentl2 != NULL)
	{
		lenl2++;
		currentl2 = currentl2-&gt;next;
	}
	printf(&quot;len1 is %d, len2 is %d\n&quot;, lenl1, lenl2);

	currentl1 = l1;
	currentl2 = l2;

	// Get the largest length, thus we could do some tricks. 
	//
	//
	//
	//
	//
	while((currentl1 != NULL) &amp;&amp; (currentl2 != NULL))
	{
		ptr-&gt;val = (currentl1-&gt;val + currentl2-&gt;val)%10+shiftnumber;
		shiftnumber = 0;
		if((currentl1-&gt;val + currentl2-&gt;val)&gt;=10)
		{
		    shiftnumber = (currentl1-&gt;val + currentl2-&gt;val)/10;
		}
		//ptr-&gt;val = (currentl1-&gt;val + currentl2-&gt;val)%10;
		if(currentl1-&gt;next != NULL)
		{
		    ptr-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
		    ptr-&gt;next-&gt;next = NULL;
		    ptr = ptr-&gt;next;
		}
		// shiftnumber exists, so you should assign shiftnumber to the
		// newnode
		else
		{
			// Only check shiftnumber
			if(shiftnumber != 0)
			{
		          ptr-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
		          ptr-&gt;next-&gt;next = NULL;
			  ptr-&gt;next-&gt;val = shiftnumber;
			}

		}
		currentl1 = currentl1-&gt;next;
		currentl2 = currentl2-&gt;next;
	}
	return head;
}



int main(void)
{
	struct ListNode test1, test1_2, test1_3;
	struct ListNode* p = &amp;test1;
	p-&gt;val = 2;
	p-&gt;next = &amp;test1_2;
	p-&gt;next-&gt;val = 4;
	p-&gt;next-&gt;next = &amp;test1_3;
	p-&gt;next-&gt;next-&gt;val = 4;
	p-&gt;next-&gt;next-&gt;next = NULL;
	printf(&quot;### List l1!\n&quot;);
	print_list(p);
	
	struct ListNode test2, test2_2, test2_3;
	struct ListNode* q = &amp;test2;
	q-&gt;val = 5;
	q-&gt;next = &amp;test2_2;
	q-&gt;next-&gt;val = 6;
	q-&gt;next-&gt;next = &amp;test2_3;
	q-&gt;next-&gt;next-&gt;val = 7;
	q-&gt;next-&gt;next-&gt;next = NULL;
	printf(&quot;### List l2!\n&quot;);
	print_list(q);

	printf(&quot;\n *** Start testing addTwoNumbers! *** \n&quot;);
	struct ListNode* r = addTwoNumbers(p, q);
	print_list(r);
	// Remember to free memory here
	//while(r-&gt;next != NULL);
	//{
	//	printf(&quot;See if you could get the money?\n&quot;);
	//	r = r-&gt;next;
	//}

	printf(&quot;\n *** Finished testing addTwoNumbers! *** \n&quot;);

	return 0;
}
</code></pre>

<p>一塌糊涂啊！！！明天继续写。</p>

<p>最后独立写出的答案如下，非常难看。</p>

<pre><code class="language-c">int shiftnumber = 0;

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
	struct ListNode* currentl1 = l1;
	struct ListNode* currentl2 = l2;
	// Holding the return value
	struct ListNode* ptr = (struct ListNode*)malloc(sizeof(struct ListNode));
	struct ListNode* head = ptr;
	ptr-&gt;next = NULL;
	shiftnumber = 0;


	// First calculate the longest Linked List
	int lenl1 = 0;
	int lenl2 = 0;

	while(currentl1 != NULL)
	{
		lenl1++;
		currentl1 = currentl1-&gt;next;
	}
	while(currentl2 != NULL)
	{
		lenl2++;
		currentl2 = currentl2-&gt;next;
	}

	currentl1 = l1;
	currentl2 = l2;

	// Get the largest length, thus we could use this number for controlling the
	// return value. 
	int LinkedListLen = lenl1&gt;lenl2?lenl1:lenl2;
	while(LinkedListLen &gt; 0)
	{
		LinkedListLen--;
		int ValOfL1, ValOfL2 = 0;
		ValOfL1 = (currentl1 == NULL)?0:currentl1-&gt;val;
		ValOfL2 = (currentl2 == NULL)?0:currentl2-&gt;val;
		ptr-&gt;val = ((ValOfL1 + ValOfL2)%10 + shiftnumber)%10;
		if(((ValOfL1 + ValOfL2)%10 + shiftnumber) == 10)
		{
		    shiftnumber = 1;
		}
		else{
		shiftnumber = 0;
		    if((ValOfL1 + ValOfL2)&gt;=10)
		    {
		        shiftnumber = (ValOfL1 + ValOfL2)/10;
		    }
		}
		// Allocate memory for new node. Only allocate (LinkedListLen - 1) times
		if(LinkedListLen &gt; 0)
		{
		    ptr-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
		    ptr-&gt;next-&gt;next = NULL;
		    ptr = ptr-&gt;next;
		}
		// Switch to next node.
		if(currentl1 != NULL)
		{
		    currentl1 = currentl1-&gt;next;
		}
		if(currentl2 != NULL)
		{
		    currentl2 = currentl2-&gt;next;
		}
	}
	// If shiftnumber &gt; 0, allocate a new node for holding it
	if(shiftnumber != 0)
	{
		ptr-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
		ptr-&gt;next-&gt;next = NULL;
		ptr-&gt;next-&gt;val = shiftnumber;
	}
	
	return head;
}
</code></pre>

<p>我的思路:</p>

<p>1，考虑到两个输入的链表长度可能不一样，因而先得到最长的链表长度，用这个最长的长度来做递归。<br />
2, 是否有进位通过一个全局表两shiftnumber来hold. 如果相加到最后依然有进位，则在循环外开辟一块空间来存放这个进位。<br />
3, 两个链表中的任何一个一旦走到了NULL指针，则其值用0来代替。<br />
4, 三目运算符的使用。<br />
5, <code>ptr-&gt;val = ((ValOfL1 + ValOfL2)%10 + shiftnumber)%10;</code>，这个是考虑到test case:</p>

<pre><code>[9]
[1, 9]
</code></pre>

<p>如果不做的话，则得出结果会是[0,10], 进位和该位数字的和为10的时候需要单独考虑。</p>

<p>反思:<br />
1, 对指针的使用要非常小心。<br />
2, 就是凭直觉写出来的，算法很差, 代码可读性也很差。</p>

<h3 id="longest-substr">Longest substr</h3>

<p>The sample code is listed, while to be optimized:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAXN 50000

// q should be longer than p
int comlen(char* p, char* q)
{
    int i = 0;
    while (*q &amp;&amp; (*p++ == *q++))
    {
        i++;
    }
    return i;
}

int cstring_cmp(const void *a, const void *b)
{
    const char **ia = (const char **)a;
    const char **ib = (const char **)b;
    return strcmp(*ia, *ib);
}


int lengthOfLongestSubstring(char* s) {
      char c[MAXN];
      char* a[MAXN];
     

      // Create a new array which hold char *s
      // Remove all of the duplicated items in array
      // no_duplicated[]
 
      char ch;
      int n = 0;
      for(n = 0; n &lt; strlen(s); n++)
      {
          printf(&quot;%c &quot;,s[n]);
          a[n] = &amp;c[n];
          c[n] = s[n];
      }
      a[n] = 0;

      qsort(a, n, sizeof(char*), cstring_cmp);

      int maxlen = 0;
      int len = 0;
      int maxi = 0;
      for (int i = 0; i &lt; n - 1; i++)
      {
          len = comlen(a[i], a[i + 1]);
	  printf(&quot;len is %d\n&quot;, len);
          if (len &gt; maxlen)
          {
              maxlen = len;
              maxi = i;
          }
      }

      printf(&quot;maxlen:%d\tmax string:\t&quot;, maxlen);
      char ch_tmp;
      for (int i = 0; i &lt; maxlen; i++)
      {
          ch_tmp = *(a[maxi] + i);
          printf(&quot;%c&quot;, ch_tmp);
      }
      printf(&quot;\n&quot;);

      return maxlen;
}

int main(void)
{
	char s[100] = &quot;abcabcccc&quot;;
	char t[100] = &quot;bbbbbbbbbbbb&quot;;
	char k[100] = &quot;pwwkew&quot;;
	lengthOfLongestSubstring(s);
	lengthOfLongestSubstring(t);
	lengthOfLongestSubstring(k);
	return 0;
}

</code></pre>

  </div>
  
</div>






<script src="http://purplepalmdash.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

