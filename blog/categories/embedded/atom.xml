<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Embedded | Dash]]></title>
  <link href="http://purplepalmdash.github.io/blog/categories/embedded/atom.xml" rel="self"/>
  <link href="http://purplepalmdash.github.io/"/>
  <updated>2016-03-27T13:32:52+08:00</updated>
  <id>http://purplepalmdash.github.io/</id>
  <author>
    <name><![CDATA[Dash]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tips on NodeMCU]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/27/tips-on-nodemcu/"/>
    <updated>2016-03-27T09:30:05+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/27/tips-on-nodemcu</id>
    <content type="html"><![CDATA[<h3>电路图</h3>

<p>在淘宝上买的NodeMCU是v1.0版的, v0.9版和v1.0版的差别如下:</p>

<p><img src="/images/2016_03_27_09_41_53_653x244.jpg" alt="/images/2016_03_27_09_41_53_653x244.jpg" /></p>

<p>1.0版的连线如图:</p>

<p><img src="/images/NodeMCU__v1.0_pinout.jpg" alt="/images/NodeMCU__v1.0_pinout.jpg" /></p>

<h3>烧写固件</h3>

<p>ArchLinux下,可以通过python程序直接烧写固件.</p>

<p>下载integer版本的固件,</p>

<pre><code>$ wget https://github.com/nodemcu/nodemcu-firmware/releases/download/0.9.6-dev_20150704/nodemcu_integer_0.9.6-dev_20150704.bin:w
</code></pre>

<p>下载esp-tool, ArchLinux需要安装python2版本的pyserial库才能运行该软件:</p>

<pre><code>$ git clone https://github.com/themadinventor/esptool.git
$ sudo pacman -S python2-pyserial
$ sudo python2 ./esptool.py --port /dev/ttyUSB0 --write_flash 0x0000 ../nodemcu_integer_0.9.6-dev_20150704.bin
</code></pre>

<h3>Minicom串口</h3>

<p>Minicom串口配置如下:</p>

<p><img src="/images/2016_03_27_10_09_12_746x325.jpg" alt="/images/2016_03_27_10_09_12_746x325.jpg" /></p>

<p>烧写完固件后,最简单的测试如下:</p>

<pre><code>&gt; print "Hello World"
Hello World
</code></pre>

<p>同时我们可以看下NodeMCU的版本,命令如下:</p>

<pre><code>&gt; majorVer, minorVer, devVer, chipid, flashid, flashsize, flashmode, flashspeed = node.info();
&gt; print("NodeMCU "..majorVer.."."..minorVer.."."..devVer)
NodeMCU 0.9.6
</code></pre>

<p>可以看到我们使用的固件版本是0.9.6的.</p>

<h3>闪烁LED</h3>

<p>NodeMCU支持LUA编程,为此我们需要准备另一个写入LUA脚本的小程序:</p>

<pre><code>$ git clone https://github.com/4refr0nt/luatool.git
</code></pre>

<p>NodeMCU板上自带有两个LED, 我们先点亮D4口,即GPIO2口上的LED:</p>

<p>程序照搬
<a href="http://esp8266.co.uk/recipes/blink-demo/">http://esp8266.co.uk/recipes/blink-demo/</a></p>

<pre><code class="lua">-- Config
local pin = 4            --&gt; GPIO2
local value = gpio.LOW
local duration = 1000    --&gt; 1 second


-- Function toggles LED state
function toggleLED ()
    if value == gpio.LOW then
        value = gpio.HIGH
    else
        value = gpio.LOW
    end

    gpio.write(pin, value)
end


-- Initialise the pin
gpio.mode(pin, gpio.OUTPUT)
gpio.write(pin, value)


-- Create an interval
tmr.alarm(0, duration, 1, toggleLED)
</code></pre>

<p>烧写到板子上:</p>

<pre><code>$ sudo python2 luatool/luatool/luatool.py --port /dev/ttyUSB0 --src blinkLED/init.lua --dest init.lua --restart
</code></pre>

<p>把<code>pin = 4</code>改为<code>pin = 0</code>, 则可以点亮另一个LED.</p>

<h3>WIFI控制LED</h3>

<p>注意,需要把init.lua文件里的第二行改为你自家的WIFI SSID和密码:</p>

<pre><code>$ mkdir webLED
$ vim webLED/init.lua
wifi.setmode(wifi.STATION)
wifi.sta.config("SSID","PASSWORD")
print(wifi.sta.getip())
led1 = 0
led2 = 4
gpio.mode(led1, gpio.OUTPUT)
gpio.mode(led2, gpio.OUTPUT)
srv=net.createServer(net.TCP)
srv:listen(80,function(conn)
    conn:on("receive", function(client,request)
        local buf = "";
        local _, _, method, path, vars = string.find(request, "([A-Z]+) (.+)?(.+) HTTP");
        if(method == nil)then
            _, _, method, path = string.find(request, "([A-Z]+) (.+) HTTP");
        end
        local _GET = {}
        if (vars ~= nil)then
            for k, v in string.gmatch(vars, "(%w+)=(%w+)&amp;*") do
                _GET[k] = v
            end
        end
        buf = buf.."&lt;h1&gt; ESP8266 Web Server&lt;/h1&gt;";
        buf = buf.."&lt;p&gt;GPIO0 &lt;a href=\"?pin=ON1\"&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=\"?pin=OFF1\"&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;";
        buf = buf.."&lt;p&gt;GPIO2 &lt;a href=\"?pin=ON2\"&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=\"?pin=OFF2\"&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;";
        local _on,_off = "",""
        if(_GET.pin == "OFF1")then
            gpio.write(led1, gpio.HIGH);
        elseif(_GET.pin == "ON1")then
            gpio.write(led1, gpio.LOW);
        elseif(_GET.pin == "OFF2")then
            gpio.write(led2, gpio.HIGH);
        elseif(_GET.pin == "ON2")then
            gpio.write(led2, gpio.LOW);
        end
        client:send(buf);
        client:close();
        collectgarbage();
    end)
end)
$ sudo python2 luatool/luatool/luatool.py --port /dev/ttyUSB0 --src webLED/init.lua --dest init.lua --restartkk
</code></pre>

<p>串口上可以得到ESP板的IP地址:</p>

<pre><code>&gt; print(wifi.sta.getip())
192.168.177.6   255.255.255.0   192.168.177.1
</code></pre>

<p>现在可以通过访问主机的页面<code>http://192.168.177.6</code>来设置LED了.</p>

<p><img src="/images/2016_03_27_10_52_37_430x215.jpg" alt="/images/2016_03_27_10_52_37_430x215.jpg" /></p>

<h3>Arduino版LED</h3>

<p>Arduino默认是不支持ESP的,需要安装插件来支持.  <br/>
File -> Preferences -> Settings中, 如下图所示, 填json定义网址  <br/>
<a href="http://arduino.esp8266.com/stable/package_esp8266com_index.json">http://arduino.esp8266.com/stable/package_esp8266com_index.json</a></p>

<p><img src="/images/2016_03_27_13_25_19_905x639.jpg" alt="/images/2016_03_27_13_25_19_905x639.jpg" /></p>

<p>而后打开Tools -> Boards -> Board Manager, 自动刷新后, 安装ESP8266相关的库:</p>

<p><img src="/images/2016_03_27_13_28_14_784x425.jpg" alt="/images/2016_03_27_13_28_14_784x425.jpg" /></p>

<p>安装完毕后就可以使用ESP对应的Board了.</p>

<p>这里的代码实现了LED的闪烁, 源代码如下:</p>

<pre><code>/*LED_Breathing.ino Arduining.com  20 AUG 2015
Using NodeMCU Development Kit V1.0
Going beyond Blink sketch to see the blue LED breathing.
A PWM modulation is made in software because GPIO16 can't
be used with analogWrite().
*/

#define LED     D0        // Led in NodeMCU at pin GPIO16 (D0).

#define BRIGHT    350     //max led intensity (1-500)
#define INHALE    1250    //Inhalation time in milliseconds.
#define PULSE     INHALE*1000/BRIGHT
#define REST      1000    //Rest Between Inhalations.

//----- Setup function. ------------------------
void setup() {                
  pinMode(LED, OUTPUT);   // LED pin as output.    
}

//----- Loop routine. --------------------------
void loop() {
  //ramp increasing intensity, Inhalation: 
  for (int i=1;i&lt;BRIGHT;i++){
    digitalWrite(LED, LOW);          // turn the LED on.
    delayMicroseconds(i*10);         // wait
    digitalWrite(LED, HIGH);         // turn the LED off.
    delayMicroseconds(PULSE-i*10);   // wait
    delay(0);                        //to prevent watchdog firing.
  }
  //ramp decreasing intensity, Exhalation (half time):
  for (int i=BRIGHT-1;i&gt;0;i--){
    digitalWrite(LED, LOW);          // turn the LED on.
    delayMicroseconds(i*10);          // wait
    digitalWrite(LED, HIGH);         // turn the LED off.
    delayMicroseconds(PULSE-i*10);  // wait
    i--;
    delay(0);                        //to prevent watchdog firing.
  }
  delay(REST);                       //take a rest...
}
</code></pre>

<p>直接在Arduino IDE中编译验证即可.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on 5050RGB(2)]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/17/tips-on-5050rgb-2/"/>
    <updated>2016-03-17T13:09:12+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/17/tips-on-5050rgb-2</id>
    <content type="html"><![CDATA[<p>上次的5050RGB模块损坏后, 我又从淘宝买了一块. 价格不贵,4块钱不到. 卖家的资料上
这么写着:</p>

<p><img src="/images/2016_03_17_13_08_03_532x306.jpg" alt="/images/2016_03_17_13_08_03_532x306.jpg" /></p>

<p>瞅着还挺OK的,不就是Arduino板5V电压外接,然后用三个GPIO口来控制嘛. 接线完毕后发
现怎么也点不亮.</p>

<p>于是用万用表Debug, 发现公共端应该是接GND, 三个控制端需要电平置为高才可以点亮对
应的颜色.</p>

<p>于是正确的连线和示例代码如下:</p>

<pre><code class="C">// V-VCC GND   R-9   B-10  G-11
#define LEDR 9
#define LEDB 10
#define LEDG 11

void clear()
{
  analogWrite(LEDR,0);
  analogWrite(LEDB,0);
  analogWrite(LEDG,0);  //off
}


void setup()
{
  pinMode(LEDG,OUTPUT);
  pinMode(LEDB,OUTPUT);
  pinMode(LEDR,OUTPUT);
}

void loop()
{
  clear();
  // Red
  analogWrite(LEDR,255);
  delay(1000);
  clear();
  // Green
  analogWrite(LEDG,255);
  delay(1000);
  clear();
  // Blue
  analogWrite(LEDB,255);
  delay(1000);
  // White
  analogWrite(LEDB,255);
  analogWrite(LEDG,255);
  analogWrite(LEDR,255);
  delay(2000);
}
</code></pre>

<p>编译并上传代码到Arduino板子上, LED将呈现成红色->绿色->蓝色->白色的渐变.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on 5050RGB]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/12/tips-on-5050rgb/"/>
    <updated>2016-03-12T19:32:42+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/12/tips-on-5050rgb</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>淘宝上买的5050RGB模块, 外观如下图:</p>

<p><img src="/images/2016_03_12_19_36_05_351x233.jpg" alt="/images/2016_03_12_19_36_05_351x233.jpg" /></p>

<p>连线:</p>

<p>这个RGB模块比较奇怪,直接使用Arduino的5v输出一直有问题,我是用的外接5V电源供电,
动用了面包板模块.(之后发现不是供电的问题, 是因为淘宝上卖的模块提供示例代码的问
题)</p>

<p>更具体的连线如下:</p>

<pre><code>// V-VCC 5V   R-9   B-10  G-11
#define LEDR 9
#define LEDB 10
#define LEDG 11
</code></pre>

<h3>测试</h3>

<p>按照厂方提供的程序,未能成功运行.</p>

<p>厂方提供的电路图如下:</p>

<p><img src="/images/2016_03_12_20_31_25_373x471.jpg" alt="/images/2016_03_12_20_31_25_373x471.jpg" /></p>

<h3>Debug</h3>

<p>百思不得其解后,用万用表测试, 电阻发声的那档, 发现加电后,某两个LED可以亮, 另外
一个不能亮.</p>

<p>发现奇怪的一点是, VCC接高电压, RGB接低电压时, 无法点亮LED. RGB接高电压, VCC接
低电压时, LED可以被点亮两个.</p>

<p>猜测: 厂方给的参考资料有误, 接线错误. 而且LED坏了一个.</p>

<p>验证, 正确.</p>

<p>连线更改为:</p>

<pre><code>// V-VCC 5V   R-9   B-10  G-11
#define LEDR 9
#define LEDG 10
</code></pre>

<p>蓝色的LED已坏, 所以示例代码中,不许配置LEDB.</p>

<pre><code>// V-VCC GND   R-9   G-10  
#define LEDR 9
#define LEDG 10

int i = 0;

void setup()
{
  pinMode(LEDG,OUTPUT);
  pinMode(LEDR,OUTPUT);

}

void loop()
{
  analogWrite(LEDR,0);
  analogWrite(LEDG,0);  //off
  delay(1000);
  analogWrite(LEDR,255); 
delay(1000); 
  analogWrite(LEDR,0);
  analogWrite(LEDG,0);
  delay(1000); 
  analogWrite(LEDR,30);
  analogWrite(LEDG,200);
delay(1000); 
  analogWrite(LEDR,0);
  analogWrite(LEDG,0);
  delay(1000); 
    analogWrite(LEDG,30);
  analogWrite(LEDR,200);
  delay(1000); 
}
</code></pre>

<p>正确的电路连线应该是:</p>

<p><img src="/images/2016_03_12_20_54_55_707x379.jpg" alt="/images/2016_03_12_20_54_55_707x379.jpg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on W5100]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/11/tips-on-w5100/"/>
    <updated>2016-03-11T22:00:50+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/11/tips-on-w5100</id>
    <content type="html"><![CDATA[<h3>参考</h3>

<p>参考如下:</p>

<p><a href="http://www.bigiot.net/help/6.html">http://www.bigiot.net/help/6.html</a></p>

<h3>问题</h3>

<p>上报的数据不准确.</p>

<p>原因是因为W5100抄版的淘宝版本有短路, 换成别的模拟口:</p>

<pre><code>const int LM35 = 3;//LM35 pin
byte mac[] = {0x00, 0x1D, 0x72, 0x82, 0x35, 0x9D};
EthernetClient client ;
IPAddress ip(192, 168, 17, 177);//local IP
//IPAddress server(121,42,180,30);
char server[] = "www.bigiot.net"; 
</code></pre>

<p>连线改为了3, 即A3口以后,上报数据成功.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on V-USB and Arduino(5)]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/07/tips-on-v-usb-and-arduino-5/"/>
    <updated>2016-03-07T21:52:47+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/07/tips-on-v-usb-and-arduino-5</id>
    <content type="html"><![CDATA[<p>这一节将添加一个LED到已有的方案中. 这个LED将使用11口, 通过<code>./set-led new</code>来设
置状态.</p>

<h3>连线</h3>

<p>新加一个LED如图:</p>

<p><img src="/images/2016_03_07_21_52_18_683x513.jpg" alt="/images/2016_03_07_21_52_18_683x513.jpg" /></p>

<p>仅仅添加了一个LED + 220欧电阻.</p>

<h3>代码修改</h3>

<h4>requests.h</h4>

<p>添加新的request定义:</p>

<pre><code class="diff">diff --git a/requests.h b/requests.h
index 90275f5..b354a73 100644
--- a/requests.h
+++ b/requests.h
@@ -32,4 +32,6 @@

 #define CUSTOM_RQ_BLINK    3

+#define CUSTOM_RQ_NEWLED    4
+
</code></pre>

<h4>hid_custom_rq.h</h4>

<p>添加新的管脚, 和对<code>CUSTOM_RQ_NEWLED</code>的处理代码:</p>

<pre><code class="diff">diff --git a/hid_custom_rq.h b/hid_custom_rq.h
index f5509e4..b5411cf 100644
--- a/hid_custom_rq.h
+++ b/hid_custom_rq.h
@@ -13,6 +13,7 @@ class hid_custom_rqDevice {
   hid_custom_rqDevice () {
     usbInit();
     ledPin = 13;        // pin 13 as default ledPin
+    newledPin = 11;    // pin 11 as newledPin
   }

   void poll() {
@@ -20,6 +21,7 @@ class hid_custom_rqDevice {
   }

   unsigned int ledPin;  
+  unsigned int newledPin;  
 };

 hid_custom_rqDevice hid_custom_rq = hid_custom_rqDevice();
@@ -99,6 +101,14 @@ usbMsgLen_t usbFunctionSetup(uchar data[8])
             usbMsgPtr = dataBuffer;         /* tell the driver which data to
return */
             return 1;                       /* tell the driver to send 1 byte
*/
         }
+       /* Added for newly added LED */
+       else if(rq-&gt;bRequest == CUSTOM_RQ_NEWLED){
+            if(rq-&gt;wValue.bytes[0] &amp; 1){    /* set new LED */
+                digitalWrite(hid_custom_rq.newledPin, HIGH);
+            }else{                          /* clear new LED */
+                digitalWrite(hid_custom_rq.newledPin, LOW);
+            }
+       }
     }
</code></pre>

<h4>set-led.c</h4>

<p>这个文件中,添加了两条新命令,分别为<code>./set-led newledon</code>和<code>./set-led newledoff</code>用于点亮/
熄灭新加的LED.</p>

<pre><code>diff --git a/examples/hid_custom_rq_demo/commandline/set-led.c b/examples/hid_custom_rq_demo/commandline/set-led.c
index 44d39f9..a306eca 100644
--- a/examples/hid_custom_rq_demo/commandline/set-led.c
+++ b/examples/hid_custom_rq_demo/commandline/set-led.c
@@ -91,12 +91,19 @@ buffer[3] = 0;
         }else{
             printf("LED is %s\n", buffer[0] ? "on" : "off");
         }
-    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+    }
+    else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
         cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
         if(cnt &lt; 0){
             fprintf(stderr, "USB error: %s\n", usb_strerror());
         }
     }
+    else if((isOn = (strcasecmp(argv[1], "newledon") == 0)) || strcasecmp(argv[1], "newledoff") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_NEWLED, isOn, 0, buffer, 0, 5000);
+        if(cnt &lt; 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+    }

 else if(strcasecmp(argv[1], "onoff") == 0){ /* Test custom on/off */
</code></pre>

<h4>hid_custom_rq_demo.ped</h4>

<p>因为新添加了硬件,ped文件同样需要更新.</p>

<pre><code>diff --git a/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde b/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde
index 77e3912..6d98151 100644
--- a/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde
+++ b/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde
@@ -1,10 +1,13 @@
 #include &lt;hid_custom_rq.h&gt;

 const int ledPin = 13;
+const int newledPin = 11;

 void setup() {
   hid_custom_rq.ledPin = ledPin;
   pinMode(hid_custom_rq.ledPin, OUTPUT);
+  hid_custom_rq.newledPin = newledPin;
+  pinMode(hid_custom_rq.newledPin, OUTPUT);
 }

 void loop() {
</code></pre>

<h3>验证</h3>

<p>写入新编译的Arduino固件, 并新编译<code>set-led</code>程序, 即可看到新增的LED被点亮/熄灭.</p>

<p>效果如图:</p>

<p><img src="/images/70584386.jpg" alt="/images/70584386.jpg" /></p>

<h3>延伸</h3>

<p>既然点亮了LED, 其他各种设备就不在话下了. 引入一个舵机,或者步进电机, 就可以实现
e-buddy人偶的提醒功能.</p>

<p>当然我们可以想得更妙, 例如,用蓝牙或者WIFI来替代USB传输. 这样可以做到更远距离.</p>
]]></content>
  </entry>
  
</feed>
