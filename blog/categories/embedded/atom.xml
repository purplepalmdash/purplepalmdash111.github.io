<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Embedded | Dash]]></title>
  <link href="http://purplepalmdash.github.io/blog/categories/embedded/atom.xml" rel="self"/>
  <link href="http://purplepalmdash.github.io/"/>
  <updated>2015-05-22T10:00:20+08:00</updated>
  <id>http://purplepalmdash.github.io/</id>
  <author>
    <name><![CDATA[Dash]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Modification SWAP on RPI Installation]]></title>
    <link href="http://purplepalmdash.github.io/blog/2015/04/30/modification-on-rpi-installation/"/>
    <updated>2015-04-30T21:49:00+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2015/04/30/modification-on-rpi-installation</id>
    <content type="html"><![CDATA[<p>First disable the swap partition, for it will save your sd card:  <br/>
Know where is your swap file:</p>

<pre><code>$ cat /proc/swap*
</code></pre>

<p>Disable it via change the S to K under <code>/etc/rcx.d</code>, and reboot the services:</p>

<pre><code>$ sudo mv S02dphys-swapfile K02dphys-swapfile
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable Bluetooth Playing]]></title>
    <link href="http://purplepalmdash.github.io/blog/2015/03/08/enable-bluetooth-playing/"/>
    <updated>2015-03-08T21:36:00+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2015/03/08/enable-bluetooth-playing</id>
    <content type="html"><![CDATA[<p>First scan the bluetooth adapter via <code>lsusb</code>:</p>

<pre><code>$ lsusb
Bus 005 Device 002: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)
</code></pre>

<p>Install packages and configure bluetooth:</p>

<pre><code>$ sudo apt-get install bluetooth
$ sudo apt-get install bluez-utils
$ sudo apt-get install blueman
</code></pre>

<p>Then setup the bluetooth headset in blueman&rsquo;s graphical interface.  <br/>
The more detailed steps are available at:  <br/>
<a href="http://kkkttt.github.io/blog/2013/12/19/bluetooth-headset-on-archlinux/">http://kkkttt.github.io/blog/2013/12/19/bluetooth-headset-on-archlinux/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrade OpenWRT on MW151RM3G]]></title>
    <link href="http://purplepalmdash.github.io/blog/2014/11/24/upgrade-openwrt-on-mw151rm3g/"/>
    <updated>2014-11-24T13:54:00+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2014/11/24/upgrade-openwrt-on-mw151rm3g</id>
    <content type="html"><![CDATA[<h3>Prepare</h3>

<p>First go to <a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/">http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/</a>, find the &ldquo;wr703n&rdquo;, download the 2 files.</p>

<pre><code>$ ls -l openwrt*
-rw-r----- 1 Trusty root 3932160 Nov 24 13:50 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin
-rw-r----- 1 Trusty root 3342340 Nov 24 13:50 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin
</code></pre>

<p>sysupgrade.bin is for upgrading.</p>

<h3>Upgrade</h3>

<p>System-> Backup/Flash Firmware.   <br/>
Flash New firmware image, choose File. Select the sysupgrade.bin, Upgrade.</p>

<p>Tehn you have to wait for the changes to be applied, around half a miniutes, then everything will be OK.</p>

<h3>Use Flash Disk For Booting</h3>

<p>Cause the inner storage is only 4M-BYTE, we have to enlarge it via adding the external flash disk .</p>

<pre><code>$ opkg update
$ opkg install block-mount kmod-usb-storage fdisk
</code></pre>

<p>Comparing to Attitude Adjustment, the kmod-fs-ext4 couldn&rsquo;t be installed, thus we have to formt the flash disk into ext3 format.</p>

<p>Cause we won&rsquo;t installed the kmod-fs-ext4, so the external system couldn&rsquo;t be used, this time just flash back the Attitude Adjustment.</p>

<h3>Rootfs on External Storage</h3>

<p>Copy the filesystem into the external disk:</p>

<pre><code>root@OpenWrt:/mnt/sda2# tar -C /overlay -cvf - . | tar -C /mnt/sda2 -xf -
root@OpenWrt:/mnt/sda2# ls
etc         lib         lost+found  mnt         sbin        usr
</code></pre>

<p>Configure the /etc/config/fstab:</p>

<pre><code>config mount
        option target   /overlay
        option device   /dev/sda2
        option fstype   ext3
        option options  rw,sync
        option enabled  1
        option enabled_fsck 0
</code></pre>

<p>Reboot and you got 8G rootfs enabled router.</p>

<h3>Wireless-> Wired.</h3>

<p>First set the wireless port to client mode:   <br/>
<img src="/images/wireless_client.jpg" alt="/images/wireless_client.jpg" /></p>

<p>Then set the wired port to static address:  <br/>
<img src="/images/wired_config.jpg" alt="/images/wired_config.jpg" /></p>

<p>Now reset  your router and connect the ethernet port with a line, the equipments who only have ethernet could use router&rsquo;s wireless signal for accessing the network.  <br/>
Later when I study in the library, this router could easily transfer the signal from wireless to wired and let surfacePro work properly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EBC Exercises on BBB - PWM]]></title>
    <link href="http://purplepalmdash.github.io/blog/2014/11/16/ebc-exercises-on-bbb-pwm/"/>
    <updated>2014-11-16T16:44:00+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2014/11/16/ebc-exercises-on-bbb-pwm</id>
    <content type="html"><![CDATA[<h3>PWM</h3>

<p>Simply enable the <code>P9_21</code> to PWM, then connect to the LED. The LED connection could refer to <code>EBC Exercises on BBB - Control LED</code></p>

<pre><code>SLOTS=/sys/devices/bone_capemgr.*/slots
echo am33xx_pwm &gt; $SLOTS
echo bone_pwm_P9_21 &gt; $SLOTS
cd /sys/devices/ocp.3/pwm_test_P9_21.15/
echo 1000000000 &gt; period
echo  250000000 &gt; duty
echo 1 &gt; run
</code></pre>

<p>From now you could see the LED begin to flash. In fact using this pwm we could control servo motor:  <br/>
<a href="http://www.linux.com/learn/tutorials/776799-servo-control-from-the-beaglebone-black/">http://www.linux.com/learn/tutorials/776799-servo-control-from-the-beaglebone-black/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EBC Exercises on BBB -i2c and BBB]]></title>
    <link href="http://purplepalmdash.github.io/blog/2014/11/16/i2c-and-bbb/"/>
    <updated>2014-11-16T13:21:00+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2014/11/16/i2c-and-bbb</id>
    <content type="html"><![CDATA[<h3>Connection</h3>

<p>HMC5883L magnetometer runs in 400KHZ I2C bus, it&rsquo;s for measuring the magnetic field vector in 3 dimensions.   <br/>
We use its 4 ports: VCC,GND,SDA, SCL. SDA is for Data, while SCL is for Clock.</p>

<p>Use P9 for connecting the HMC5883L.</p>

<pre><code>P9_02(GND) &lt;----&gt; GND    
P9_04(VCC) &lt;----&gt; VCC
P9_19(I2C2_SCL) &lt;----&gt; SCL   I2C bus 2(pin 19 on header p9 to SCL) 
P9_20(I2C2_SDA) &lt;----&gt; SDA   
</code></pre>

<h3>I2C Detect</h3>

<p>First you should install i2cdetect, then list the avaiable i2c bus via following command:</p>

<pre><code>root@arm:~# i2cdetect -l
i2c-0   i2c             OMAP I2C adapter                        I2C adapter
i2c-1   i2c             OMAP I2C adapter                        I2C adapter
</code></pre>

<p>We choose i2c bus2, thus the command for detecting the connected device should be:</p>

<pre><code>root@arm:~# i2cdetect -y -r 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- 1e -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- UU UU UU UU -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- --     
</code></pre>

<p>The address should be 0x1e.</p>

<h3>Communicate with HMC5883L</h3>

<p>The registers are listed as following, notice eavh value for each axis are 16-bits, thus we have to read them seperately and combine them:</p>

<pre><code>Address Name    Access
00  Configuration Register A    Read/Write
01  Configuration Register B    Read/Write
02  Mode Register   Read/Write
03  Data Output X MSB Register  Read
04  Data Output X LSB Register  Read
05  Data Output Z MSB Register  Read
06  Data Output Z LSB Register  Read
07  Data Output Y MSB Register  Read
08  Data Output Y LSB Register  Read
09  Status Register Read
10  Identification register A   Read
11  Identification register B   Read
12  Identification register C   Read
</code></pre>

<p>Thus we could read out the X MSB Restier and X LSB Register via:</p>

<pre><code>root@arm:~# i2cget -y 1 0x1e 3
0xfe
root@arm:~# i2cget -y 1 0x1e 4
0x91
</code></pre>

<h4>Different Mode</h4>

<p>Notice Mode Register, this will set the mesurement mode.  <br/>
<img src="/images/moderegister.jpg" alt="/images/moderegister.jpg" /></p>

<p>From the above table, we know for setting the lower 2 bits we could enable the operation mode of HMC5883L.  <br/>
Now we set to single measurement mode, for one-time measure.</p>

<pre><code># i2cset -y 1 0x1e 2 1
</code></pre>

<p>2 means we set the register 2, and its number equals to 01(Single-Measurement Mode). After one-time measurement, it wil fall back to idle Mode.      <br/>
After one-time measurement, get the register mode:</p>

<pre><code>root@arm:~# i2cget -y 1 0x1e 2
0x03
</code></pre>

<p>Get the value of x-axis:</p>

<pre><code>root@arm:~# i2cget -y 1 0x1e 3
0xfe
root@arm:~# i2cget -y 1 0x1e 4
0x77
</code></pre>

<h3>C Code</h3>

<p>Running Result:</p>

<pre><code>root@arm:~/code/i2c# ./myi2cget 1 30 2
0x03 (3)
root@arm:~/code/i2c# ./myi2cget 1 30 34
0x00 (0)
root@arm:~/code/i2c# ./myi2cget 1 30 4
0x77 (119)
</code></pre>

<p>Critical Code:  <br/>
Open the i2c-xxx:</p>

<pre><code>        sprintf(filename, "/dev/i2c-%d", i2cbus);
        file = open(filename, O_RDWR);
</code></pre>

<p>ioctl for setting the address:</p>

<pre><code>        if (ioctl(file, I2C_SLAVE, address) &lt; 0) {
</code></pre>

<p>Now read the byte from:</p>

<pre><code>        res = i2c_smbus_read_byte_data(file, daddress);
</code></pre>

<p>Comparing the official i2cget, myi2cget could print out the human-readable format of data.</p>

<h3>Web Displaying</h3>

<p>Git clone the following project form github.com:</p>

<pre><code># git clone https://github.com/duganje/ECE497_duganje.git
# cd  ECE497_duganje/
# ls
MiniProject01  MiniProject02  MiniProject03  MiniProject04  README.md
</code></pre>

<p>Upload the project MiniProject04 to the BBB board.  <br/>
Notice change the code in buttonBox.js from <code>i2cset -y 3</code> to <code>i2cset -y 1 and</code>i2cget -y 3<code>to</code>i2cget -y 1`</p>

<p>After modification, run buttonBox.js via:</p>

<pre><code>$ node buttonBox.js
</code></pre>

<p>Now visit the <code>http://xx.xx.xx.xxx:8081/buttonBox.html</code> you could see the data displayed as following:</p>

<p><img src="/images/magnetometer.jpg" alt="/images/magnetometer.jpg" /></p>
]]></content>
  </entry>
  
</feed>
