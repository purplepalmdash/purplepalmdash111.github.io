<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Embedded | Dash]]></title>
  <link href="http://purplepalmdash.github.io/blog/categories/embedded/atom.xml" rel="self"/>
  <link href="http://purplepalmdash.github.io/"/>
  <updated>2016-03-12T20:58:04+08:00</updated>
  <id>http://purplepalmdash.github.io/</id>
  <author>
    <name><![CDATA[Dash]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tips on 5050RGB]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/12/tips-on-5050rgb/"/>
    <updated>2016-03-12T19:32:42+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/12/tips-on-5050rgb</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>淘宝上买的5050RGB模块, 外观如下图:</p>

<p><img src="/images/2016_03_12_19_36_05_351x233.jpg" alt="/images/2016_03_12_19_36_05_351x233.jpg" /></p>

<p>连线:</p>

<p>这个RGB模块比较奇怪,直接使用Arduino的5v输出一直有问题,我是用的外接5V电源供电,
动用了面包板模块.(之后发现不是供电的问题, 是因为淘宝上卖的模块提供示例代码的问
题)</p>

<p>更具体的连线如下:</p>

<pre><code>// V-VCC 5V   R-9   B-10  G-11
#define LEDR 9
#define LEDB 10
#define LEDG 11
</code></pre>

<h3>测试</h3>

<p>按照厂方提供的程序,未能成功运行.</p>

<p>厂方提供的电路图如下:</p>

<p><img src="/images/2016_03_12_20_31_25_373x471.jpg" alt="/images/2016_03_12_20_31_25_373x471.jpg" /></p>

<h3>Debug</h3>

<p>百思不得其解后,用万用表测试, 电阻发声的那档, 发现加电后,某两个LED可以亮, 另外
一个不能亮.</p>

<p>发现奇怪的一点是, VCC接高电压, RGB接低电压时, 无法点亮LED. RGB接高电压, VCC接
低电压时, LED可以被点亮两个.</p>

<p>猜测: 厂方给的参考资料有误, 接线错误. 而且LED坏了一个.</p>

<p>验证, 正确.</p>

<p>连线更改为:</p>

<pre><code>// V-VCC 5V   R-9   B-10  G-11
#define LEDR 9
#define LEDG 10
</code></pre>

<p>蓝色的LED已坏, 所以示例代码中,不许配置LEDB.</p>

<pre><code>// V-VCC GND   R-9   G-10  
#define LEDR 9
#define LEDG 10

int i = 0;

void setup()
{
  pinMode(LEDG,OUTPUT);
  pinMode(LEDR,OUTPUT);

}

void loop()
{
  analogWrite(LEDR,0);
  analogWrite(LEDG,0);  //off
  delay(1000);
  analogWrite(LEDR,255); 
delay(1000); 
  analogWrite(LEDR,0);
  analogWrite(LEDG,0);
  delay(1000); 
  analogWrite(LEDR,30);
  analogWrite(LEDG,200);
delay(1000); 
  analogWrite(LEDR,0);
  analogWrite(LEDG,0);
  delay(1000); 
    analogWrite(LEDG,30);
  analogWrite(LEDR,200);
  delay(1000); 
}
</code></pre>

<p>正确的电路连线应该是:</p>

<p><img src="/images/2016_03_12_20_54_55_707x379.jpg" alt="/images/2016_03_12_20_54_55_707x379.jpg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on W5100]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/11/tips-on-w5100/"/>
    <updated>2016-03-11T22:00:50+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/11/tips-on-w5100</id>
    <content type="html"><![CDATA[<h3>参考</h3>

<p>参考如下:</p>

<p><a href="http://www.bigiot.net/help/6.html">http://www.bigiot.net/help/6.html</a></p>

<h3>问题</h3>

<p>上报的数据不准确.</p>

<p>原因是因为W5100抄版的淘宝版本有短路, 换成别的模拟口:</p>

<pre><code>const int LM35 = 3;//LM35 pin
byte mac[] = {0x00, 0x1D, 0x72, 0x82, 0x35, 0x9D};
EthernetClient client ;
IPAddress ip(192, 168, 17, 177);//local IP
//IPAddress server(121,42,180,30);
char server[] = "www.bigiot.net"; 
</code></pre>

<p>连线改为了3, 即A3口以后,上报数据成功.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on V-USB and Arduino(5)]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/07/tips-on-v-usb-and-arduino-5/"/>
    <updated>2016-03-07T21:52:47+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/07/tips-on-v-usb-and-arduino-5</id>
    <content type="html"><![CDATA[<p>这一节将添加一个LED到已有的方案中. 这个LED将使用11口, 通过<code>./set-led new</code>来设
置状态.</p>

<h3>连线</h3>

<p>新加一个LED如图:</p>

<p><img src="/images/2016_03_07_21_52_18_683x513.jpg" alt="/images/2016_03_07_21_52_18_683x513.jpg" /></p>

<p>仅仅添加了一个LED + 220欧电阻.</p>

<h3>代码修改</h3>

<h4>requests.h</h4>

<p>添加新的request定义:</p>

<pre><code class="diff">diff --git a/requests.h b/requests.h
index 90275f5..b354a73 100644
--- a/requests.h
+++ b/requests.h
@@ -32,4 +32,6 @@

 #define CUSTOM_RQ_BLINK    3

+#define CUSTOM_RQ_NEWLED    4
+
</code></pre>

<h4>hid_custom_rq.h</h4>

<p>添加新的管脚, 和对<code>CUSTOM_RQ_NEWLED</code>的处理代码:</p>

<pre><code class="diff">diff --git a/hid_custom_rq.h b/hid_custom_rq.h
index f5509e4..b5411cf 100644
--- a/hid_custom_rq.h
+++ b/hid_custom_rq.h
@@ -13,6 +13,7 @@ class hid_custom_rqDevice {
   hid_custom_rqDevice () {
     usbInit();
     ledPin = 13;        // pin 13 as default ledPin
+    newledPin = 11;    // pin 11 as newledPin
   }

   void poll() {
@@ -20,6 +21,7 @@ class hid_custom_rqDevice {
   }

   unsigned int ledPin;  
+  unsigned int newledPin;  
 };

 hid_custom_rqDevice hid_custom_rq = hid_custom_rqDevice();
@@ -99,6 +101,14 @@ usbMsgLen_t usbFunctionSetup(uchar data[8])
             usbMsgPtr = dataBuffer;         /* tell the driver which data to
return */
             return 1;                       /* tell the driver to send 1 byte
*/
         }
+       /* Added for newly added LED */
+       else if(rq-&gt;bRequest == CUSTOM_RQ_NEWLED){
+            if(rq-&gt;wValue.bytes[0] &amp; 1){    /* set new LED */
+                digitalWrite(hid_custom_rq.newledPin, HIGH);
+            }else{                          /* clear new LED */
+                digitalWrite(hid_custom_rq.newledPin, LOW);
+            }
+       }
     }
</code></pre>

<h4>set-led.c</h4>

<p>这个文件中,添加了两条新命令,分别为<code>./set-led newledon</code>和<code>./set-led newledoff</code>用于点亮/
熄灭新加的LED.</p>

<pre><code>diff --git a/examples/hid_custom_rq_demo/commandline/set-led.c b/examples/hid_custom_rq_demo/commandline/set-led.c
index 44d39f9..a306eca 100644
--- a/examples/hid_custom_rq_demo/commandline/set-led.c
+++ b/examples/hid_custom_rq_demo/commandline/set-led.c
@@ -91,12 +91,19 @@ buffer[3] = 0;
         }else{
             printf("LED is %s\n", buffer[0] ? "on" : "off");
         }
-    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+    }
+    else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
         cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
         if(cnt &lt; 0){
             fprintf(stderr, "USB error: %s\n", usb_strerror());
         }
     }
+    else if((isOn = (strcasecmp(argv[1], "newledon") == 0)) || strcasecmp(argv[1], "newledoff") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_NEWLED, isOn, 0, buffer, 0, 5000);
+        if(cnt &lt; 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+    }

 else if(strcasecmp(argv[1], "onoff") == 0){ /* Test custom on/off */
</code></pre>

<h4>hid_custom_rq_demo.ped</h4>

<p>因为新添加了硬件,ped文件同样需要更新.</p>

<pre><code>diff --git a/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde b/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde
index 77e3912..6d98151 100644
--- a/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde
+++ b/examples/hid_custom_rq_demo/hid_custom_rq_demo.pde
@@ -1,10 +1,13 @@
 #include &lt;hid_custom_rq.h&gt;

 const int ledPin = 13;
+const int newledPin = 11;

 void setup() {
   hid_custom_rq.ledPin = ledPin;
   pinMode(hid_custom_rq.ledPin, OUTPUT);
+  hid_custom_rq.newledPin = newledPin;
+  pinMode(hid_custom_rq.newledPin, OUTPUT);
 }

 void loop() {
</code></pre>

<h3>验证</h3>

<p>写入新编译的Arduino固件, 并新编译<code>set-led</code>程序, 即可看到新增的LED被点亮/熄灭.</p>

<p>效果如图:</p>

<p><img src="/images/70584386.jpg" alt="/images/70584386.jpg" /></p>

<h3>延伸</h3>

<p>既然点亮了LED, 其他各种设备就不在话下了. 引入一个舵机,或者步进电机, 就可以实现
e-buddy人偶的提醒功能.</p>

<p>当然我们可以想得更妙, 例如,用蓝牙或者WIFI来替代USB传输. 这样可以做到更远距离.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips on V-USB and Arduino(4)]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/07/tips-on-v-usb-and-arduino-4/"/>
    <updated>2016-03-07T21:07:53+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/07/tips-on-v-usb-and-arduino-4</id>
    <content type="html"><![CDATA[<p>前面把玩了一下ebuddy, 回去想了一下, 觉得基于v-usb和arduino来实现
一个自己的ebuddy也不是特别难的事情.</p>

<h3>思路</h3>

<p>还是参考:</p>

<p><a href="http://coopermaa2nd.blogspot.tw/2011/10/v-usb-examples-for-arduino.html">V-USB examples for Arduino</a></p>

<p>以<code>hid_custom_rq</code>项目来改. 例子里已经实现了Arduino板载的LED亮/灭. 我们只需要在
原例上修改, 添加自定义命令和硬件即可.</p>

<h3>代码</h3>

<p>示例代码我做完后放到了github上, 可以通过以下命令获得:</p>

<pre><code>$ git clone git@github.com:purplepalmdash/arduino-usb-led.git
</code></pre>

<h3>主要修改</h3>

<h4>request.h</h4>

<p>这个头文件被USB固件和主机所共享, 定义了USB的request number数字, request number
被用于主机和设备之间的通信.</p>

<p>添加:</p>

<pre><code>#define CUSTOM_RQ_BLINK    3
</code></pre>

<h4>hid_custom_rq.h</h4>

<p>这个文件是Arduino板上固件程序中对各种来自主机的request信息的响应, 或者说, 消息
处理函数.</p>

<p>针对上面在<code>requst.h</code>文件中添加的消息, 我们需要在<code>usbFunctionSetup()</code>函数中添加
对应的消息处理代码, 为简单起见, 直接添加在函数的入口处就好.</p>

<pre><code class="c">
usbMsgLen_t usbFunctionSetup(uchar data[8])
{
    usbRequest_t    *rq = (usbRequest_t *)((void *)data);    

+    if(rq-&gt;bRequest == CUSTOM_RQ_BLINK){ /* blink -- used for blink the LED */
+            /* First set the led pin to high  */
+             unsigned char i = 6;
+             while(i &gt;= 1)
+             {
+             digitalWrite(hid_custom_rq.ledPin, HIGH);
+             delay(1000);
+             digitalWrite(hid_custom_rq.ledPin, LOW);
+             delay(1000);
+             i--;
+             }
+    }

    if((rq-&gt;bmRequestType &amp; USBRQ_TYPE_MASK) == USBRQ_TYPE_VENDOR){
        if(rq-&gt;bRequest == CUSTOM_RQ_SET_STATUS){
</code></pre>

<p>上面添加的代码, 在监测到<code>CUSTOM_RQ_BLINK</code>消息后, 会将led闪烁6次.</p>

<h4>set-led.c</h4>

<p><code>set-led.c</code>文件用于编译出主机端程序, 编译出来的程序将接受用户输入, 将对应的输
入发送给USB设备.</p>

<p>在<code>set-led.c</code>文件中我们添加一条命令,用于发送<code>CUSTOM_RQ_BLINK</code>消息:</p>

<pre><code class="c">$ vim examples/hid_custom_rq_demo/commandline/set-led.c
int main(int argc, char **argv)
{

//.......

+ else if(strcasecmp(argv[1], "blink") == 0){ /* set blink goes here */
+         cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_BLINK, 0, 0, buffer, 0, 5000);
+         if(cnt &lt; 0){
+             fprintf(stderr, "USB error: %s\n", usb_strerror());
+         }
+ }

//.......

}
</code></pre>

<h3>验证</h3>

<p>将代码拷贝到Arduino IDE的<code>libraries</code>目录下:</p>

<pre><code>$ pwd
/media/y/arduino/1.0.5/libraries/hid_custom_rq
</code></pre>

<p>IDE菜单里的<code>File -&gt; Examples -&gt; hid_custom_rq</code>下将出现<code>hid_custom_rq_demo</code>, 点
击, 开始编译. 编译完以后, 上传到Arduino板.</p>

<p>按
<a href="http://purplepalmdash.github.io/blog/2016/02/26/tips-on-v-usb-and-arduino-2/">http://purplepalmdash.github.io/blog/2016/02/26/tips-on-v-usb-and-arduino-2/</a>
设置并检查Arduino连线.</p>

<p>现在拔掉Arduino串口的USB线, 插上我们新加的USB连线, 而后运行以下验证例程:</p>

<pre><code>➜  hid_custom_rq git:(master) cd examples/hid_custom_rq_demo/commandline 
➜  commandline git:(master) ./set-led blink
USB error: Connection timed out
</code></pre>

<p>出现USB error是因为在板子上的服务例程中耗费了太多时间. 问题不大. 每次运行
<code>./set-led blink</code>命令将使得板子上13口的led闪烁6次.</p>

<p>做到这里, 我们已经能模拟出ebuddy的心脏灯光效果了. 通过编写不同的request消息,发
送给Arduino板子即可.</p>

<p>下面将研究添加一个新的LED灯, 等同于ebuddy的头灯.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[把玩ebuddy(2)]]></title>
    <link href="http://purplepalmdash.github.io/blog/2016/03/03/ba-wan-ebuddy-2/"/>
    <updated>2016-03-03T10:15:43+08:00</updated>
    <id>http://purplepalmdash.github.io/blog/2016/03/03/ba-wan-ebuddy-2</id>
    <content type="html"><![CDATA[<h3>ArchLinux配置过程</h3>

<p>因为ArchLinux默认python版本为python3, 使用python2激活e-buddy人偶:</p>

<pre><code>$ sudo pacman -S python2-pip
$ sudo pip2 install pyusb
$ git clone git@github.com:purplepalmdash/pybuddy-dx.git
$ sudo python2 ~/Code/ebuddy/pybuddy-dx/pybuddyDX.py
$ sudo netstat -anp | grep 8888
udp        0      0 127.0.0.1:8888          0.0.0.0:*                           14635/python2 
</code></pre>

<p>接下来就是往<code>127.0.0.1:8888</code>发送指令控制人偶的干活了。具体的指令可以见上一篇文章。</p>

<h3>定期检查邮件控制人偶</h3>

<p>先安装用于检查imap服务端状态的python模块:</p>

<pre><code>$ sudo pip2 install imapclient
</code></pre>

<p>检查邮件的脚本如下, 该脚本检查163邮箱的IMAP服务器，如果有新邮件，人偶的头就会出现颜色渐
变，否则，则显示绿灯闪烁:</p>

<pre><code>#!/usr/bin/env python
import imaplib 
from imapclient import IMAPClient
import time
import subprocess
import thread

DEBUG = True

HOSTNAME = 'imap.163.com'
USERNAME = 'XXXXXXXX'
PASSWORD = 'XXXXXXXX'
MAILBOX = 'Inbox'
newmails = 0

NEWMAIL_OFFSET = 0   # my unread messages never goes to zero, yours might
MAIL_CHECK_FREQ = 60 # check mail every 60 seconds

# Define a function for checking email
def check_mail( threadName):
    while True:
        # Login into the imap server and check the numbers for the new mail.
        server = IMAPClient(HOSTNAME, use_uid=True, ssl=True)
        server.login(USERNAME, PASSWORD)
        if DEBUG:
            print('Logging in as ' + USERNAME)
            select_info = server.select_folder(MAILBOX)
            print('%d messages in INBOX' % select_info['EXISTS'])

        folder_status = server.folder_status(MAILBOX, 'UNSEEN')
        global newmails
        newmails = int(folder_status['UNSEEN'])

        if DEBUG:
            print "You have", newmails, "new emails!"
        time.sleep(MAIL_CHECK_FREQ)

def loop():

    if newmails &gt; NEWMAIL_OFFSET:
        bashCommand = 'echo 12 &gt; /dev/udp/127.0.0.1/8888'
        output = subprocess.check_output(['bash','-c', bashCommand])
        time.sleep(8)
    else:
        bashCommand = 'echo 08 &gt; /dev/udp/127.0.0.1/8888'
        output = subprocess.check_output(['bash','-c', bashCommand])
        time.sleep(5)

if __name__ == '__main__':
    try:
        print 'Press Ctrl-C to quit.'
        thread.start_new_thread( check_mail, ("Thread-1", ) )
        while True:
            loop()
    finally:
        print "finally comes here!"
</code></pre>
]]></content>
  </entry>
  
</feed>
