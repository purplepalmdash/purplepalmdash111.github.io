<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fc on Dash</title>
    <link>http://purplepalmdash.github.io/categories/fc/</link>
    <description>Recent content in Fc on Dash</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Apr 2014 16:50:56 +0000</lastBuildDate>
    <atom:link href="http://purplepalmdash.github.io/categories/fc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Programming in C of FC tutorial 6</title>
      <link>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-6/</link>
      <pubDate>Tue, 08 Apr 2014 16:50:56 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-6/</guid>
      <description>&lt;p&gt;###Full Circle C 8
####Limitation
Fibonacci sequence: normally this program limited by the limitation of unsigned long long&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

typedef unsigned long long fibo_type;
#define FIBO_FORMAT &amp;quot;%10llu&amp;quot;

void printFibo(fibo_type num)
{
        printf(FIBO_FORMAT, num);
}

int main()
{
        int num = 0;
        fibo_type a = 0, b=1, c;

        printf(&amp;quot;%4d: &amp;quot;, ++num);
        printFibo(a);
        printf(&amp;quot;\n&amp;quot;);

        printf(&amp;quot;%4d: &amp;quot;,++num);
        printFibo(b);
        printf(&amp;quot;\n&amp;quot;);

        c=a+b;
        while(c&amp;gt;=b)
        {
                printf(&amp;quot;%4d: &amp;quot;,++num);
                printFibo(c);
                printf(&amp;quot;\n&amp;quot;);
                a=b;
                b=c;
                c=a+b;
        }

        printf(&amp;quot;Stopped after %d digits\n&amp;quot;, num);
        printFibo(c);
        printf(&amp;quot;\n&amp;quot;);
        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program will exit when c reach the limitation of definition of unsigned long long
####Using GMP
Using gmp to re-write this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;gmp.h&amp;gt;

int main()
{
        int num = 0;
        mpz_t f_1;
        mpz_t f_2;

        mpz_init(f_1);
        mpz_init(f_2);
        mpz_set_ui(f_1, 0);
        mpz_set_ui(f_1, 1);
        printf(&amp;quot;%10d: 0\n&amp;quot;, ++num);

        while(1)
        {
                mpz_add(f_1, f_2, f_1);
                mpz_swap(f_1, f_2);
                char *res = mpz_get_str(NULL, 10, f_2);
                printf(&amp;quot;%10d: %s\n&amp;quot;, ++num, res);
                free(res);
                sleep(1);
        }

        mpz_clear(f_1);
        mpz_clear(f_2);
        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile it via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o Fibonacci2 Fibonacci2.c -lgmp

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This won&amp;rsquo;t have limitation currently, but you have to finish the execises, when you get internet connection.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming in C of FC tutorial 5</title>
      <link>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-5/</link>
      <pubDate>Tue, 08 Apr 2014 16:17:22 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-5/</guid>
      <description>&lt;p&gt;###Full Circle C 7
####Example
Following is the origin ifstat.c, this program will list the net-interface payloads, and it will print out the net interface statistics every 2 seconds, but notice this program have several bugs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
typedef unsigned long long ull;
int parseDevFile(const char * iface, ull *bRx, ull *pRx, ull *bTx, ull *pTx);
void dumpInterfaceUsage(const char * iface);
int parseDevFile(const char * iface, ull *bRx, ull *pRx, ull *bTx, ull *pTx)
{
        FILE * fp = NULL;
        char * line = NULL;
        unsigned int len = 0;
        fp = fopen(&amp;quot;/proc/net/dev&amp;quot;, &amp;quot;r&amp;quot;);
        if(fp == NULL)
        {
                return -1;
        }
        while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
        {
                if(strstr(line, iface) != NULL)
                {
                        sscanf(strstr(line, &amp;quot;:&amp;quot;)+1, &amp;quot;%llu%llu%*u%*u%*u%*u%*u%*u%llu%llu&amp;quot;, bRx, pRx, bTx, pTx);
                }
        }
        fclose(fp);
        free(line);
        return 0;
}
void dumpInterfaceUsage(const char * iface)
{
        ull ifaceBRxOld = 0, ifaceBTxOld = 0, ifacePRxOld = 0, ifacePTxOld = 0;
        ull ifaceBRxNew = 0, ifaceBTxNew = 0, ifacePRxNew = 0, ifacePTxNew = 0;
        const int SLEEP_TIME = 2;

        if(parseDevFile(iface, &amp;amp;ifaceBRxOld, &amp;amp;ifacePRxOld, &amp;amp;ifaceBTxOld, &amp;amp;ifacePTxOld) == -1) return;
        sleep(SLEEP_TIME);
        while(1)
        {
                if(parseDevFile(iface, &amp;amp;ifaceBRxNew, &amp;amp;ifacePRxNew, &amp;amp;ifaceBTxNew, &amp;amp;ifacePTxNew) == -1) return;
                printf(&amp;quot;%s In: %8.2f kbytes/s  %5llu P/s Out: %8.2f kbytes/s %5llu P/s\n&amp;quot;, iface,
                                (ifaceBRxNew - ifaceBRxOld)/(SLEEP_TIME *1024.0),
                                (ifacePRxNew - ifacePRxOld)/(SLEEP_TIME),
                                (ifaceBTxNew - ifaceBTxOld)/(SLEEP_TIME *1024.0),
                                (ifacePTxNew - ifacePTxOld)/(SLEEP_TIME));
                ifaceBRxOld = ifaceBRxNew;
                ifaceBTxOld = ifaceBTxNew;
                ifacePRxOld = ifacePRxNew;
                ifacePTxOld = ifacePTxNew;
                sleep(SLEEP_TIME);
        }
}

int main(int argc, char **argv)
{
        if(argc != 2)
        {
                printf(&amp;quot;Usage: %s interfacename\n&amp;quot;, argv[0]);
                return 1;
        }
        dumpInterfaceUsage(argv[1]);
        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost C7]# ./ifstat eth0
eth0 In:     0.24 kbytes/s      2 P/s Out:     0.25 kbytes/s     1 P/s
eth0 In:     0.32 kbytes/s      4 P/s Out:     0.97 kbytes/s     3 P/s
eth0 In:     1.29 kbytes/s     13 P/s Out:     5.06 kbytes/s    13 P/s
eth0 In:     0.06 kbytes/s      1 P/s Out:     0.08 kbytes/s     0 P/s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Bugs
Ok, now let&amp;rsquo;s see its bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#enable the unlimited:
[root@localhost C7]# ulimit -c unlimited
#Get the core file: 
[root@localhost C7]# ./ifstat b
Segmentation fault (core dumped)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Debugging&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost C7]# ls -l -h core*
-rw------- 1 root root 272K Oct 14 06:53 core.3961
#Use gdb for anlysing the corefile:    
[root@localhost C7]# gdb ifstat core.3961
GNU gdb Fedora (6.8-27.el5)
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i386-redhat-linux-gnu&amp;quot;...

warning: Can&#39;t read pathname for load map: Input/output error.
Reading symbols from /lib/libc.so.6...done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
Core was generated by `./ifstat b&#39;.
Program terminated with signal 11, Segmentation fault.
[New process 3961]
#0  0x00b6f957 in rawmemchr () from /lib/libc.so.6

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seems the corefile is useless, this because the error is not derived from our own code, but rather from the library. Run gdb for anlysing the ./ifstat b&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost C7]# gdb ./ifstat
GNU gdb Fedora (6.8-27.el5)
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i386-redhat-linux-gnu&amp;quot;...
(gdb) run b
Starting program: /root/code/C7/ifstat b

Program received signal SIGSEGV, Segmentation fault.
0x00b6f957 in rawmemchr () from /lib/libc.so.6
(gdb) break parseDevFile
Breakpoint 1 at 0x804854a: file ifstat.c, line 10.
(gdb) run b
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/code/C7/ifstat b

Breakpoint 1, parseDevFile (iface=0xbfe52b5e &amp;quot;b&amp;quot;, bRx=0xbfe50f80, pRx=0xbfe50f70, bTx=0xbfe50f78, pTx=0xbfe50f68) at ifstat.c:10
10              FILE * fp = NULL;
(gdb) step
11              char * line = NULL;
(gdb)
12              unsigned int len = 0;
(gdb)
13              fp = fopen(&amp;quot;/proc/net/dev&amp;quot;, &amp;quot;r&amp;quot;);
(gdb) print fp
$1 = (FILE *) 0x0
(gdb) step
14              if(fp == NULL)
(gdb) step
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
(gdb) display line
1: line = 0x0
(gdb) step
20                      if(strstr(line, iface) != NULL)
1: line = 0x9730170 &amp;quot;Inter-|   Receive&amp;quot;, &#39; &#39; &amp;lt;repeats 48 times&amp;gt;, &amp;quot;|  Transmit\n&amp;quot;
(gdb) step
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9730170 &amp;quot;Inter-|   Receive&amp;quot;, &#39; &#39; &amp;lt;repeats 48 times&amp;gt;, &amp;quot;|  Transmit\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9730170 &amp;quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n&amp;quot;
(gdb)
22                              sscanf(strstr(line, &amp;quot;:&amp;quot;)+1, &amp;quot;%llu%llu%*u%*u%*u%*u%*u%*u%llu%llu&amp;quot;, bRx, pRx, bTx, pTx);
1: line = 0x9730170 &amp;quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n&amp;quot;
(gdb)

Program received signal SIGSEGV, Segmentation fault.
0x00b6f957 in rawmemchr () from /lib/libc.so.6
(gdb)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We found another bug, also we can see ./ifstat dba&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost C7]# gdb ./ifstat
GNU gdb Fedora (6.8-27.el5)
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;
and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;i386-redhat-linux-gnu&amp;quot;...
(gdb) run dba
Starting program: /root/code/C7/ifstat dba
dba In:     0.00 kbytes/s      0 P/s Out:     0.00 kbytes/s     0 P/s
dba In:     0.00 kbytes/s      0 P/s Out:     0.00 kbytes/s     0 P/s

Program received signal SIGINT, Interrupt.
0x00ef3402 in __kernel_vsyscall ()
(gdb) break parseDevFile
Breakpoint 1 at 0x804854a: file ifstat.c, line 10.
(gdb) run dba
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /root/code/C7/ifstat dba

Breakpoint 1, parseDevFile (iface=0xbf81bb5c &amp;quot;dba&amp;quot;, bRx=0xbf81ad40, pRx=0xbf81ad30, bTx=0xbf81ad38, pTx=0xbf81ad28) at ifstat.c:10
10              FILE * fp = NULL;
(gdb) step
11              char * line = NULL;
(gdb) step
12              unsigned int len = 0;
(gdb) step
13              fp = fopen(&amp;quot;/proc/net/dev&amp;quot;, &amp;quot;r&amp;quot;);
(gdb) step
14              if(fp == NULL)
(gdb) step
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
(gdb) display line
1: line = 0x0
(gdb) step
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;Inter-|   Receive&amp;quot;, &#39; &#39; &amp;lt;repeats 48 times&amp;gt;, &amp;quot;|  Transmit\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;Inter-|   Receive&amp;quot;, &#39; &#39; &amp;lt;repeats 48 times&amp;gt;, &amp;quot;|  Transmit\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;    lo: 4684910    2267    0    0    0     0          0         0  4684910    2267    0    0    0     0       0          0\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;    lo: 4684910    2267    0    0    0     0          0         0  4684910    2267    0    0    0     0       0          0\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;  eth0: 5135043   75928    0    0    0     0          0         0 15204045  129941    0    0    0     0       0          0\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;  eth0: 5135043   75928    0    0    0     0          0         0 15204045  129941    0    0    0     0       0          0\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
25              fclose(fp);
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
26              free(line);
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
27              return 0;
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
28      }
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
dumpInterfaceUsage (iface=0xbf81bb5c &amp;quot;dba&amp;quot;) at ifstat.c:36
36              sleep(SLEEP_TIME);
(gdb)
39                      if(parseDevFile(iface, &amp;amp;ifaceBRxNew, &amp;amp;ifacePRxNew, &amp;amp;ifaceBTxNew, &amp;amp;ifacePTxNew) == -1) return;
(gdb)

Breakpoint 1, parseDevFile (iface=0xbf81bb5c &amp;quot;dba&amp;quot;, bRx=0xbf81ad20, pRx=0xbf81ad10, bTx=0xbf81ad18, pTx=0xbf81ad08) at ifstat.c:10
10              FILE * fp = NULL;
1: line = 0xaf5ca0 &amp;quot;&amp;quot;
(gdb)
11              char * line = NULL;
1: line = 0xaf5ca0 &amp;quot;&amp;quot;
(gdb)
12              unsigned int len = 0;
1: line = 0x0
(gdb)
13              fp = fopen(&amp;quot;/proc/net/dev&amp;quot;, &amp;quot;r&amp;quot;);
1: line = 0x0
(gdb)
14              if(fp == NULL)
1: line = 0x0
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x0
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;Inter-|   Receive&amp;quot;, &#39; &#39; &amp;lt;repeats 48 times&amp;gt;, &amp;quot;|  Transmit\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;Inter-|   Receive&amp;quot;, &#39; &#39; &amp;lt;repeats 48 times&amp;gt;, &amp;quot;|  Transmit\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot; face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;    lo: 4684910    2267    0    0    0     0          0         0  4684910    2267    0    0    0     0       0          0\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;    lo: 4684910    2267    0    0    0     0          0         0  4684910    2267    0    0    0     0       0          0\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;  eth0: 5141021   76010    0    0    0     0          0         0 15217535  130042    0    0    0     0       0          0\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;  eth0: 5141021   76010    0    0    0     0          0         0 15217535  130042    0    0    0     0       0          0\n&amp;quot;
(gdb)
20                      if(strstr(line, iface) != NULL)
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
18              while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
25              fclose(fp);
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
26              free(line);
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
27              return 0;
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
28      }
1: line = 0x9101170 &amp;quot;  sit0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\n&amp;quot;
(gdb)
dumpInterfaceUsage (iface=0xbf81bb5c &amp;quot;dba&amp;quot;) at ifstat.c:40
40                      printf(&amp;quot;%s In: %8.2f kbytes/s  %5llu P/s Out: %8.2f kbytes/s %5llu P/s\n&amp;quot;, iface,
(gdb)
dba In:     0.00 kbytes/s      0 P/s Out:     0.00 kbytes/s     0 P/s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Conclusion:
And now we can get the reason, the ./ifstat b is because we reached the line2 of the /proc/net/dev, it has b for &amp;ldquo;bytes&amp;rdquo;.&lt;br /&gt;
./ifstat dba always print 0 because we don&amp;rsquo;t have this equipment at all !&lt;br /&gt;
####Correcting
So the corrected code is listed as following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int parseDevFile(const char * iface, ull *bRx, ull *pRx, ull *bTx, ull *pTx)
{
        FILE * fp = NULL;
        char * line = NULL;
        unsigned int len = 0;
        short int exists = 0;
        fp = fopen(&amp;quot;/proc/net/dev&amp;quot;, &amp;quot;r&amp;quot;);
        if(fp == NULL)
        {
                return -1;
        }
        while(getline(&amp;amp;line, &amp;amp;len, fp) != -1)
        {
                if(strstr(line, iface) != NULL)
                {
                        if(strstr(line, &amp;quot;:&amp;quot;) != NULL)
                        {
                                sscanf(strstr(line, &amp;quot;:&amp;quot;)+1, &amp;quot;%llu%llu%*u%*u%*u%*u%*u%*u%llu%llu&amp;quot;, bRx, pRx, bTx, pTx);
                                exists = 1;
                        }
                }
        }
        fclose(fp);
        free(line);
        if( exists != 1)
        {
                fprintf(stderr, &amp;quot;Your device %s is not in the file /proc/net/dev!\n&amp;quot;, iface);
                exit(2);
        }
        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run it and the result is listed as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost C7]# ./ifstat_upgrade b
Your device b is not in the file /proc/net/dev!
[root@localhost C7]# ./ifstat_upgrade bba
Your device bba is not in the file /proc/net/dev!
[root@localhost C7]# ./ifstat_upgrade eth0
eth0 In:     0.03 kbytes/s      0 P/s Out:     0.00 kbytes/s     0 P/s
eth0 In:     0.03 kbytes/s      0 P/s Out:     0.08 kbytes/s     0 P/s

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Programming in C of FC tutorial 4</title>
      <link>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-4/</link>
      <pubDate>Tue, 08 Apr 2014 16:01:06 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-4/</guid>
      <description>&lt;p&gt;###Full Circle C 6
####Using valgrid for memory check
See &lt;a href=&#34;www.valgrind.org&#34;&gt;www.valgrind.org&lt;/a&gt; for more information for using the valgrind available tools.&lt;br /&gt;
memcheck is the main topic in this chapter.&lt;br /&gt;
this tool override libc calls that deal with handling memory. And it will do some bookkeeping. is all memory given back to the system, and is all the allocated memory still reachable?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void leak()
{
        char *ptr = malloc(10);
        printf(&amp;quot;malloc(10) points to: %p\n&amp;quot;, ptr);
}

int main()
{
        int i = 0;
        for(i = 0; i&amp;lt;10; i++)
        {
                leak();
        }
        char *ptr = malloc(15);
        printf(&amp;quot;malloc(15) in main: %p\n&amp;quot;, ptr);
        while(1){}
        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result shows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;valgrind --leak-check=full --show-reachable=yes ./memleak
==2144== Memcheck, a memory error detector.
==2144== Copyright (C) 2002-2006, and GNU GPL&#39;d, by Julian Seward et al.
==2144== Using LibVEX rev 1658, a library for dynamic binary translation.
==2144== Copyright (C) 2004-2006, and GNU GPL&#39;d, by OpenWorks LLP.
==2144== Using valgrind-3.2.1, a dynamic binary instrumentation framework.
==2144== Copyright (C) 2000-2006, and GNU GPL&#39;d, by Julian Seward et al.
==2144== For more details, rerun with: -v
==2144==
malloc(10) points to: 0x4022028
malloc(10) points to: 0x4022068
malloc(10) points to: 0x40220a8
malloc(10) points to: 0x40220e8
malloc(10) points to: 0x4022128
malloc(10) points to: 0x4022168
malloc(10) points to: 0x40221a8
malloc(10) points to: 0x40221e8
malloc(10) points to: 0x4022228
malloc(10) points to: 0x4022268
malloc(15) in main: 0x40222a8
==2144==
==2144== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 12 from 1)
==2144== malloc/free: in use at exit: 115 bytes in 11 blocks.
==2144== malloc/free: 11 allocs, 0 frees, 115 bytes allocated.
==2144== For counts of detected errors, rerun with: -v
==2144== searching for pointers to 11 not-freed blocks.
==2144== checked 46,792 bytes.
==2144==
==2144== 15 bytes in 1 blocks are still reachable in loss record 1 of 2
==2144==    at 0x40053C0: malloc (vg_replace_malloc.c:149)
==2144==    by 0x8048419: main (leak.c:17)
==2144==
==2144==
==2144== 100 bytes in 10 blocks are definitely lost in loss record 2 of 2
==2144==    at 0x40053C0: malloc (vg_replace_malloc.c:149)
==2144==    by 0x80483C5: leak (leak.c:6)
==2144==    by 0x8048403: main (leak.c:15)
==2144==
==2144== LEAK SUMMARY:
==2144==    definitely lost: 100 bytes in 10 blocks.
==2144==      possibly lost: 0 bytes in 0 blocks.
==2144==    still reachable: 15 bytes in 1 blocks.
==2144==         suppressed: 0 bytes in 0 blocks.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we change the code into following, this means valgrid won&amp;rsquo;t interpret the output, so this will let the tracked memory add 10&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void leak()
{
        char *ptr = malloc(10);
        printf(&amp;quot;malloc(10) points to: %p\n&amp;quot;, ptr);
}

int main()
{
        int i = 0;
        for(i = 0; i&amp;lt;10; i++)
        {
                leak();
        }
        char *ptr = malloc(15);
        printf(&amp;quot;malloc(15) in main: %p\n&amp;quot;, ptr);
        //while(1){}
        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile and verify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -Wall -g leak1.c -o memleak1
View the valgrind result:
valgrind --leak-check=full --show-reachable=yes ./memleak1
==2190== Memcheck, a memory error detector.
==2190== Copyright (C) 2002-2006, and GNU GPL&#39;d, by Julian Seward et al.
==2190== Using LibVEX rev 1658, a library for dynamic binary translation.
==2190== Copyright (C) 2004-2006, and GNU GPL&#39;d, by OpenWorks LLP.
==2190== Using valgrind-3.2.1, a dynamic binary instrumentation framework.
==2190== Copyright (C) 2000-2006, and GNU GPL&#39;d, by Julian Seward et al.
==2190== For more details, rerun with: -v
==2190==
malloc(10) points to: 0x4022028
malloc(10) points to: 0x4022068
malloc(10) points to: 0x40220a8
malloc(10) points to: 0x40220e8
malloc(10) points to: 0x4022128
malloc(10) points to: 0x4022168
malloc(10) points to: 0x40221a8
malloc(10) points to: 0x40221e8
malloc(10) points to: 0x4022228
malloc(10) points to: 0x4022268
malloc(15) in main: 0x40222a8
==2190==
==2190== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 12 from 1)
==2190== malloc/free: in use at exit: 115 bytes in 11 blocks.
==2190== malloc/free: 11 allocs, 0 frees, 115 bytes allocated.
==2190== For counts of detected errors, rerun with: -v
==2190== searching for pointers to 11 not-freed blocks.
==2190== checked 46,796 bytes.
==2190==
==2190== 15 bytes in 1 blocks are definitely lost in loss record 1 of 2
==2190==    at 0x40053C0: malloc (vg_replace_malloc.c:149)
==2190==    by 0x8048419: main (leak1.c:17)
==2190==
==2190==
==2190== 100 bytes in 10 blocks are definitely lost in loss record 2 of 2
==2190==    at 0x40053C0: malloc (vg_replace_malloc.c:149)
==2190==    by 0x80483C5: leak (leak1.c:6)
==2190==    by 0x8048403: main (leak1.c:15)
==2190==
==2190== LEAK SUMMARY:
==2190==    definitely lost: 115 bytes in 11 blocks.
==2190==      possibly lost: 0 bytes in 0 blocks.
==2190==    still reachable: 0 bytes in 0 blocks.
==2190==         suppressed: 0 bytes in 0 blocks.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####exercise 1:
vmstat is a tool which report system usage statistics, use strace to figure out which /proc/file(s) it uses to generate its output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execve(&amp;quot;/usr/bin/vmstat&amp;quot;, [&amp;quot;vmstat&amp;quot;], [/* 29 vars */]) = 0
brk(0)                                  = 0x96b7000
access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK)      = -1 ENOENT (No such file or directory)
open(&amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=95416, ...}) = 0
mmap2(NULL, 95416, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7f80000
close(3)                                = 0
open(&amp;quot;/lib/libproc-3.2.7.so&amp;quot;, O_RDONLY) = 3
read(3, &amp;quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\320c\304\0004\0\0\0&amp;quot;..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=54212, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7f000
mmap2(0xc44000, 133592, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xc44000
mmap2(0xc51000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xc) = 0xc51000
mmap2(0xc52000, 76248, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xc52000
close(3)                                = 0
open(&amp;quot;/lib/libc.so.6&amp;quot;, O_RDONLY)        = 3
read(3, &amp;quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\320?\261\0004\0\0\0&amp;quot;..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1606808, ...}) = 0
mmap2(0xafe000, 1324452, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xafe000
mmap2(0xc3c000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13e) = 0xc3c000
mmap2(0xc3f000, 9636, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xc3f000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7e000
set_thread_area({entry_number:-1 -&amp;gt; 6, base_addr:0xb7f7e6c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xc3c000, 8192, PROT_READ)     = 0
mprotect(0xaf5000, 4096, PROT_READ)     = 0
munmap(0xb7f80000, 95416)               = 0
uname({sys=&amp;quot;Linux&amp;quot;, node=&amp;quot;localhost.localdomain&amp;quot;, ...}) = 0
brk(0)                                  = 0x96b7000
brk(0x96d8000)                          = 0x96d8000
open(&amp;quot;/proc/stat&amp;quot;, O_RDONLY)            = 3
fstat64(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f97000
read(3, &amp;quot;cpu  14886 15300 97152 608490 41&amp;quot;..., 4096) = 693
read(3, &amp;quot;&amp;quot;, 4096)                       = 0
close(3)                                = 0
munmap(0xb7f97000, 4096)                = 0
ioctl(1, TIOCGWINSZ, {ws_row=36, ws_col=115, ws_xpixel=0, ws_ypixel=0}) = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 4), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f97000
write(1, &amp;quot;procs -----------memory---------&amp;quot;..., 82procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
) = 82
write(1, &amp;quot; r  b   swpd   free   buff  cach&amp;quot;..., 81 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
) = 81
open(&amp;quot;/proc/meminfo&amp;quot;, O_RDONLY)         = 3
lseek(3, 0, SEEK_SET)                   = 0
read(3, &amp;quot;MemTotal:       897068 kB\nMemFre&amp;quot;..., 1023) = 771
open(&amp;quot;/proc/stat&amp;quot;, O_RDONLY)            = 4
read(4, &amp;quot;cpu  14886 15300 97153 608490 41&amp;quot;..., 65535) = 693
open(&amp;quot;/proc/vmstat&amp;quot;, O_RDONLY)          = 5
lseek(5, 0, SEEK_SET)                   = 0
read(5, &amp;quot;nr_anon_pages 29682\nnr_mapped 13&amp;quot;..., 1023) = 803
write(1, &amp;quot; 0  0    120  16980  32852 67407&amp;quot;..., 81 0  0    120  16980  32852 674076    0    0   228   223 1040  432  4 13 78  5  0
) = 81
exit_group(0)                           = ?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above output, we can see, it access /proc/stat and /proc/vmstat for output message.&lt;br /&gt;
####exercise 2
Repeat the ltrace /strace example on wget with ivalid URL, TBD&lt;br /&gt;
####exercise 3
Does valgrind automatically trace child process?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

/* For using fork() */
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

/* Using errono */
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;


void leak()
{
        char *ptr = malloc(10);
        printf(&amp;quot;malloc(10) points to: %p\n&amp;quot;, ptr);
}

int main(void)
{
        pid_t child;
        /* Parent do leak() */
        int i = 0;
        for(i = 0; i&amp;lt;10; i++)
        {
                leak();
        }

        /* Now fork a child process */
        if((child = fork()) &amp;lt; 0) {
                fprintf(stderr, &amp;quot;fork of child failed: %s\n&amp;quot;, strerror(errno));
                return 1;
        }
        else if(child == 0) {
                printf(&amp;quot;Now its in child process\n&amp;quot;);
                sleep(2);
        }
        else {
                // parent will exit immediately !
                printf(&amp;quot;Parent will exit!\n&amp;quot;);
                sleep(1);
                return 0;
        }

        // Only Child comes here
        printf(&amp;quot;Only child comes here!\n&amp;quot;);
        for(i = 0; i&amp;lt;10; i++)
        {
                leak();
        }

        return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We use following command for tracing the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost code]# valgrind --leak-check=full --show-reachable=yes ./memleak_fork
==2561== Memcheck, a memory error detector.
==2561== Copyright (C) 2002-2006, and GNU GPL&#39;d, by Julian Seward et al.
==2561== Using LibVEX rev 1658, a library for dynamic binary translation.
==2561== Copyright (C) 2004-2006, and GNU GPL&#39;d, by OpenWorks LLP.
==2561== Using valgrind-3.2.1, a dynamic binary instrumentation framework.
==2561== Copyright (C) 2000-2006, and GNU GPL&#39;d, by Julian Seward et al.
==2561== For more details, rerun with: -v
==2561==
malloc(10) points to: 0x4022028
malloc(10) points to: 0x4022068
malloc(10) points to: 0x40220a8
malloc(10) points to: 0x40220e8
malloc(10) points to: 0x4022128
malloc(10) points to: 0x4022168
malloc(10) points to: 0x40221a8
malloc(10) points to: 0x40221e8
malloc(10) points to: 0x4022228
malloc(10) points to: 0x4022268
Now its in child process
Parent will exit!
==2561==
==2561== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 12 from 1)
==2561== malloc/free: in use at exit: 100 bytes in 10 blocks.
==2561== malloc/free: 10 allocs, 0 frees, 100 bytes allocated.
==2561== For counts of detected errors, rerun with: -v
==2561== searching for pointers to 10 not-freed blocks.
==2561== checked 46,796 bytes.
==2561==
==2561== 100 bytes in 10 blocks are definitely lost in loss record 1 of 1
==2561==    at 0x40053C0: malloc (vg_replace_malloc.c:149)
==2561==    by 0x8048515: leak (fork.c:15)
==2561==    by 0x8048553: main (fork.c:26)
==2561==
==2561== LEAK SUMMARY:
==2561==    definitely lost: 100 bytes in 10 blocks.
==2561==      possibly lost: 0 bytes in 0 blocks.
==2561==    still reachable: 0 bytes in 0 blocks.
==2561==         suppressed: 0 bytes in 0 blocks.
[root@localhost code]# Only child comes here!
malloc(10) points to: 0x40222a8
malloc(10) points to: 0x40222e8
malloc(10) points to: 0x4022328
malloc(10) points to: 0x4022368
malloc(10) points to: 0x40223a8
malloc(10) points to: 0x40223e8
malloc(10) points to: 0x4022428
malloc(10) points to: 0x4022468
malloc(10) points to: 0x40224a8
malloc(10) points to: 0x40224e8
==2562==
==2562== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 12 from 1)
==2562== malloc/free: in use at exit: 200 bytes in 20 blocks.
==2562== malloc/free: 20 allocs, 0 frees, 200 bytes allocated.
==2562== For counts of detected errors, rerun with: -v
==2562== searching for pointers to 20 not-freed blocks.
==2562== checked 46,796 bytes.
==2562==
==2562== 200 bytes in 20 blocks are definitely lost in loss record 1 of 1
==2562==    at 0x40053C0: malloc (vg_replace_malloc.c:149)
==2562==    by 0x8048515: leak (fork.c:15)
==2562==    by 0x8048553: main (fork.c:26)
==2562==
==2562== LEAK SUMMARY:
==2562==    definitely lost: 200 bytes in 20 blocks.
==2562==      possibly lost: 0 bytes in 0 blocks.
==2562==    still reachable: 0 bytes in 0 blocks.
==2562==         suppressed: 0 bytes in 0 blocks.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above output, we can see valgrid also tracked the child process&amp;rsquo;s memory usage.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming in C of FC tutorial 3</title>
      <link>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-3/</link>
      <pubDate>Tue, 08 Apr 2014 09:41:55 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/08/programming-in-c-of-fc-tutorial-3/</guid>
      <description>&lt;p&gt;###Full Circle C 5
####Callback
Use Call Back function for implementing a calculator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int minus(int a, int b)
{
	return a-b;
}

int add(int a, int b)
{
	return a+b;
}

int multiply(int a, int b)
{
	return a*b;
}

int divide(int a, int b)
{
	return a/b;
}

typedef int (*mathFun)(int, int);

struct operator
{
	char c;
	mathFun f;
};

int main()
{
	struct operator functs[4];
	functs[0].c = &#39;-&#39;; functs[0].f=&amp;amp;minus;
	functs[1].c = &#39;+&#39;; functs[1].f=&amp;amp;add;
	functs[2].c = &#39;*&#39;; functs[2].f=&amp;amp;multiply;
	functs[3].c = &#39;/&#39;; functs[3].f=&amp;amp;divide;
	while(1)
	{
		int a,b,i;
		char c;
		printf(&amp;quot;Enter a:\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
		printf(&amp;quot;Enter b:\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;b);
		printf(&amp;quot;Enter the operator:\n&amp;quot;);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
		i = 0;
		while(i&amp;lt;4)
		{
			if(functs[i].c==c)
			{
				printf(&amp;quot;Result:%d\n&amp;quot;, functs[i].f(a,b));
				break;
			}
			i++;
		}
		if(i == 4)
		{
			printf(&amp;quot;Unkown operator:%c\n&amp;quot;, c);
		}
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Exercise 1
Modify the application to operate on floating point numbers instead of integers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

float  minus(float a, float b)
{
	return a-b;
}

float add(float a, float b)
{
	return a+b;
}

float multiply(float a, float b)
{
	return a*b;
}

float divide(float a, float b)
{
	return a/b;
}

typedef float (*mathFun)(float, float);

struct operator
{
	char c;
	mathFun f;
};

int main()
{
	struct operator functs[4];
	functs[0].c = &#39;-&#39;; functs[0].f=&amp;amp;minus;
	functs[1].c = &#39;+&#39;; functs[1].f=&amp;amp;add;
	functs[2].c = &#39;*&#39;; functs[2].f=&amp;amp;multiply;
	functs[3].c = &#39;/&#39;; functs[3].f=&amp;amp;divide;
	while(1)
	{
		int i;
		float a,b; 
		char c;
		printf(&amp;quot;Enter a:\n&amp;quot;);
		scanf(&amp;quot;%f&amp;quot;, &amp;amp;a);
		printf(&amp;quot;Enter b:\n&amp;quot;);
		scanf(&amp;quot;%f&amp;quot;, &amp;amp;b);
		printf(&amp;quot;Enter the operator:\n&amp;quot;);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
		i = 0;
		while(i&amp;lt;4)
		{
			if(functs[i].c==c)
			{
				printf(&amp;quot;Result:%f\n&amp;quot;, functs[i].f(a,b));
				break;
			}
			i++;
		}
		if(i == 4)
		{
			printf(&amp;quot;Unkown operator:%c\n&amp;quot;, c);
		}
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Exercise 2
Extend the calculator with the possibility for the user to enter &amp;lsquo;q&amp;rsquo; for quit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int minus(int a, int b)
{
	return a-b;
}

int add(int a, int b)
{
	return a+b;
}

int multiply(int a, int b)
{
	return a*b;
}

int divide(int a, int b)
{
	return a/b;
}

typedef int (*mathFun)(int, int);

struct operator
{
	char c;
	mathFun f;
};

int main()
{
	struct operator functs[4];
	functs[0].c = &#39;-&#39;; functs[0].f=&amp;amp;minus;
	functs[1].c = &#39;+&#39;; functs[1].f=&amp;amp;add;
	functs[2].c = &#39;*&#39;; functs[2].f=&amp;amp;multiply;
	functs[3].c = &#39;/&#39;; functs[3].f=&amp;amp;divide;
	char q;
	do
	{
		int a,b,i;
		char c;
		printf(&amp;quot;Enter a:\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
		printf(&amp;quot;Enter b:\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;b);
		printf(&amp;quot;Enter the operator:\n&amp;quot;);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
		i = 0;
		while(i&amp;lt;4)
		{
			if(functs[i].c==c)
			{
				printf(&amp;quot;Result:%d\n&amp;quot;, functs[i].f(a,b));
				break;
			}
			i++;
		}
		if(i == 4)
		{
			printf(&amp;quot;Unkown operator:%c\n&amp;quot;, c);
		}
		printf(&amp;quot;Enter q for quit! Others for continue\n&amp;quot;);
		scanf(&amp;quot;%c&amp;quot;,&amp;amp;q);
		scanf(&amp;quot;%c&amp;quot;,&amp;amp;q);
	}
	while(q != &#39;q&#39;);
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Exercise 4
Modify the application that, instead of entering characters, the user is able to enter “5 plus 6” or “6 minus 5”. In order to do this, you will need to adapt the structure to hold a string as the operator, and, instead of reading a character, you will need to read a string. Extra credit if you manage to do this without buffer overrun issues (see man getline) and memory leaks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int minus(int a, int b)
{
	return a-b;
}

int add(int a, int b)
{
	return a+b;
}

int multiply(int a, int b)
{
	return a*b;
}

int divide(int a, int b)
{
	return a/b;
}

typedef int (*mathFun)(int, int);

struct operator
{	char c[20];
	mathFun f;
};

int main()
{
	struct operator functs[4];
	strcpy(functs[0].c, &amp;quot;minus&amp;quot;);
	functs[0].f=&amp;amp;minus;
	strcpy(functs[1].c, &amp;quot;add&amp;quot;);
	functs[1].f=&amp;amp;add;
	strcpy(functs[2].c, &amp;quot;mul&amp;quot;);
	functs[2].f=&amp;amp;multiply;
	strcpy(functs[3].c, &amp;quot;div&amp;quot;);
	functs[3].f=&amp;amp;divide;
	while(1)
	{
		int a,b,i;
		char c[20];
		printf(&amp;quot;Enter a:\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
		printf(&amp;quot;Enter b:\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;b);
		printf(&amp;quot;Enter the operator:\n&amp;quot;);
		scanf(&amp;quot;%s&amp;quot;, c);
		i = 0;
		while(i&amp;lt;4)
		{
			int result = strcmp(functs[i].c, c);
			if(result == 0)
			{
			printf(&amp;quot;Result is :%d\n&amp;quot;, functs[i].f(a,b));
			break;
			}
			i++;
		}
		if(i == 4)
		{
			printf(&amp;quot;Unkown operator:%s\n&amp;quot;, c);
		}
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Programming in C of FC tutorial 2</title>
      <link>http://purplepalmdash.github.io/2014/04/07/programming-in-c-of-fc-tutorial-2/</link>
      <pubDate>Mon, 07 Apr 2014 17:43:26 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/07/programming-in-c-of-fc-tutorial-2/</guid>
      <description>&lt;p&gt;###Full Circle C 3
####Exercise 1
Collect all the code snippets on this page and turn them into the working program&lt;br /&gt;
Pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void)
{
	int anInt = 5;

	int *anIntPointer = &amp;amp;anInt;

	printf(&amp;quot;Address: %p Value: %d \n&amp;quot;, &amp;amp;anInt, anInt);

	printf(&amp;quot;Address of Pointer: %p Address: %p Value: %d\n&amp;quot;, &amp;amp;anIntPointer, anIntPointer, *anIntPointer);

	printf(&amp;quot;Size of pointer: %d, size of int: %d\n&amp;quot;, sizeof(anIntPointer), sizeof(anInt));

	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;array.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void)
{
	int i;
	int anIntArray[5] = {10, 20, 30, 40, 50};

	printf(&amp;quot;Address of Array: %p \n&amp;quot;, &amp;amp;anIntArray);

	printf(&amp;quot;Size of Array: %d\n&amp;quot;, sizeof(anIntArray));

	for(i = 0; i&amp;lt;sizeof(anIntArray)/sizeof(int); i++)
	{
		printf(&amp;quot;Index: %x Address: %p Value: %d, Value: %d\n&amp;quot;, i, &amp;amp;anIntArray[i], anIntArray[i], *(anIntArray+i));
	}

	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
	int i;
	char aChar = &#39;c&#39;;
	char * aString = &amp;quot;Hello&amp;quot;;

	printf(&amp;quot;Address: %p value: %c size: %d\n&amp;quot;, &amp;amp;aChar, aChar, sizeof(aChar));

	printf(&amp;quot;Address of the string: %p\n&amp;quot;, &amp;amp;aString);

	printf(&amp;quot;Size of String: %d\n&amp;quot;, strlen(aString));

	printf(&amp;quot;Value: %s\n&amp;quot;, aString);

	for(i = 0; i&amp;lt;=strlen(aString); i++)
	{
		printf(&amp;quot;Index:%x Address: %p, Value:%c\n&amp;quot;, i, &amp;amp;aString[i], aString[i]);
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
struct aStruct_def
{
	int intMember;
	int * intPointer;
	char charMember;
	char ** stringPointer;
};

int main(void)
{
	struct aStruct_def aStruct;
	struct aStruct_def *aStructPointer;
	int anInt = 5; 
	char *aString = &amp;quot;Hello&amp;quot;;

	printf(&amp;quot;Address: %p Size: %d\n&amp;quot;, &amp;amp;aStruct, sizeof(struct aStruct_def));

	printf(&amp;quot;%p %p %p %p\n&amp;quot;, &amp;amp;aStruct.intMember, &amp;amp;aStruct.intPointer, &amp;amp;aStruct.charMember, &amp;amp;aStruct.stringPointer);

	aStruct.intMember = 6;
	aStruct.intPointer = &amp;amp;anInt;
	aStruct.charMember = &#39;k&#39;;
	aStruct.stringPointer = &amp;amp;aString;

	aStructPointer = &amp;amp;aStruct;

	printf(&amp;quot;Member of struct: %d\n&amp;quot;, (*aStructPointer).intMember);
	printf(&amp;quot;Member of struct: %d\n&amp;quot;, *(*aStructPointer).intPointer);
	printf(&amp;quot;Member of struct: %d\n&amp;quot;, aStructPointer-&amp;gt;intMember);
	printf(&amp;quot;Member of struct: %d\n&amp;quot;, *aStructPointer-&amp;gt;intPointer);
	printf(&amp;quot;Member of struct: %s\n&amp;quot;, *aStructPointer-&amp;gt;stringPointer);

	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Exercise 2
Implement strlen yourself use a while() loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int mystrlen(char *strings)
{
	int i = 0;
	while(strings[i] != &#39;\0&#39;)
	{
		i++;
	}
	return i;
}

int main()
{
	char *a = &amp;quot;Hello World&amp;quot;;
	printf(&amp;quot;%s &#39;s length is %d\n&amp;quot;, a, mystrlen(a));
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Exercise 3
A C application typically has &amp;lsquo;int main(int argc, char **argv)&amp;rsquo; as it&amp;rsquo;s main prototype, here argc contains the number of strings passed to the application, and argc is an array of argc strings. Write a small application which prints all arguments given to the application. What is stored in argv[0] ?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
	int i = 0; 
	for(i = 0; i&amp;lt;argc; i++)
	{
		printf(&amp;quot;arg %d is %s\n&amp;quot;, i, argv[i]);
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Programming In C New Words</title>
      <link>http://purplepalmdash.github.io/2014/04/07/programming-in-c-new-words/</link>
      <pubDate>Mon, 07 Apr 2014 16:02:47 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/07/programming-in-c-new-words/</guid>
      <description>&lt;p&gt;###Programming In C
intermediate: 中级的&lt;br /&gt;
hereby: 特此&lt;br /&gt;
scary: 恐慌的，提心吊胆的&lt;br /&gt;
de facto (法)，事实上的&lt;br /&gt;
span: 跨越&lt;br /&gt;
interpreted: 可交互的&lt;br /&gt;
fanatic: 狂热者&lt;br /&gt;
novice: 新手，入门者&lt;br /&gt;
concrete: 实际的&lt;br /&gt;
prime number: 素数，质数
ternary: 三重的，三元的&lt;br /&gt;
intrusive: 侵入的，打扰的&lt;br /&gt;
grind: 磨难，磨碎，折磨&lt;br /&gt;
confessed: 坦白的&lt;br /&gt;
scary: 提心吊胆的，胆小的&lt;br /&gt;
apropos: 恰好的&lt;br /&gt;
grasp: 掌握&lt;br /&gt;
instalment: 分期付款的&lt;br /&gt;
gibberish: 乱语，快速而不清楚的话语&lt;br /&gt;
condense: 电容器&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming in C of FC tutorial</title>
      <link>http://purplepalmdash.github.io/2014/04/07/programming-in-c-of-fc-tutorial/</link>
      <pubDate>Mon, 07 Apr 2014 16:02:08 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/07/programming-in-c-of-fc-tutorial/</guid>
      <description>&lt;p&gt;###Programming In C
GCC&amp;rsquo;s funcitionality:&lt;br /&gt;
gcc command calls a compiler(which transforms a higher level language into assembler), an assembler translates assembler into object files(machine instructions), and a linker, which combines several object files into an executable.&lt;/p&gt;

&lt;p&gt;launchpad.net is a unique collaboration and hosting platform for free software. &lt;a href=&#34;http://www.launchpad.net&#34;&gt;http://www.launchpad.net&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;###Programming In C II
Example code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#define VERSION &amp;quot;1.0&amp;quot;

/* 
 * Runs a prime check on a given integer, return
 * 1 when the integer is a prime number, 0 otherwise
 */
int isPrime(int prime)
{
	int count = 2;

	// Catch two special cases 
	if(prime == 1)
	{
		return 0;
	}
	else if(prime == 2)
	{
		return 1;
	}
	else
	{
		while(prime % count != 0 &amp;amp;&amp;amp; count*count&amp;lt;=prime)
		{
			count++;
		}
		return (prime%count==0)?0:1;
	}
}
/*
 * Print version information
 */
void printVersion()
{
	printf(&amp;quot;Primality checker version %s\n&amp;quot;, VERSION);
	printf(&amp;quot;Compiled on %s %s\n&amp;quot;, __DATE__, __TIME__);
}

int main()
{
	int i = 1;
	const int max_prime = 2500;

	printVersion();

	for (i = 1; i&amp;lt;max_prime; i++)
	{
		if(isPrime(i))
		{
			printf(&amp;quot;%d is prime\n&amp;quot;, i);
		}
		else
		{
			printf(&amp;quot;%d is not prime\n&amp;quot;, i);
		}
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Execise 1
Rewrite the for loop in the main() function so it becomes a while loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//for (i = 1; i&amp;lt;max_prime; i++)
	while(i&amp;lt;max_prime)
	{
		if(isPrime(i))
		{
			printf(&amp;quot;%d is prime\n&amp;quot;, i);
		}
		else
		{
			printf(&amp;quot;%d is not prime\n&amp;quot;, i);
		}
		i++;
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Execise 2
Rewrite the if&amp;hellip;else if&amp;hellip;else structure in the isPrime() function to a switch&amp;hellip;case structure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	int count = 2;
	int returnvalue = 0;

	// Catch two special cases 
	switch(prime)
	{
		case 1:
			returnvalue = 0;
			break;
		case 2:
			returnvalue = 1;
			break;
		default:
			while(prime % count != 0 &amp;amp;&amp;amp; count*count &amp;lt;= prime)
			{
				count++;
			}
			returnvalue =  (prime % count == 0)?0:1;

	}
	return returnvalue;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Execise 3
Rewrite the ternary(condition)?value1:value2 to an if..else structure&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//return (prime%count==0)?0:1;
if(prime%count == 0)
{
	return 0;
}
else
{
	return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Execise 4
Rewrite the if&amp;hellip;else in the main() funciton to make sure the ternary operator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
if(isPrime(i))
{
	printf(&amp;quot;%d is prime\n&amp;quot;, i);
}
else
{
	printf(&amp;quot;%d is not prime\n&amp;quot;, i);
}
*/
printf(&amp;quot;%d %s prime\n&amp;quot;, i, isPrime(i)?&amp;quot;is&amp;quot;:&amp;quot;is not&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Execise 5
Replace the isPrime() function by an isOdd() function which return 1 when a given integer is odd.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int isOdd(int odd)
{
	if(odd == 1)
	{
		return 1;
	}
	else
	{
		if(odd%2 == 0)
		{
			return 0;
		}
		else
		{
			return 1;
		}
	}
}

/* Called via */
if(isOdd(i))
{
	printf(&amp;quot;%d is Odd\n&amp;quot;, i);
}
else
{
	printf(&amp;quot;%d is not Odd\n&amp;quot;, i);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Execise 6
Design and write a small application which print out the n Fibonacci sequence, where n should be easily modifiable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

/* The formula is like
 * a(n+2) = a(n)+a(n+1)
 * while when a1 = 1, a2 =1
 */

int Fib(int fib)
{
	if(fib == 1)
	{
		return 1;
	}
	else if(fib == 2)
	{
		return 1;
	}
	else
	{
		return (Fib(fib-1) + Fib(fib-2));
	}
}

int main(int argc, char **argv)
{
	int i;
	int j = 1;

	printf(&amp;quot;Please input an integer number\n&amp;quot;);
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;i);

	printf(&amp;quot;The Fibonacci sequence is: \n&amp;quot;);
	for( j = 1; j &amp;lt;= i; j++)
	{
		printf(&amp;quot;a[%d] is %d.\n&amp;quot;, j, Fib(j));
	}

	return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we use recursion here, when the n is too big, the calculation maybe very slow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reading Digest of FC3</title>
      <link>http://purplepalmdash.github.io/2014/04/07/reading-digest-of-fc3/</link>
      <pubDate>Mon, 07 Apr 2014 14:50:58 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/07/reading-digest-of-fc3/</guid>
      <description>&lt;p&gt;###Full Circle 3
1. Page 6 of cn version: DSL(Damn Small Linux), &lt;a href=&#34;http://www.damnsmalllinux.org&#34;&gt;http://www.damnsmalllinux.org&lt;/a&gt;, which could be run on 16MB memory&amp;rsquo;s 486 computer, try it.&lt;br /&gt;
2. Page&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FC3 New Words</title>
      <link>http://purplepalmdash.github.io/2014/04/07/fc3-new-words/</link>
      <pubDate>Mon, 07 Apr 2014 14:45:26 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/07/fc3-new-words/</guid>
      <description>&lt;p&gt;###Full Circle 3
stunning: 令人惊奇的事物&lt;br /&gt;
reveal: 揭露&lt;br /&gt;
footrest: 搁脚物&lt;br /&gt;
fusion: 融化&lt;br /&gt;
compiz+beryl = Compiz Fusion&lt;br /&gt;
trawl: 用拖网捕鱼&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reading Digest of FC2</title>
      <link>http://purplepalmdash.github.io/2014/04/06/reading-digest-of-fc2/</link>
      <pubDate>Sun, 06 Apr 2014 20:41:10 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/06/reading-digest-of-fc2/</guid>
      <description>&lt;p&gt;###Full Circle 2
Things to be done:&lt;br /&gt;
1. Page 3, Visit linuxgeekery?&lt;br /&gt;
2. Page 4, OpenMOKO, its recent status. Try to visit &lt;a href=&#34;www.linuxinsider.com&#34;&gt;www.linuxinsider.com&lt;/a&gt;&lt;br /&gt;
3. Page 5, UbuntuHomeServer? &lt;a href=&#34;www.ubuntuhomeserver.org&#34;&gt;www.ubuntuhomeserver.org&lt;/a&gt;&lt;br /&gt;
4. Page 16, try VPN, use VPN to reach back home.&lt;br /&gt;
5. Page 25, What is GEDCOM?&lt;br /&gt;
6. Page 27, What is LDS church?&lt;br /&gt;
7. Page 28, Still , try Gramps.&lt;br /&gt;
8. Page 29, ipod support on Ubuntu, libgpod. amaroK&lt;br /&gt;
9. Page 31, try flock, democracy player, songbird, inkscape&lt;br /&gt;
10. Page 34, try game tremulous.&lt;br /&gt;
11. Page 36, try ubuntustudio theme.&lt;br /&gt;
12. Page 37, try to install these applets and integrate them with awesome.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FC2 New Words</title>
      <link>http://purplepalmdash.github.io/2014/04/06/fc2-new-words/</link>
      <pubDate>Sun, 06 Apr 2014 20:34:16 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/06/fc2-new-words/</guid>
      <description>&lt;p&gt;###Full Circle 2
affiliate: 归纳，使附属&lt;br /&gt;
endorse: 签署，赞同，认可&lt;br /&gt;
mean-machine: 概念机&lt;br /&gt;
editorial: 编辑的，社论的&lt;br /&gt;
dose: 剂量&lt;br /&gt;
sarcasm: 嘲讽，挖苦&lt;br /&gt;
slip: 滑动，slipped，被忽略&lt;br /&gt;
niggle: 拘泥小节&lt;br /&gt;
darter: 飞奔者，投掷者&lt;br /&gt;
infringement: 侵犯，违反&lt;br /&gt;
speculation: 投机，推荐，思索，投机买卖&lt;br /&gt;
litigation: 诉讼，起诉&lt;br /&gt;
barrier: 障碍物&lt;br /&gt;
sentiment: 观点，情绪&lt;br /&gt;
interoperability: 互用性，互操作性&lt;br /&gt;
imminent: 即将到来的，迫近的&lt;br /&gt;
Venezuelan: 委内瑞拉&lt;br /&gt;
Bolivarian: 玻利瓦尔&lt;br /&gt;
KDE: K Desktop Environment&lt;br /&gt;
GNOME: GNU Object Model Environment&lt;br /&gt;
chunk: 块&lt;br /&gt;
prerequisite: 先决条件&lt;br /&gt;
wobbling: 颤抖的&lt;br /&gt;
eyecandy: 视觉糖果&lt;br /&gt;
tray: 任务栏&lt;br /&gt;
purge: 移除&lt;br /&gt;
decorator: 装饰，装修&lt;br /&gt;
nerds: 书呆子&lt;br /&gt;
pinkie: 小手指&lt;br /&gt;
imprint: 加痕迹的，刻上记号的&lt;br /&gt;
tattoo: 纹身，刻花样的&lt;br /&gt;
dip: 舀取， 把&amp;hellip;浸入&lt;br /&gt;
toe: 脚趾，足尖&lt;br /&gt;
toy: 玩弄，调戏&lt;br /&gt;
evolve: 发展，进化&lt;br /&gt;
podcast: 播客&lt;br /&gt;
zealot: 狂热者，犹太教狂热信徒&lt;br /&gt;
pingu: 企鹅家族（动画片名)&lt;br /&gt;
pimping: 拉皮条，很小的，小气的&lt;br /&gt;
nail salon: 美甲沙龙&lt;br /&gt;
pingu-pimping: 为企鹅家族拉皮条&lt;br /&gt;
Dirty Harry: 《警探哈里》，美国70年代“新警察电影”的代表作，塑造一个典型的硬派新警察形象&lt;br /&gt;
spam: 罐头猪肉，垃圾邮件&lt;br /&gt;
savvy: 悟性，理解能力，懂行的人&lt;br /&gt;
wizz: 奇才，专家&lt;br /&gt;
alley: 小径&lt;br /&gt;
freak: 怪人，怪事，畸形人&lt;br /&gt;
fiancee: 未婚妻&lt;br /&gt;
is right up the alley: 正符合我的要求&lt;br /&gt;
swipe: 猛击，偷窃，夺得&lt;br /&gt;
tetris: 俄罗斯方块&lt;br /&gt;
worn: 疲倦的，用旧的&lt;br /&gt;
worn-down:&lt;br /&gt;
cyber-granny:  电脑奶奶, cyber做前缀代表科技的，电脑的，之类&lt;br /&gt;
pasture: 草地，牧场，牧草，放牧&lt;br /&gt;
defective: 不完美的，有缺陷的&lt;br /&gt;
bode: 停留，继续，遭到，预示, bide的过去式&lt;br /&gt;
cheque: 支票&lt;br /&gt;
mallware: 广告&lt;br /&gt;
user-boo-boo: 用户的反感&lt;br /&gt;
dispose: 处理，处置，安排&lt;br /&gt;
clog: 阻塞&lt;br /&gt;
toaster: 烤面包机，烤面包的人&lt;br /&gt;
easy as firing up a toaster: 像用烤面包机加热面包一样简单？&lt;br /&gt;
bongos: 邦高鼓&lt;br /&gt;
rumble: 隆隆作响&lt;br /&gt;
uncover: 发现，揭开，揭露&lt;br /&gt;
goodies: 好吃的东西，老妇人，伪君子&lt;br /&gt;
pentagon: 五角星&lt;br /&gt;
memo: 备忘录&lt;br /&gt;
trill: 用颤声唱，用颤声说&lt;br /&gt;
trilled: 激动&lt;br /&gt;
frank: 坦白，直白&lt;br /&gt;
grin: 咧着嘴笑&lt;br /&gt;
utter: 发出，表达&lt;br /&gt;
wayward: 任性的，不规则的&lt;br /&gt;
VPN; Virtual Private Networking&lt;br /&gt;
presario: 自由人&lt;br /&gt;
dart: 镖，飞镖&lt;br /&gt;
stylish: 时髦的&lt;br /&gt;
pamphlet: 小册子&lt;br /&gt;
power cord: 电源线&lt;br /&gt;
pad: 填充&lt;br /&gt;
workhorse: 重负荷机器&lt;br /&gt;
lid: 盖子&lt;br /&gt;
clicky: 滴答的&lt;br /&gt;
tactile: 触觉的，有触觉的&lt;br /&gt;
intervention: 介入，调停，妨碍&lt;br /&gt;
partially: 局部的，部分地&lt;br /&gt;
optical: 光学的&lt;br /&gt;
spike: 阻止&lt;br /&gt;
immune: 免疫&lt;br /&gt;
dang: 讨厌的&lt;br /&gt;
nail: 钉，使固定&lt;br /&gt;
avid: 贪婪的&lt;br /&gt;
enthusiast: 狂热者，热心家&lt;br /&gt;
Corel Linux : Corel corporation&lt;br /&gt;
coral: 珊瑚&lt;br /&gt;
outdoors: 户外&lt;br /&gt;
index finger: 食指&lt;br /&gt;
pull-cart: 拖车&lt;br /&gt;
obscure: 难懂的，晦涩的&lt;br /&gt;
slack: 松弛的，疏忽的，缓慢的&lt;br /&gt;
monty: 必定的事物，尤指赛马时必赢的马&lt;br /&gt;
appropriate: 恰当的&lt;br /&gt;
holy grail: 圣杯&lt;br /&gt;
fictional: 虚构的&lt;br /&gt;
patronimic: 教名&lt;br /&gt;
cohesion: 内聚力&lt;br /&gt;
ego: 自我，自负，自我意识&lt;br /&gt;
concensus:&lt;br /&gt;
compromise: 让步&lt;br /&gt;
deficiency: 缺陷，缺点，不足&lt;br /&gt;
adhere: 坚持，依附&lt;br /&gt;
recruit: 招聘，补充，聘用&lt;br /&gt;
bounty: 发给……奖金&lt;br /&gt;
overwhelm: 压倒，淹没，受打击&lt;br /&gt;
aggregator: 聚合器&lt;br /&gt;
appeal: 呼吁，恳求&lt;br /&gt;
recipe: 食谱，处方，秘诀&lt;br /&gt;
landscape: 风景，景色，山水&lt;br /&gt;
fiddle: 瞎搞，拉小提琴&lt;br /&gt;
dapper: 短小精悍的&lt;br /&gt;
drake:  公鸭&lt;br /&gt;
premium: 保险费，额外费用，奖金&lt;br /&gt;
lexmark: 利盟公司&lt;br /&gt;
stingy: 小气，吝啬&lt;br /&gt;
flock: 成群而行&lt;br /&gt;
democracy: 民主，民主政治&lt;br /&gt;
mash: 饲料&lt;br /&gt;
noob: newbie，新手&lt;br /&gt;
stumble: 踌躇，蹒跚&lt;br /&gt;
intrigue: 用诡计取得，激起……的兴趣&lt;br /&gt;
informative: 教育性的，有益的&lt;br /&gt;
polish: 优雅，精良&lt;br /&gt;
whopper: 弥天大谎&lt;br /&gt;
UV: 紫外线指数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FC1 reading digest</title>
      <link>http://purplepalmdash.github.io/2014/04/06/fc1-reading-digest/</link>
      <pubDate>Sun, 06 Apr 2014 20:10:15 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/04/06/fc1-reading-digest/</guid>
      <description>&lt;p&gt;Following is the reading digests for reading the FullCircle 1:&lt;br /&gt;
1. Page 5, remember visit &lt;a href=&#34;www.ubuntutribe.com&#34;&gt;www.ubuntutribe.com&lt;/a&gt; for recent updates for Ubuntu Tribe Movie.&lt;br /&gt;
2. Page 6, OLPC&amp;rsquo;s current status?&lt;br /&gt;
3. Page 19, Scribus series.&lt;br /&gt;
4. Page 18, MythTV on Ubuntu.&lt;br /&gt;
5. Page 29, try GRAMPS, and try to read its sourcecode, and its implementation of the relationships. Its relationship could also be applied to the company structure. And the relationship representation, I mean, its images are well described as the relationship.&lt;br /&gt;
6. Page 34, Deluge&amp;rsquo;s author interview is very good. Then we can also view his code and see deluge&amp;rsquo;s present and its comparison to other torrent software, seems azura is vanished?&lt;br /&gt;
7. Page 38, Burn your DVD into other formats, for example, mp3 or other videos.&lt;br /&gt;
8. Page 38, My story says beryl, and here they also said beryl, and two websites &lt;a href=&#34;www.gnome-look.org&#34;&gt;www.gnome-look.org&lt;/a&gt; and &lt;a href=&#34;www.kde-look.org&#34;&gt;www.kde-look.org&lt;/a&gt;, try to visit and get its latest status.&lt;br /&gt;
9. Page 39, try to customize your own desktop like the author&amp;rsquo;s.&lt;br /&gt;
10. Page 40, game, battle for wesnoth and neverball try.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>