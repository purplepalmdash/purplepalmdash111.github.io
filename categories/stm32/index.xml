<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stm32 on Dash</title>
    <link>http://purplepalmdash.github.io/categories/stm32/</link>
    <description>Recent content in Stm32 on Dash</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Dec 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://purplepalmdash.github.io/categories/stm32/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GPIO Advanced in STM32</title>
      <link>http://purplepalmdash.github.io/2013/12/01/gpio-advanced-in-stm32/</link>
      <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/01/gpio-advanced-in-stm32/</guid>
      <description>&lt;p&gt;直接操作寄存器的好处，最主要的就是看中它的快。缺点在于比较晦涩，因为你需要了解到实现的底层。在官方库中，我们可以找到如下的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h:
#define PERIPH_BASE           ((uint32_t)0x40000000) /*!&amp;lt; Peripheral base address in the alias region */
//./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h:
#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
//./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h:
#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
//./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h:
#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
// Definition of the GPIO Types
/** 
  * @brief General Purpose I/O
  */

typedef struct
{
  __IO uint32_t CRL;
  __IO uint32_t CRH;
  __IO uint32_t IDR;
  __IO uint32_t ODR;
  __IO uint32_t BSRR;
  __IO uint32_t BRR;
  __IO uint32_t LCKR;
} GPIO_TypeDef;

/**
 * IO definitions
 *
 * define access restrictions to peripheral registers
 */

#ifdef __cplusplus
  #define     __I     volatile                /*!&amp;lt; defines &#39;read only&#39; permissions      */
#else
  #define     __I     volatile const          /*!&amp;lt; defines &#39;read only&#39; permissions      */
#endif
#define     __O     volatile                  /*!&amp;lt; defines &#39;write only&#39; permissions     */
#define     __IO    volatile                  /*!&amp;lt; defines &#39;read / write&#39; permissions   */
;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面就可以基本看出GPIO的相关知识。在GPIO的使用中我们需要注意7个寄存器：&lt;br /&gt;
CRL, CRH, IDR, ODR, BSRR, BRR, LCKR.&lt;br /&gt;
使用起来很简单，直接调用相应的寄存器操作就好：&lt;br /&gt;
GPIOA-&amp;gt;CRL=0x00;&lt;br /&gt;
寄存器的定义在手册中有详细的介绍。简单的说，CRL和CRH被称之为Configuration Register， 配置寄存器，而IDR和ODR则是数据寄存器，一个是INPUT一个是OUTPUT。 置位/复位寄存器BSRR，还有一个16位的复位寄存器BRR， 还有一个32位的锁定寄存器LCKR，设置好对应的寄存器则可执行相应的操作。&lt;/p&gt;

&lt;p&gt;输入和输出操作可以直接操作寄存器，例如点亮和熄灭LED都是可以直接用操作寄存器来完成。而对键盘的操作，则是读入值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#define GET_LEFT()	(!(GPIOD-&amp;gt;IDR&amp;amp;GPIO_Pin_3)) 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;能使用库函数的场合，除非对IO要求非常高，否则不建议直接操作寄存器。因为出错误的概率会远远增大。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>STM32 and 25F080</title>
      <link>http://purplepalmdash.github.io/2013/12/01/stm32-and-25f080/</link>
      <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/01/stm32-and-25f080/</guid>
      <description>&lt;p&gt;SST25F080,高达 1M 字节的串行 FLASH 存储器,此芯片为-50 版,即 SPI 速度可达到 50M,利用 STM32 的最高速 SPI 接口(36M),读写速度绝对不比并行 FLASH 慢.&lt;br /&gt;
连线图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/25f080.jpg&#34; alt=&#34;25f080.jpg&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RTC on STM32</title>
      <link>http://purplepalmdash.github.io/2013/11/30/rtc-on-stm32/</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/30/rtc-on-stm32/</guid>
      <description>&lt;p&gt;RTC(Real Time Clock) 在STM32中可以理解为内置的一个部件，和传说中的DS1302是有差别的。尽管官方发布的程序可以将RTC搞成一个万年历。&lt;br /&gt;
###配置RTC
RTC需要顺带使用后备寄存器， 因为RTC是一个简单的秒中断定时器，关于年日月分秒的信息需要在掉电保存时依然放在某个地方，这个地方就是STM32的后备寄存器。配置好以后，尽管系统关电，依靠板子上的后备电池，依然可以保存32768的晶振和后备寄存器的数据。&lt;br /&gt;
配置RTC的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#include &amp;quot;stm32f10x_bkp.h&amp;quot;
	#include &amp;quot;stm32f10x_pwr.h&amp;quot;
	#include &amp;quot;stm32f10x_rtc.h&amp;quot;
	//使能一些外设
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
		PWR_BackupAccessCmd(ENABLE);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###判断RTC是否被配置过
下面的函数被用于判断RTC是否被配置过：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**************************************************************
** 函数名:TestRtc
** 功能:测试RTC用
** 注意事项:用于显示RTC是否已经设置过.
***************************************************************/
void TestRtc(void)
{
	if(RTC_Blank)
	{
		USART1_Puts(&amp;quot;The Time is not set\r\n&amp;quot;);
	}
	else
	{
		USART1_Puts(&amp;quot;Time Setted.\r\n&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数判断RTC_Blank全局变量的值，而全局变量的值则在配置RTC的时候被设定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void RTC_Configuration(void)
{
  //......
	if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
		{
	//......
			RTC_Blank=1;	//这个标志代表RTC是没有预设的(或者说是没有上纽扣电池)
	
		}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果RTC后备寄存器的值为设定为0xA5A5，则代表RTC已经被设置过。否则，我们认为它处于未被设置过的状态。&lt;br /&gt;
###使用RTC的秒中断
在NVIC中，需要有下列的定义，以标识RTC的秒中断。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/* RTC */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&amp;amp;NVIC_InitStructure);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的中断响应例程则定义在stm32f10x_it.c中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*******************************************************************************
* Function Name  : RTC_IRQHandler    RTC中断
* Description    : 
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
extern volatile bool Sec;	//1S标志
void RTC_IRQHandler(void)
{
	if(RTC_GetITStatus(RTC_IT_SEC) != RESET) //RTC发生了秒中断（也有可能是溢出或者闹钟中断)
	{
		RTC_ClearITPendingBit(RTC_IT_SEC);
		Sec=TRUE;
		
		//以免RTC计数溢出,这里限制了RTC计数值的大小.0x0001517f实际就是一天的秒数
		if(RTC_GetCounter() &amp;gt;= 0x0001517f)	
		{
			RTC_SetCounter(0x0);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在main.c中，则根据Sec的值来闪烁LED1灯。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for(;;)
	{
		if(Sec == 1)
		{
			Sec = 0;
			GPIOA-&amp;gt;ODR^=GPIO_Pin_8;
		}
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for(;;)
	{
		if(Sec == 1)
		{
			Sec = 0;
			GPIOA-&amp;gt;ODR^=GPIO_Pin_8;
		}
	}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>STM32中的Systick</title>
      <link>http://purplepalmdash.github.io/2013/11/30/stm32zhong-de-systick/</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/30/stm32zhong-de-systick/</guid>
      <description>&lt;p&gt;Cortx-M3特有的SysTick可以很方便的实现定时。系统始终的频率和开启系统时钟中断主要在RCC.c里进行设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//SYSTICK分频--1ms的系统时钟中断
	if (SysTick_Config(SystemCoreClock / 1000))
  	{
  	  	/* Capture error */
    	while (1);
  	}
// The definition of the SysTick_Config:

/**
 * @brief  Initialize and start the SysTick counter and its interrupt.
 *
 * @param   ticks   number of ticks between two interrupts
 * @return  1 = failed, 0 = successful
 *
 * Initialise the system tick timer and its interrupt and start the
 * system tick timer / counter in free running mode to generate 
 * periodical interrupts.
 */

/*
  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
  *                                  by the user application to setup the SysTick 
  *                                  timer or configure other parameters.
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　系统时钟SYSCLK，它是供STM32中绝大部分部件工作的时钟源。系统时钟可选择为PLL输出、HSI或者HSE。系统时钟最大频率为72MHz，它通过AHB分频器分频后送给各模块使用，AHB分频器可选择1、2、4、8、16、64、128、256、512分频。其中AHB分频器输出的时钟送给5大模块使用：&lt;br /&gt;
　　①、送给AHB总线、内核、内存和DMA使用的HCLK时钟。&lt;br /&gt;
　　②、通过8分频后送给Cortex的系统定时器时钟。&lt;br /&gt;
　　③、直接送给Cortex的空闲运行时钟FCLK。&lt;br /&gt;
　　④、送给APB1分频器。APB1分频器可选择1、2、4、8、16分频，其输出一路供APB1外设使用(PCLK1，最大频率36MHz)，另一路送给定时器(Timer)2、3、4倍频器使用。该倍频器可选择1或者2倍频，时钟输出供定时器2、3、4使用。&lt;br /&gt;
　　⑤、送给APB2分频器。APB2分频器可选择1、2、4、8、16分频，其输出一路供APB2外设使用(PCLK2，最大频率72MHz)，另一路送给定时器(Timer)1倍频器使用。该倍频器可选择1或者2倍频，时钟输出供定时器1使用。另外，APB2分频器还有一路输出供分频器使用，分频后送给ADC模块使用。ADC分频器可选择为2、4、6、8分频。&lt;br /&gt;
Cortex-M3允许为SysTick提供2个时钟源以供选择，第一个是内核的“自由运行时钟”FCLK，“自由”表现在它不是来自系统时钟HCLK，因此在系统时钟停止时，FCLK也能继续运行。第2个是一个外部的参考时钟，但是使用外部时钟时，因为它在内部是通过FCLK来采样的，因此其周期必须至少是FCLK的两倍（采样定理）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*******************************************************************************
* Function Name  : SysTickHandler
* Description    :系统时钟，一般调教到1MS中断一次
*******************************************************************************/

void SysTick_Handler(void)
{
	if(Timer1)
		Timer1--;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timer1 为全局变量,我们将设置这个全局变量，以决定其定时期限。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/********************************************
**函数名:SysTickDelay
**功能:使用系统时钟的硬延迟
**注意事项:一般地,不要在中断中调用本函数,否则会存在重入问题.另外如果屏蔽了全局中断,则不要使用此函数
********************************************/
volatile u16 Timer1;
void SysTickDelay(u16 dly_ms)
{
	Timer1=dly_ms;
	while(Timer1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而设置这个全局变量则是在main.c的loop函数中设置的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for(;;)
	{
		SysTickDelay(500);
		GPIOA-&amp;gt;ODR^=GPIO_Pin_8;
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果把500改成其它的值，则很方便可以实现不同大小的定时器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>STM使用库函数读写Flash</title>
      <link>http://purplepalmdash.github.io/2013/11/30/stmshi-yong-ku-han-shu-du-xie-flash/</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/30/stmshi-yong-ku-han-shu-du-xie-flash/</guid>
      <description>&lt;p&gt;代码非常之简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define	FLASH_ADR	0x08008000		//要写入数据的地址
#define	FLASH_DATA	0x5a5a5a5a		//要写入的数据


int main(void)
{
	u32 tmp;
	ChipHalInit();			//片内硬件初始化
	ChipOutHalInit();		//片外硬件初始化

	//判断此FLASH是否为空白
	tmp=*(vu32*)(FLASH_ADR);
	if(tmp==0xffffffff)
	{
		FLASH_Unlock();
		FLASH_ProgramWord(FLASH_ADR,FLASH_DATA);
		FLASH_Lock();
		USART1_Puts(&amp;quot;The destination is empty, Data has been written in!\r\n&amp;quot;);
	}
	else if(tmp==FLASH_DATA)
	{
		USART1_Puts(&amp;quot;The destination data is the same as certification data!\r\n&amp;quot;);
	}
	else
	{
		USART1_Puts(&amp;quot;The destination data is not equal to certification data, may caused via written error, or the destination is not empty!\r\n&amp;quot;);
		FLASH_Unlock();
		FLASH_ErasePage(FLASH_ADR);
		FLASH_Lock();
		USART1_Puts(&amp;quot;Erased the written destination!\r\n&amp;quot;);
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	The destination is empty, Data has been written in!
	The destination data is the same as certification data!
	The destination data is the same as certification data!
	The destination data is the same as certification data!
	The destination data is the same as certification data!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理在于，直接读取到目的地址的值，与预设的值相比较。 要注意如何写入。先unlock，写入字后，lock住。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>STM32上的定时器</title>
      <link>http://purplepalmdash.github.io/2013/11/29/stm32shang-de-ding-shi-qi/</link>
      <pubDate>Fri, 29 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/29/stm32shang-de-ding-shi-qi/</guid>
      <description>&lt;p&gt;使用定时器的好处是，等待某个时隙的同时还可以干别的事，而定时器的时间一到，得到一个中断后对应执行中断函数中的服务例程而已。STM32的定时器非常之复杂而强大，配置和使用都要花很大精力。&lt;br /&gt;
打开TIM2线的程序如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void TIM_Configuration(void)
{
	//......

	/* TIM2 clock enable */
  	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	//......

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关定时器的设置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/* 基础设置*/
	TIM_TimeBaseStructure.TIM_Period = 8000;			//计数值   
	TIM_TimeBaseStructure.TIM_Prescaler = 7200-1;    	//预分频,此值+1为分频的除数
	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;  	//
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; 	//向上计数

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里设置的是定时器溢出控制,分频值的计算就是上述代码中提到的预分频的设置。 TIM2属于低速总线，这条总线最高只能达到36M的速度，芯片内部还有一个X2的倍频器，用于将低速的32M倍频成72M， 库中已经默认有实现。所以我们这里使用的TIM2其速度依然是72M， 如果预设分频为7200的话，分频后的结果就是72M/7200=10K(&lt;sup&gt;72000000&lt;/sup&gt;&amp;frasl;&lt;sub&gt;7200&lt;/sub&gt;). 我们可以把这个值变大或变小，以获得更慢或更快的分频速度。&lt;br /&gt;
计数值设置的是8000，计数器向上计数到8000的时候会溢出。因而溢出的时间是8000/10K=0.8s 比较值的设置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	u16 CCR1_Val = 4000;
	u16 CCR2_Val = 2000;
	u16 CCR3_Val = 1000;
	u16 CCR4_Val = 500; 
	/* 比较通道1*/
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Inactive;      		//输出比较非主动模式
	TIM_OCInitStructure.TIM_Pulse = CCR1_Val;  
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;		//极性为正
	  
	TIM_OC1Init(TIM2, &amp;amp;TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Disable);				//禁止OC1重装载,其实可以省掉这句,因为默认是4路都不重装的.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则得到的四个比较值的大小分别为: &lt;sup&gt;4000&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10000&lt;/sub&gt;=0.4s, &lt;sup&gt;2000&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10000&lt;/sub&gt;=0.2s, &lt;sup&gt;1000&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10000&lt;/sub&gt;=0.1s, &lt;sup&gt;500&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10000&lt;/sub&gt;=0.05&lt;/p&gt;

&lt;p&gt;不同的分频值设置，如果把Prescaler设置为14400-1,则得到的分频结果是72000000/14400=5K，对应的时间也随着调整。&lt;br /&gt;
简单来说，我们需要得到分频结果，还有就是预设的几个值与其结果作运算得出的真正时间。&lt;/p&gt;

&lt;p&gt;Timer到达后会产生中断，通道的捕获中断发生时，对应会执行相应的动作。这些中断处理函数是在&amp;rdquo;stm32f10x_it.c&amp;rdquo;中实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*******************************************************************************
* Function Name  : TIM2_IRQHandler TIM2中断
* Description    : This function handles TIM2 global interrupt request.
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/

void TIM2_IRQHandler(void)
{
	if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)
	{
		/*必须清空标志位*/
		TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
	
		/*点亮LED5*/
		LED5_ON;
		//LED1直接操作寄存器方式的闪烁
		GPIOA-&amp;gt;ODR^=GPIO_Pin_8;
	
	}
	else if (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET)
	{
		TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);
	
		/*点亮LED6*/
		LED6_ON;
	}
	else if (TIM_GetITStatus(TIM2, TIM_IT_CC3) != RESET)
	{
		TIM_ClearITPendingBit(TIM2, TIM_IT_CC3);
		
		/* 点亮LED7*/
		LED7_ON;
	}
	else if (TIM_GetITStatus(TIM2, TIM_IT_CC4) != RESET)
	{
	  	TIM_ClearITPendingBit(TIM2, TIM_IT_CC4);
	    
	  	/*点亮LED8*/
		LED8_ON;
	
	}
	else if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
	{
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		/*熄灭所有LED*/
		LED5_OFF;
		LED6_OFF;
		LED7_OFF;
		LED8_OFF;
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是， GPIOA-&amp;gt;ODR^=GPIO_Pin_8, 直接操作了寄存器，用于将LED1反向输出。GPIO-&amp;gt;ODR就是GPIOA的输出寄存器，而LED1用的就是GPIOA的8脚， 在这个中断函数中，如果TIM_IT_CC1的值达到了，将点亮LED5和控制LED1的闪烁。&lt;br /&gt;
在IO速度要求很高的场合，建议采用IO直接操作寄存器的方法，比用库函数要快得多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于STM32板上的12864液晶(2)</title>
      <link>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-1/</link>
      <pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-1/</guid>
      <description>&lt;p&gt;###有关电路
上一章讲的是12864的基础知识。这一章里来看12864和stm32板的连接和驱动的问题。&lt;/p&gt;

&lt;p&gt;有关12864小LCD的连接，在PDF中我们可以找到如下的表项:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能模块&lt;/th&gt;
&lt;th&gt;占用模块&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;12864小LCD&lt;/td&gt;
&lt;td&gt;PC4,PB2,PB11,PB13,PB15&lt;/td&gt;
&lt;td&gt;PC4:A0,同时也是 CH375 和 TFT 的 A0;&lt;br&gt;PB2:BOOT1,LCD 的 CS 脚;&lt;br&gt;PB11:28J60 和大小 LCD 的复位脚&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再结合电路图：&lt;br /&gt;
&lt;img src=&#34;http://purplepalmdash.github.io/images/stm32spi.jpg&#34; alt=&#34;stm32spi.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;关于GPIO口的设置，我们可以看到有这样的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	typedef enum
	{ GPIO_Mode_AIN = 0x0,
	  GPIO_Mode_IN_FLOATING = 0x04,
	  GPIO_Mode_IPD = 0x28,
	  GPIO_Mode_IPU = 0x48,
	  GPIO_Mode_Out_OD = 0x14,
	  GPIO_Mode_Out_PP = 0x10,
	  GPIO_Mode_AF_OD = 0x1C,
	  GPIO_Mode_AF_PP = 0x18
	}GPIOMode_TypeDef;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在stm32的Datasheet中有如下的配置模式：&lt;br /&gt;
&lt;img src=&#34;http://purplepalmdash.github.io/images/stmgpiomode.jpg&#34; alt=&#34;stmgpiomode.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最低的8个bit和表中是一一对应的，其中通用输出/复用功能输出的mode1/mode0的值为00.&lt;br /&gt;
因为PB15是MOSI2口， PB13是SCK2口，所以这两个管脚需要被设置为AF模式的。AF代表复用功能。PP代表push-pull.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/* PB15-MOSI2,PB13-SCK2*/
	/* Why PB14 should be enabled? */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 |GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOB, &amp;amp;GPIO_InitStructure);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PB11和PB2属于output口，所以直接设置为out口即可。&lt;br /&gt;
有关SPI2口的配置， 在STM中的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/* SPI2 configuration */
	    SPI_Cmd(SPI2, DISABLE); 												//必须先禁能,才能改变MODE
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;		//两线全双工
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;							//主
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;						//8位
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;								//CPOL=1 时钟悬空高
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;							//CPHA=1 数据捕获第2个
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;								//软件NSS
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;		//2分频
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;						//高位在前
	SPI_InitStructure.SPI_CRCPolynomial = 7;								//CRC7
	
	    SPI_Init(SPI2, &amp;amp;SPI_InitStructure);
	SPI_Cmd(SPI2, ENABLE);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###有关SPI总线
SPI接口是Motorola 首先提出的全双工三线同步串行外围接口，采用主从模式（Master Slave）架构；支持多slave模式应用，一般仅支持单Master。时钟由Master控制，在时钟移位脉冲下，数据按位传输，高位在前，低位在后（MSB first）；SPI接口有2根单向数据线，为全双工通信，目前应用中的数据速率可达几Mbps的水平。&lt;br /&gt;
stm32中关于SPI传送字节的函数编写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	static u8 SPIByte(u8 byte)
	{
		/*等待发送寄存器空*/
		while((SPI2-&amp;gt;SR &amp;amp; SPI_I2S_FLAG_TXE)==RESET);
	    /*发送一个字节*/
		SPI2-&amp;gt;DR = byte;
		/* 等待接收寄存器有效*/
		while((SPI2-&amp;gt;SR &amp;amp; SPI_I2S_FLAG_RXNE)==RESET);
		return(SPI2-&amp;gt;DR);
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令和数据是调用这个函数写入的，我们需要注意的是时序，在写入总线时需要先拉低/高A0线&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//写命令
	void LcdCmd(u8 cmd)
	{
		CSLCDS_L;
		A0_L;
		//__nop();
		;
		SPIByte(cmd);
		//__nop();
		;
		CSLCDS_H;
	}
	
	//写数据
	void LcdDat(u8 dat)
	{
		CSLCDS_L;
		A0_H;
		//__nop();
		;
		SPIByte(dat);
		//__nop();
		;
		CSLCDS_H;
	}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于STM32板上的12864液晶(3)</title>
      <link>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-3/</link>
      <pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-3/</guid>
      <description>&lt;p&gt;###如何控制液晶屏幕
ASCII码的可打印字符的范围在0x20 ~ 0x7f之间， 0x20 是空格字符，0x7f是delete字符。 最开始我们需要在内存中建立一张关于可打印字符的表。用于表示在液晶屏幕上如何显示出该字符，即该字符的点阵排列。&lt;br /&gt;
下图是可以打印的ASCII/Unicode 0-127的值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/ascii.jpg&#34; alt=&#34;ascii.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点阵数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	const u8 Asii8[] = {
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x06,0x5F,0x06,0x00,0x00,0x07,0x03,0x00,
		0x07,0x03,0x00,0x24,0x7E,0x24,0x7E,0x24,
		0x00,0x24,0x2B,0x6A,0x12,0x00,0x00,0x63,
		0x13,0x08,0x64,0x63,0x00,0x36,0x49,0x56,

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#: 0x00, 0x24, 0x7e, 0x24, 0x7e, 0x24
	00000000
	00100100
	01111110
	00100100
	01111110
	00100100

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的1代表将该点的液晶点点上。&lt;br /&gt;
要注意，实际的显示应该是倒过来的，即： 把你的脖子顺时针转90度看上面的二进制表达式。&lt;/p&gt;

&lt;p&gt;在LCD上设置需要写入的坐标，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/**************************************************************
	**函数名 :LcdSetXP
	**功能:设置坐标**
	**注意事项:这里设置的坐标不是X,Y,而是X,PAGE.因为黑白屏一次写入的数据为8个点,而且为竖
	**			式写入,故纵坐标是以页为单位,64个点共8页
	***************************************************************/
	void LcdSetXP(u8 x,u8 page)
	{
		LcdCmd((page&amp;amp;0x07)+0xb0);	//设置页指针
	    LcdCmd((x&amp;gt;&amp;gt;4)|0x10);
	    LcdCmd(x&amp;amp;0x0f);
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;128X64的屏幕一共有8192个点， 每一个字符用48个点来表示，即8X6。所以每一个字的X坐标长度应该是6, 而Y坐标应该是8. 一个page代表8个点。&lt;br /&gt;
考虑下面代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	LcdSetXP(0,1);
	LcdChar8(&#39;T&#39;);
	LcdChar8(&#39;E&#39;);
	LcdChar8(&#39;S&#39;);
	LcdChar8(&#39;T&#39;);
	LcdChar8(&#39; &#39;);
	LcdChar8(&#39;O&#39;);
	LcdChar8(&#39;K&#39;);
	LcdChar8(&#39;!&#39;);

	LcdSetXP(0,2);
	LcdChar8(&#39;T&#39;);
	LcdSetXP(6,2);
	LcdChar8(&#39;E&#39;);
	LcdSetXP(24,2);
	LcdChar8(&#39;S&#39;);
	LcdChar8(&#39;T&#39;);
	LcdChar8(&#39; &#39;);
	LcdChar8(&#39;O&#39;);
	LcdChar8(&#39;K&#39;);
	LcdChar8(&#39;!&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的结果应该是：&lt;br /&gt;
TEST OK!&lt;br /&gt;
TE  ST OK!&lt;br /&gt;
对应上面的解释不难明白在屏幕上填写字符的原理。&lt;/p&gt;

&lt;p&gt;有关在屏幕上写字符的函数是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**************************************************************
**函数名 :LcdChar8
**功能:写一个宽6高8的ASCII
**注意事项:这里忽略了坐标的设置,此函数作为子函数被其他函数调用,使用前需要设置坐标
			使用内部的点阵表
***************************************************************/
void LcdChar8(char chr)
{
	u8 i;
	u8* p_data;

	/* 0x20 is the space character
	 * 0x7f is the delete character
	 * Seems all of the printable character are listed in the global array
	 */
	if((chr&amp;lt;0x20)||(chr&amp;gt;0x7f))
	{
		return;
	}

	/* Asii8 is the global variable(Glbal Array), So now we retrieve the
	 * character&#39;s address via first address plus the (asii code number)*6
	 * Because, each entry size if 6, all of the entry start from 0x20
	 */
	p_data = (u8*)Asii8 + (chr-0x20)*6;	//要写字符的首地址

	for(i=0;i&amp;lt;6;i++)
	{
		LcdDat(*p_data++);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例说明， !的字符表示为
00000000&lt;br /&gt;
00000000&lt;br /&gt;
00000110&lt;br /&gt;
01011111&lt;br /&gt;
00000110&lt;br /&gt;
00000000&lt;br /&gt;
则看起来应该像：
000100&lt;br /&gt;
001110&lt;br /&gt;
000100&lt;br /&gt;
000000&lt;br /&gt;
000100&lt;br /&gt;
000000&lt;br /&gt;
把1想象为点，就能对应想象出!在屏幕上的样子。&lt;/p&gt;

&lt;p&gt;原有的代码中关于GPIO初始化的时候，多初始化了一个PB14口，删除后一切正常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于STM32板上的12864液晶</title>
      <link>http://purplepalmdash.github.io/2013/11/27/guan-yu-stm32ban-shang-de-12864ye-jing/</link>
      <pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/27/guan-yu-stm32ban-shang-de-12864ye-jing/</guid>
      <description>&lt;p&gt;板子是09年入手的，但是一直没时间好好玩，最近端起来觉得有必要好好研究一番。为了以后翻阅方便，全中文记下来。&lt;br /&gt;
###12864
通常所说的12864LCD显示块是所说的点阵液晶显示模块，就是由128X64个液晶显示点组成的一个128列X64行的阵列，所以也就叫成了12864。每个显示点都对应着有一位二进制数，0表示灭，1表示亮。存储这些点阵信息的RAM被称为显示数据存储器。如果要显示某个图形或汉字就是将相应的点阵信息写入到对应的存储单元中。图形或汉字的点阵信息是由自己设计，这时候问题的关键是显示点在液晶屏上的位置与其在存储器中的地址之间的关系。&lt;br /&gt;
显示点在64X64液晶屏上的位置由列号（line,0~63）与行号（line,0~63）确定。512X8 bits RAM中某个存储单元的地址由页地址（Xpage,0~7）和列地址（Yaddress,0~63）确定。每个存储单元存储8个液晶点的显示信息。也就是说，一个页的大小是8. 运算关系则是64x64=(64x8)x8=512x8.&lt;br /&gt;
由于多数液晶显示模块的驱动电路是由一片行驱动器和两片列驱动器构成，所以12864液晶屏实际上是由左右两块独立的64X64液晶屏拼接而成，每半屏有一个512X8 bits显示数据RAM。左右半屏驱动电路及存储器分别由片选信号CS1和CS2选择。（少数厂商为了简化用户设计，在模块中增加译码电路，使得128X64液晶屏就是一个整屏，只需一个片选信号。）&lt;/p&gt;

&lt;p&gt;如如果点亮12864的屏中（20，30）位置上的液晶点，因列地址30小于64，该点在左半屏第29列，所以CS1有效；行地址20除以8取整得2，取余得4，该点在RAM中页地址为2，在字节中的序号为4；所以将二进制数据00010000（也可能是00001000，高低顺序取决于制造商）写入Xpage=2，Yaddress=29的存储单元中即点亮（20，30）上的液晶点。&lt;/p&gt;

&lt;p&gt;这是为了为了使液晶点位置信息与存储地址的对应关系更直观关，将64X64液晶屏从上至下8等分为8个显示块，每块包括8行X64列个点阵。每列中的8行点阵信息构成一个8bits二进制数，存储在一个存储单元中。（需要注意：二进制的高低有效位顺序与行号对应关系因不同商家而不同）存放一个显示块的RAM区称为存储页。即64X64液晶屏的点阵信息存储在8个存储页中，每页64个字节，每个字节存储一列(8行)点阵信息。因此存储单元地址包括列地址（Yaddress,0~63）和页地址（Xpage,0~7）。&lt;/p&gt;

&lt;p&gt;以上就是对于12864点阵液晶显示器的原理介绍。&lt;/p&gt;

&lt;p&gt;在DX32开发板上的液晶是怎么一回事呢？它的封装图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/128641.jpg&#34; alt=&#34;128641.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Datasheet有72页，乱七八糟的会讲一大堆。但是事实上我们只需要关注和软件有关的方面，拿一个很简单的开启/关闭LCD的例子来说，DataSheet里有这样的表格：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;A0 /RD /WR&lt;/th&gt;
&lt;th&gt;D7 D6 D5 D4 D3 D2 D1 D0&lt;/th&gt;
&lt;th&gt;Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Display On/OFF&lt;/td&gt;
&lt;td&gt;0 1 0&lt;/td&gt;
&lt;td&gt;1 0 1 0 1 1 1 1&lt;/td&gt;
&lt;td&gt;LCD Display ON&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Display On/OFF&lt;/td&gt;
&lt;td&gt;0 1 0&lt;/td&gt;
&lt;td&gt;1 0 1 0 1 1 1 0&lt;/td&gt;
&lt;td&gt;LCD Display OFF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那么会有对应的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/**************************************************************
	**函数名:LcdOnOff
	**功能:开关LCD
	***************************************************************/
	void LcdOnOff(u8 onoff)
	{
	     if(onoff&amp;gt;0)
			 LcdCmd(0xaf);       //开显示
	     else
			 LcdCmd(0xae);          	//关显示
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0xaf的二进制的值是1010 1111, 而0xae的值则是1010 1110， 这点在手册中容易引起混淆，因为它操蛋的把前面的一系列值都省略了，表格里的才是完整的应该发送的命令。&lt;/p&gt;

&lt;p&gt;再拿一个例子来说，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/**************************************************************
	**函数名:LcdInit
	**功能:初始化LCD,初始化后需要用LcdCmd(0xaf)命令打开显示
	***************************************************************/
	const u8 LCD_Tab[] = {		/*0x26改0x27可增加对比度*/
		0xa2,0xa0,0xc8,0xf8,0x00,0x26,0x2f,0x81,0x05,0xa4,0xa6,0xac,0x00,0xee,0x40
	};
	void LcdInit(void)
	{
		u16 i;
		RSTLCDS_L;
		for(i=0;i&amp;lt;65530;i++);
		RSTLCDS_H;
	
		/* Why we have to write 15 times for the LCD_Tab? */
		for(i=0;i&amp;lt;15;i++)
			LcdCmd(LCD_Tab[i]);
		LcdCmd(0xaf);       //开显示
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在初始化LCD的时候我们需要依次写入命令，这里我们把命令做成一个数组，就是LCD_Tab数组， 那么命令的格式如下：&lt;br /&gt;
0xa2  LCD bits set, 0 means normal displaying&lt;br /&gt;
0xa0  ADC Select. Set the display RAM address SEG output corresponding, 0 means normal.&lt;br /&gt;
0xc8  Common Output Set, means reverse direction.&lt;br /&gt;
0xf8  Booster ratio.&lt;/p&gt;

&lt;p&gt;所有这些在DataSheet中均有详细说明。&lt;br /&gt;
总之，对于12864,我们只要把它看成是一个“黑盒子”，输入对应的值，盒子上就能显示出怎样的值，如此就可以得到我们要的结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to setup STM32 Project in eclipse</title>
      <link>http://purplepalmdash.github.io/2013/11/25/how-to-setup-stm32-project-in-eclipse/</link>
      <pubDate>Mon, 25 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/25/how-to-setup-stm32-project-in-eclipse/</guid>
      <description>&lt;p&gt;###Preparation
####STM Standard Peripheral Lib
Download Link for STSW-STM32054STM32F10x standard peripheral library :&lt;br /&gt;
&lt;a href=&#34;http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1743/PF257890&#34;&gt;http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1743/PF257890&lt;/a&gt;&lt;br /&gt;
Unsip the downloaded library and you will get several folders, the Libraries folder is the pure libs.
####Cross-Compiler for STM32
Download the cross-compiler from CodeSourcery ARM EABI toolchain - Mentor Graphics:&lt;br /&gt;
&lt;a href=&#34;https://sourcery.mentor.com/sgpp/lite/arm/portal/subscription?@template=lite&#34;&gt;https://sourcery.mentor.com/sgpp/lite/arm/portal/subscription?@template=lite&lt;/a&gt;&lt;br /&gt;
You have to choose EABI version. Download and install it, you will get &amp;ldquo;arm-none-eabi-&amp;rdquo; prefixed cross-compiler.&lt;br /&gt;
####Eclipse plugins
Help-&amp;gt; Install New Software, Add the URL for gnuarm:&lt;br /&gt;
&lt;a href=&#34;http://gnuarmeclipse.sourceforge.net/updates&#34;&gt;http://gnuarmeclipse.sourceforge.net/updates&lt;/a&gt;&lt;br /&gt;
Then Install CDT GNU Cross Development Tools , after install the plugin, you will asked to reboot, just reboot. Now your preparation is OK.&lt;/p&gt;

&lt;p&gt;###Create a new project
 In Eclipse, Click File-&amp;gt;New-&amp;gt;C project, choose &amp;ldquo;ARM Cross Target Applcation (End of life)&amp;rdquo;, choose &amp;ldquo;Empty Project&amp;rdquo; &amp;ldquo;ARM Linux GCC(Sourcery Lite Bare), give the Project name and click Next Button, then click Finish. you will see the newly created project in the Project Explorer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipse1.jpg&#34; alt=&#34;eclipse1.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Copy the Library files into your own project, take &amp;ldquo;stmExample&amp;rdquo; project for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Trusty@DashArch STM32F10x_StdPeriph_Lib_V3.5.0]$ pwd
	/media/y/embedded/stm32/dev/lib/STM32F10x_StdPeriph_Lib_V3.5.0
	[Trusty@DashArch STM32F10x_StdPeriph_Lib_V3.5.0]$ cp -r  Libraries/ ~/workspace/stmExample/	 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your project should seem like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipse2.jpg&#34; alt=&#34;eclipse2.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now you have to prepare your startup file, notice you have to use &amp;ldquo;S&amp;rdquo; suffixed file name, and you have to remove the remaining directory except the .S file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Trusty@DashArch startup]$ pwd
	/home/Trusty/workspace/stmExample/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup
	[Trusty@DashArch startup]$ ls
	arm  gcc_ride7  iar  TrueSTUDIO
	[Trusty@DashArch startup]$ cp TrueSTUDIO/startup_stm32f10x_hd.s ./startup_stm32f10x_hd.S
	[Trusty@DashArch startup]$ ls
	arm  gcc_ride7  iar  startup_stm32f10x_hd.S  TrueSTUDIO
	[Trusty@DashArch startup]$ rm -rf TrueSTUDIO/ iar/ gcc_ride7/ arm/
	[Trusty@DashArch startup]$ ls
	startup_stm32f10x_hd.S

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a directory named src to contains your own project files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Trusty@DashArch stmExample]$ mkdir src
	[Trusty@DashArch stmExample]$ pwd
	/home/Trusty/workspace/stmExample
	[Trusty@DashArch stmExample]$ ls
	Libraries  src

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the project files into &amp;ldquo;src&amp;rdquo; directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Trusty@DashArch STM32F10x_StdPeriph_Template]$ ls
	EWARM  HiTOP  main.c  MDK-ARM  Release_Notes.html  RIDE  stm32f10x_conf.h  stm32f10x_it.c  stm32f10x_it.h  system_stm32f10x.c  TrueSTUDIO
	[Trusty@DashArch STM32F10x_StdPeriph_Template]$ cp stm32f10x_* ~/workspace/stmExample/src/
	[Trusty@DashArch STM32F10x_StdPeriph_Template]$ pwd
	/media/y/embedded/stm32/dev/lib/STM32F10x_StdPeriph_Lib_V3.5.0/Project/STM32F10x_StdPeriph_Template
Copy the link script to root directory of your project:
	[Trusty@DashArch STM32100B-EVAL]$ pwd
	/media/y/embedded/stm32/dev/lib/STM32F10x_StdPeriph_Lib_V3.5.0/Project/STM32F10x_StdPeriph_Template/TrueSTUDIO/STM32100B-EVAL
	[Trusty@DashArch STM32100B-EVAL]$ cp stm32_flash.ld  ~/workspace/stmExample/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have to modify the link script according to your own flash layout and memory layout, My CPU is STM32F103VC, which has 48K RAM and 256K Flash, so the configuration is listed as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
/*
Linker subscript for STM32F051 definitions with 64K Flash and 8K RAM
Copyright RAISONANCE 2007
!!! This file is automatically generated by RIDE !!!
Do not modify it, as it will be erased at every link.
You can use, copy and distribute this file freely, but without any warranty.
*/

/* Memory Spaces Definitions */

ENTRY(Reset_Handler)

MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 256K
  RAM  (xrw) : ORIGIN = 0x20000000, LENGTH = 48K
}

/* highest address of the user mode stack */
_estack = 0x2000c000;


/*
Common part of the linker scripts for STR71x devices in FLASH mode
(that is, the FLASH is seen at 0)
Copyright RAISONANCE 2005
You can use, modify and distribute this file freely, but without any warranty.
*/

/* Sections Definitions */

SECTIONS
{
    /* for Cortex devices, the beginning of the startup code is stored in the .isr_vector section, which goes to FLASH */
    .isr_vector :
    {
	. = ALIGN(4);
        KEEP(*(.isr_vector))            /* Startup code */
	. = ALIGN(4);
    } &amp;gt;FLASH
    
    /* the program code is stored in the .text section, which goes to Flash */
    .text :
    {
	    . = ALIGN(4);
	    
        *(.text)                   /* normal code */
        *(.text.*)                 /* -ffunction-sections code */
        *(.rodata)                 /* read-only data (constants) */
        *(.rodata*)                /* -fdata-sections read only data */
        *(.glue_7)                 /* TBD - needed ? */
        *(.glue_7t)                /* TBD - needed ? */

	/* Necessary KEEP sections (see http://sourceware.org/ml/newlib/2005/msg00255.html) */
	KEEP (*(.init))
	KEEP (*(.fini))
	
	    . = ALIGN(4);
        _etext = .;
	    /* This is used by the startup in order to initialize the .data section */
        _sidata = _etext;
    } &amp;gt;FLASH
    
    /* This is the initialized data section
    The program executes knowing that the data is in the RAM
    but the loader puts the initial values in the FLASH (inidata).
    It is one task of the startup to copy the initial values from FLASH to RAM. */
    .data  : AT ( _sidata )
    {
	    . = ALIGN(4);
        /* This is used by the startup in order to initialize the .data secion */
        _sdata = . ;
        _data = . ;
        
        *(.data)
        *(.data.*)
        *(.RAMtext)

	    . = ALIGN(4);
	    /* This is used by the startup in order to initialize the .data secion */
   	    _edata = . ;
    } &amp;gt;RAM
    
    /* This is the uninitialized data section */
    .bss :
    {
	    . = ALIGN(4);
        /* This is used by the startup in order to initialize the .bss secion */
        _sbss = .;
        _bss = .;
        
        *(.bss)
        *(.bss.*) /* patched by elias - allows the use of -fdata-sections */
        *(COMMON)
        
	    . = ALIGN(4);
	    /* This is used by the startup in order to initialize the .bss secion */
   	 _ebss = . ;
    } &amp;gt;RAM
    
    PROVIDE ( end = _ebss );
    PROVIDE ( _end = _ebss );
    
    __exidx_start = .;
    __exidx_end = .;
    
    /* after that it&#39;s only debugging information. */
    
    /* remove the debugging information from the standard libraries */
    /DISCARD/ :
    {
     libc.a ( * )
     libm.a ( * )
     libgcc.a ( * )
     }

    /* Stabs debugging sections.  */
    .stab          0 : { *(.stab) }
    .stabstr       0 : { *(.stabstr) }
    .stab.excl     0 : { *(.stab.excl) }
    .stab.exclstr  0 : { *(.stab.exclstr) }
    .stab.index    0 : { *(.stab.index) }
    .stab.indexstr 0 : { *(.stab.indexstr) }
    .comment       0 : { *(.comment) }
    /* DWARF debug sections.
       Symbols in the DWARF debugging sections are relative to the beginning
       of the section so we begin them at 0.  */
    /* DWARF 1 */
    .debug          0 : { *(.debug) }
    .line           0 : { *(.line) }
    /* GNU DWARF 1 extensions */
    .debug_srcinfo  0 : { *(.debug_srcinfo) }
    .debug_sfnames  0 : { *(.debug_sfnames) }
    /* DWARF 1.1 and DWARF 2 */
    .debug_aranges  0 : { *(.debug_aranges) }
    .debug_pubnames 0 : { *(.debug_pubnames) }
    /* DWARF 2 */
    .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
    .debug_abbrev   0 : { *(.debug_abbrev) }
    .debug_line     0 : { *(.debug_line) }
    .debug_frame    0 : { *(.debug_frame) }
    .debug_str      0 : { *(.debug_str) }
    .debug_loc      0 : { *(.debug_loc) }
    .debug_macinfo  0 : { *(.debug_macinfo) }
    /* SGI/MIPS DWARF 2 extensions */
    .debug_weaknames 0 : { *(.debug_weaknames) }
    .debug_funcnames 0 : { *(.debug_funcnames) }
    .debug_typenames 0 : { *(.debug_typenames) }
    .debug_varnames  0 : { *(.debug_varnames) }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a sample main.c under the src directory and input your source code.&lt;/p&gt;

&lt;p&gt;###Configure the project
Right click your project, select Properties, C/C++ Build -&amp;gt; Settings, ARM Linux GCC Assembler(Sourcery Lite Bare)/Preprocessor, add a Defined symbols(-D), also you have to add this into ARM Linux GCC Compiler(Sourcery Lite Bare):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	STM32F10X_HD
	USE_STDPERIPH_DRIVER

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ARM Linux GCC C Compiler(Sourcery Lite Bare)-&amp;gt; Directories, add Include paths(-i) add following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipse3.jpg&#34; alt=&#34;eclipse3.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Specify the link script:&lt;br /&gt;
ARM Linux GCC CLinker(Sourcery Lite Bare) -&amp;gt; General, Script file(-T)
    /home/Trusty/workspace/stm32archlinux/stm32_flash.ld&lt;/p&gt;

&lt;p&gt;###Build and Debug
Right click the project and click &amp;ldquo;Build project&amp;rdquo;, then you got your project compiling and linking, finally you got your Binary named stmExample.elf.&lt;br /&gt;
Now we can use OpenOCD for writing the image into the flash and debugging it.&lt;/p&gt;

&lt;p&gt;Run-&amp;gt;Debug Configuration, you will see Zylin Embedded debug(Native) is available, right click and choose &amp;ldquo;Create new&amp;rdquo;, create a new debug item.&lt;br /&gt;
Choose the Main:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipse4.jpg&#34; alt=&#34;eclipse4.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Choose the Debugger:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipse5.jpg&#34; alt=&#34;eclipse5.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Choose Commands:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipse6.jpg&#34; alt=&#34;eclipse6.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The configuration file is :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	target remote localhost:3333
	monitor reset
	monitor halt
	monitor flash protect 0 0 11 off
	monitor flash write_image erase /home/Trusty/workspace/stm32archlinux/Debug/stm32archlinux.hex 0 ihex
	disconnect
	target remote localhost:3333
	monitor reset
	monitor halt


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open your own openocd, and then using eclipse to connect the gdb. Remember &amp;ldquo;toggle breakpoint&amp;rdquo; and you will get a hardware breakpoint. Enjoy the debugging.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setup an embedded development enviroment for STM32</title>
      <link>http://purplepalmdash.github.io/2013/11/21/setup-an-embedded-development-enviroment-for-stm32/</link>
      <pubDate>Thu, 21 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/21/setup-an-embedded-development-enviroment-for-stm32/</guid>
      <description>&lt;p&gt;###Download the toolchain
We should download the toolchain from the ARM employee maintained website, the download address is located at: &lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;https://launchpad.net/gcc-arm-embedded&lt;/a&gt;, use following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ wget https://launchpad.net/gcc-arm-embedded/4.7/4.7-2013-q3-update/+download/gcc-arm-none-eabi-4_7-2013q3-20130916-linux.tar.bz2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;untar the downloaded package and then add it to your system path, my solution is directly add some alias into ~/.bashrc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	### Add Cross_Compiler for eclipse based stm32
	#export PATH=&amp;quot;/media/y/embedded/cortex/gcc-arm-none-eabi-4_7-2013q3/bin:$PATH&amp;quot;
	alias setstm=&#39;export PATH=&amp;quot;/media/y/embedded/cortex/gcc-arm-none-eabi-4_7-2013q3/bin:$PATH&amp;quot;&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Eclipse Configuration
We have to install zylin for flashing the stm32 board. After installation, eclipse will be rebooted.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/eclipseinstall.jpg&#34; alt=&#34;images/eclipseinstall.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;###OpenOCD
OpenOCD is a open-source hardware debugger.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	community/openocd 0.7.0-2
	    Debugging, in-system programming and boundary-scan testing for embedded target devices
	[root@XXXyyy capscr]# pacman -S openocd

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Template prepration
Download the template from :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ git clone https://github.com/JorgeAparicio/bareCortexM.git

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>