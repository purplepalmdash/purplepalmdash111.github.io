<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raspberrypi on Dash</title>
    <link>http://purplepalmdash.github.io/categories/raspberrypi/</link>
    <description>Recent content in Raspberrypi on Dash</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 May 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://purplepalmdash.github.io/categories/raspberrypi/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Download Android Source Code on RaspberryPI</title>
      <link>http://purplepalmdash.github.io/2014/05/04/download-android-source-code-on-raspberrypi/</link>
      <pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/05/04/download-android-source-code-on-raspberrypi/</guid>
      <description>&lt;p&gt;Just a try. I don&amp;rsquo;t think I will use raspberryPI for developing, but using it for downloading code is a good idea.&lt;br /&gt;
###Go Back Home
My raspberryPI is behind the router, so I have to use a ssh tunnel to reach raspberryPI.&lt;br /&gt;
Setting up tunnel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -L 2230:10.0.0.230:22 Tomcat.xxx.xx.xxx -l root

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Login on local port:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh root@localhost -p 2230

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a terminal which could reach raspberry PI.&lt;br /&gt;
###Package Preparation
Since the OS on my raspberryPI is ArchLinux, I have to install following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pacman -S w3m tmux lynx

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Account Setting
Use w3m for accessing &lt;a href=&#34;https://android.googlesource.com/new-password&#34;&gt;https://android.googlesource.com/new-password&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But, remember, I have a BBB which also runs at home, so I can also use it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install elinks

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use elinks for making connection to &lt;a href=&#34;https://android.googlesource.com/new-password&#34;&gt;https://android.googlesource.com/new-password&lt;/a&gt;, remember the username, and the machine and login name, just copy them into your ~/.netrc, and make sure you have the right priviledge for the file ~/.netrc.&lt;br /&gt;
###Repo sync
This will take for a long~long time, depending on your bandwidth:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repo init -u https://android.googlesource.com/a/platform/manifest -b master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we use the following file for sync the repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

while [ 1 ]
do
    repo sync -j8
    if [ &amp;quot;$?&amp;quot; = &amp;quot;0&amp;quot; ] ; then
        echo &amp;quot;rsync completed normally&amp;quot;
        exit
    else
        echo &amp;quot;Rsync failure. Backing off and retrying...&amp;quot;
        sleep 1
    fi
done

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now call tmux for holding the sync procedure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tmux new -s Android
$ /bin/bash ./autodown.sh 2&amp;gt;&amp;amp;1 | tee autodown.log
$ ctrl+b d

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sync process now is held in tmux session. Let it go, next time when you want to see the procedure, just ssh to the board use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux a -t Android

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Re-compile Kernel For Supporting 512M Memory For RaspberryPI In Qemu</title>
      <link>http://purplepalmdash.github.io/2014/03/20/re-compile-kernel-for-supporting-512m-memory-for-raspberrypi-in-qemu/</link>
      <pubDate>Thu, 20 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/03/20/re-compile-kernel-for-supporting-512m-memory-for-raspberrypi-in-qemu/</guid>
      <description>&lt;p&gt;###Cross Compiler Prepration
Get the cross-compiler from github:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Trusty@XXXyyy tools]$ pwd
	/media/y/raspberryPI/tools
	[Trusty@XXXyyy tools]$ git clone git://github.com/raspberrypi/tools.git

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the cross-compiler to system path:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	export PATH=&amp;quot;/media/y/raspberryPI/tools/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin:$PATH&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now input &amp;ldquo;arm-linux-g&amp;rdquo; + tab you will see the cross-compiler is ready.&lt;br /&gt;
###Prepare the kernel
Get the kernel source from github:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git clone git://github.com/raspberrypi/linux.git

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to get the patches for supporting the raspberryPI, Torlus has done the patches which could also be downloaded from github:&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Now we need to configure the kernel:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	cd linux
	make ARCH=arm versatile_defconfig

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NO, I MADE A MISTAKE, IT SHOULDN&amp;rsquo;T COMPILE KERNEL, SHOULD COMPILE QEMU!!!&lt;/p&gt;

&lt;p&gt;###Compile qemu
Get the modified qemu branch from github:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git clone git://github.com/Torlus/qemu.git

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Switch to &amp;lsquo;rpi&amp;rsquo; branch:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git fetch origin
	git branch -v -a # List the available branches.
	git checkout -b raspberry origin/rpi	# Checkout the origin/rpi to local raspberry
	git fetch
	git checkout raspberry

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Begin to configure qemu, notice we have to use python2 for configuring the qemu:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	workon venv2
	./configure --help
	./configure --target-list=&amp;quot;arm-softmmu arm-linux-user&amp;quot; --enable-sdl 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now begin to make the qemu, use -j8 for speeding up, adjust the number according to your own machine:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	make -j8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now under the following directory you will get the qemu-system-arm:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ pwd
	/media/y/raspberryPI/qemu/arm-softmmu

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get the kernel.img from the SD image. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;###Use the compiled qemu for running
We have to change the scripts for running the qemu:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/media/y/raspberryPI/qemu/arm-softmmu/qemu-system-arm -net nic,macaddr=$macaddr -net user -kernel kernel.img -cpu arm1176 -m 512 -M raspi -no-reboot -serial stdio -append &amp;quot;rw earlyprintk loglevel=8 panic=120 keep_bootcon rootwait dma.dmachans=0x7f35 bcm2708_fb.fbwidth=1024 bcm2708_fb.fbheight=768 bcm2708.boardrev=0xf bcm2708.serial=0xcad0eedf smsc95xx.macaddr=B8:27:EB:D0:EE:DF sdhci-bcm2708.emmc_clock_freq=100000000 vc_mem.mem_base=0x1c000000 vc_mem.mem_size=0x20000000  dwc_otg.lpm_enable=0 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait&amp;quot; -sd 2014-01-07-wheezy-raspbian.img  -device usb-kbd -device usb-mouse -usbdevice net 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run the raspberryPI in QEMU with 512MB memory, but, the network is still unavailable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploy Weather APP on RaspberryPI</title>
      <link>http://purplepalmdash.github.io/2014/03/17/deploy-weather-app-on-raspberrypi/</link>
      <pubDate>Mon, 17 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/03/17/deploy-weather-app-on-raspberrypi/</guid>
      <description>&lt;p&gt;Since I enabled the RaspberryPI and disabled the PogoPlug, I have to move the Weather App on RaspberryPI. &lt;br /&gt;
The main difference lies on the python version, on PogoPlug the default python version is python2.7, while on RaspberryPI it&amp;rsquo;s python3.3, thus I have to use the virtualenvironment of Python. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;###Setup the virtualenv
Following is the steps for setting up the virtual environment for python2.7 on ArchLinux:&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ mkdir ~/pyves
	$ cat &amp;gt;~/.virtualenvrc &amp;lt;&amp;lt;EOF
	export WORKON_HOME=&amp;quot;$HOME/pyves&amp;quot;
	export PROJECT_HOME=&amp;quot;$HOME/pyves&amp;quot;
	source /usr/bin/virtualenvwrapper.sh
	EOF
	$ source  ~/.virtualenvrc
	$ cat &amp;gt;&amp;gt;~/.bashrc &amp;lt;&amp;lt;EOF
	source $HOME/.virtualenvrc
	EOF
	$ mkvirtualenv --python=/usr/bin/python2.7 v27
	$ workon v27
	$ pip install pywapi django sqlite3

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Deployment Python Script
Copy the script to some directory, mine is under /root/code/weather.&lt;br /&gt;
If we want cron to call the virtual environment, we have to create a script and in the script to call the python script.&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	# Export everything.
	source /root/.bashrc
	# Change to the virtual environment
	workon v27
	# Call python
	python /root/code/weather/genhtml.py

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we add this script to crontab, at every whole point, each hour it will run once. &lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	crontab -e
	0 */1 * * * /root/code/weather/NJ.sh
	15 */1 * * * /root/code/weather/BJ.sh
	30 */1 * * * /root/code/weather/CS.sh

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now at every 0/15/30, our cron job will be run, and retrieve the data generate the flot image for displaying.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use RaspberryPI as a file server</title>
      <link>http://purplepalmdash.github.io/2013/12/30/use-raspberrypi-as-a-file-server/</link>
      <pubDate>Mon, 30 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/30/use-raspberrypi-as-a-file-server/</guid>
      <description>&lt;p&gt;###Preparation
Mount the partition automatically, add following lines into the /etc/fstab:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/dev/sda3	/media/ntfs    	ntfs-3g    permissions,locale=en_US.utf8  	  0	  2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I decide to use samba to share the files, so I have to install samba&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	apt-get install samba

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The samba server will start automatically, but we have to configure it to adapte to our situation.&lt;br /&gt;
Add the configuration to the samba config file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/etc/samba/smb.conf
	[raspshare]
	   comment = raspberry PI Share
	   path = /media/ntfs
	   valid users = Trusty
	   public = no
	   writable = yes
	   printable = no
	   create mask = 0765

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Restart the samba server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/etc/init.d/samba restart

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For using smbpasswd, you have to install samba-common-bin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	apt-get install samba-common-bin

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add some users to the samba sharing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	smbpasswd -a xxx

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Mount the shared partition in client
List all of the available samba shared items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ smbclient -L 10.0.0.230 -U%

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can mount it, I add following command into the .bashrc, so everytime I enter &amp;lsquo;mountraspsamba&amp;rsquo; is ok&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	alias mountraspsamba=&#39;sudo mount -t cifs //10.0.0.230/raspshare/ -o user=xxxx,password=XXXX,workgroup=WORKGROUP /media/raspsamba&#39;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>I2C between raspberryPI and Arduino</title>
      <link>http://purplepalmdash.github.io/2013/12/29/i2c-between-raspberrypi-and-arduino/</link>
      <pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/29/i2c-between-raspberrypi-and-arduino/</guid>
      <description>&lt;p&gt;###连线
Arduino I2C 连线:&lt;br /&gt;
&lt;img src=&#34;http://purplepalmdash.github.io/images/arduino-i2c-pins.jpg&#34; alt=&#34;arduino.jpg&#34; /&gt;&lt;br /&gt;
RaspberryPI I2C 连线:&lt;br /&gt;
&lt;img src=&#34;http://purplepalmdash.github.io/images/raspberry-pi-i2c-pins.jpg&#34; alt=&#34;rasp.jpg&#34; /&gt;&lt;br /&gt;
连线图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	RPI               Arduino (Uno/Duemillanove)
	--------------------------------------------
	GPIO 0 (SDA) &amp;lt;--&amp;gt; Pin 4 (SDA)
	GPIO 1 (SCL) &amp;lt;--&amp;gt; Pin 5 (SCL)
	Ground       &amp;lt;--&amp;gt; Ground

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://purplepalmdash.github.io/images/RaspberryPI-I2c-Arduino.png&#34; alt=&#34;rasp-arduino.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;###Arduino端代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Wire.h&amp;gt;

#define SLAVE_ADDRESS 0x04
int number = 0;
int state = 0;

void setup() {
    pinMode(13, OUTPUT);
    Serial.begin(9600);         // start serial for output
    // initialize i2c as slave
    Wire.begin(SLAVE_ADDRESS);

    // define callbacks for i2c communication
    Wire.onReceive(receiveData);
    Wire.onRequest(sendData);

    Serial.println(&amp;quot;Ready!&amp;quot;);
}

void loop() {
    delay(100);
}

// callback for received data
void receiveData(int byteCount){

    while(Wire.available()) {
        number = Wire.read();
        Serial.print(&amp;quot;data received: &amp;quot;);
        Serial.println(number);

        if (number == 1){

            if (state == 0){
                digitalWrite(13, HIGH); // set the LED on
                state = 1;
            }
            else{
                digitalWrite(13, LOW); // set the LED off
                state = 0;
            }
         }
     }
}

// callback for sending data
void sendData(){
    Wire.write(number);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###RaspberryPI端准备
在/etc/modules中增加一行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	i2c-dev

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释掉黑名单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ cat /etc/modprobe.d/raspi-blacklist.conf
	# blacklist spi and i2c by default (many users don&#39;t need them)
	# blacklist spi-bcm2708
	#blacklist i2c-bcm2708

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装i2c工具：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	apt-get install i2c-tools

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装python库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	apt-get install python-smbus

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;探测i2c设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	i2cdetect -y 0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不是root用户，例如，如果是pi用户，则需要将当前用户增加到i2c组中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ sudo adduser pi i2c

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###RaspberryPI端代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import smbus
import time
# for RPI version 1, use &amp;quot;bus = smbus.SMBus(0)&amp;quot;
bus = smbus.SMBus(0)

# This is the address we setup in the Arduino Program
address = 0x04

def writeNumber(value):
    bus.write_byte(address, value)
    # bus.write_byte_data(address, 0, value)
    return -1

def readNumber():
    number = bus.read_byte(address)
    # number = bus.read_byte_data(address, 1)
    return number

while True:
    var = input(&amp;quot;Enter 1 - 9: &amp;quot;)
    if not var:
        continue

    writeNumber(var)
    print &amp;quot;RPI: Hi Arduino, I sent you &amp;quot;, var
    # sleep one second
    time.sleep(1)

    number = readNumber()
    print &amp;quot;Arduino: Hey RPI, I received a digit &amp;quot;, number
    print

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码时要注意，0～255的数字输入进去，会在arduino i2c slave端收到对应的数据，并原封不动的被返回。超过255的数值将溢出。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Little tricky on SPI</title>
      <link>http://purplepalmdash.github.io/2013/12/29/little-tricky-on-spi/</link>
      <pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/29/little-tricky-on-spi/</guid>
      <description>&lt;p&gt;接着上一个日志来，玩一个小tricky，通过SPI总线自己想输入的字符。&lt;br /&gt;
主机端，添加下列头文件
    #include &lt;string.h&gt;
这使得可以使用strcpy等函数。&lt;br /&gt;
重写transfer()函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void transfer_mine(int fd, char *buf)
{
	int ret;

	uint8_t tx[140];
	int len = strlen(buf)+1;
	memcpy(tx, buf, strlen(buf)+1);
	tx[strlen(tx)] = &#39;\n&#39;;

	uint8_t rx[ARRAY_SIZE(tx)] = {0, };
	struct spi_ioc_transfer tr = {
		.tx_buf = (unsigned long)tx,
		.rx_buf = (unsigned long)rx,
		//.len = ARRAY_SIZE(tx),
		.len = len,
		.delay_usecs = delay,
		.speed_hz = speed,
		.bits_per_word = bits,
	};
 
	ret = ioctl(fd, SPI_IOC_MESSAGE(1), &amp;amp;tr);
	if (ret &amp;lt; 1)
		pabort(&amp;quot;can&#39;t send spi message&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在main()函数里，改写调用的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	char myinput[140]=&amp;quot;Trustywill, Hi, this is Trusty&amp;quot;;
	transfer_mine(fd, myinput);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以将自定义的字符传输过去了，140是随便设置的值，可以设置为别的更大或者更小的值。&lt;br /&gt;
当然你也可以从命令行输入想传输的字符, 这里就不深入了。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPI连接raspberryPI和Arduino</title>
      <link>http://purplepalmdash.github.io/2013/12/29/spilian-jie-raspberrypihe-arduino/</link>
      <pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/29/spilian-jie-raspberrypihe-arduino/</guid>
      <description>&lt;p&gt;下面是使用SPI在RaspberryPI和Arduino Nano w之间进行双机通信的一个例子。借助它可以很好的理解SPI的工作原理。&lt;br /&gt;
###背景知识
RaspberryPI GPIO布局图：&lt;br /&gt;
&lt;img src=&#34;http://purplepalmdash.github.io/images/GPIOs.png&#34; alt=&#34;/images/GPIOs.png&#34; /&gt;&lt;br /&gt;
从图中我们可以看到，RaspberryPI上与SPI通信相关的主要是GPIO 10（MOSI), GPIO 9(MISO)和GPIO 11(SCLK).&lt;br /&gt;
Arduino布局图：&lt;br /&gt;
SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK). These pins support SPI communication using the SPI library. SS代表Slava Select.&lt;br /&gt;
事实上我们要使用的仅仅是11/12/13三个口而已。&lt;br /&gt;
###连线图
如下图进行连线，简单来说，R(10 MOSI)-&amp;gt;A(12 MISO), R(9, MISO)-&amp;gt;A(11, MOSI), R(11, SCLK) -&amp;gt;A(13, SCK)：&lt;br /&gt;
&lt;img src=&#34;http://purplepalmdash.github.io/images/spiconnector.jpg&#34; alt=&#34;/images/spiconnector.jpg&#34; /&gt;
###Arduino端程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Written by Nick Gammon
// February 2011
/**
 * Send arbitrary number of bits at whatever clock rate (tested at 500 KHZ and 500 HZ).
 * This script will capture the SPI bytes, when a &#39;\n&#39; is recieved it will then output
 * the captured byte stream via the serial.
 */
 
#include &amp;lt;SPI.h&amp;gt;
 
char buf [100];
volatile byte pos;
volatile boolean process_it;
 
void setup (void)
{
  Serial.begin (115200);   // debugging
 
  // have to send on master in, *slave out*
  pinMode(MISO, OUTPUT);
  
  // turn on SPI in slave mode
  SPCR |= _BV(SPE);
  //SPCR is  Arduino SPI Control Register
  // __BV&#39;s definition is like : #define _BV(bit) (1 &amp;lt;&amp;lt; (bit))
  // SPE is the register of the SPI Enable
  
  // get ready for an interrupt 
  pos = 0;   // buffer empty
  process_it = false;
 
  // now turn on interrupts
  SPI.attachInterrupt();
 
}  // end of setup
 
 
// SPI interrupt routine
ISR (SPI_STC_vect)
{
byte c = SPDR;  // grab byte from SPI Data Register
  
  // add to buffer if room
  if (pos &amp;lt; sizeof buf)
    {
    buf [pos++] = c;
    
    // example: newline means time to process buffer
    if (c == &#39;\n&#39;)
      process_it = true;
      
    }  // end of room available
}  // end of interrupt routine SPI_STC_vect
 
// main loop - wait for flag set in interrupt routine
void loop (void)
{
  if (process_it)
    {
    buf [pos] = 0;  
    Serial.println (buf);
    pos = 0;
    process_it = false;
    }  // end of flag set
    
}  // end of loop

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code Walking through:&lt;br /&gt;
Arduino SPI Control Register (SPCR), set it to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	SPCR |= _BV(SPE);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SPI Data Register (SPDR), SPI数据寄存器。 中断程序中，每次从SPDR中取回一个byte 并存储在c中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if (c == &#39;\n&#39;)
		process_it = true;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里通过设置全局变量process_it来影响loop中对接收数据的处理，在loop()中有如下代码段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if (process_it)
	{
		//.....
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面看到，如果process_it为0,则loop中一直在空循环，只有当所有的数据全部接收完毕后，才会一次性打印出所有的数据。在打印完数据后，程序将自动将buf清0, 清0是通过将pos简单置0而实现的，实际的数据其实还在。
###RaspberryPI 端程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * SPI testing utility (using spidev driver)
 *
 * Copyright (c) 2007  MontaVista Software, Inc.
 * Copyright (c) 2007  Anton Vorontsov &amp;lt;avorontsov@ru.mvista.com&amp;gt;
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * Cross-compile with cross-gcc -I/path/to/cross-kernel/include
 */
 
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;getopt.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/spi/spidev.h&amp;gt;
 
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
 
static void pabort(const char *s)
{
	perror(s);
	abort();
}
 
static const char *device = &amp;quot;/dev/spidev0.0&amp;quot;;
static uint8_t mode;
static uint8_t bits = 8;
static uint32_t speed = 500000;
static uint16_t delay;
 
static void transfer(int fd)
{
	int ret;
	uint8_t tx[] = {
        0x48, 0x45, 0x4C, 0x4C, 0x4F,
        0x20, 
        0x57, 0x4F, 0x52, 0x4C, 0x44,
        0x0A 
	};
	uint8_t rx[ARRAY_SIZE(tx)] = {0, };
	struct spi_ioc_transfer tr = {
		.tx_buf = (unsigned long)tx,
		.rx_buf = (unsigned long)rx,
		.len = ARRAY_SIZE(tx),
		.delay_usecs = delay,
		.speed_hz = speed,
		.bits_per_word = bits,
	};
 
	ret = ioctl(fd, SPI_IOC_MESSAGE(1), &amp;amp;tr);
	if (ret &amp;lt; 1)
		pabort(&amp;quot;can&#39;t send spi message&amp;quot;);
 
    /*
	for (ret = 0; ret &amp;lt; ARRAY_SIZE(tx); ret++) {
		if (!(ret % 6))
			puts(&amp;quot;&amp;quot;);
		printf(&amp;quot;%.2X &amp;quot;, rx[ret]);
	}
	puts(&amp;quot;&amp;quot;);
    */
}
 
static void print_usage(const char *prog)
{
	printf(&amp;quot;Usage: %s [-DsbdlHOLC3]\n&amp;quot;, prog);
	puts(&amp;quot;  -D --device   device to use (default /dev/spidev1.1)\n&amp;quot;
	     &amp;quot;  -s --speed    max speed (Hz)\n&amp;quot;
	     &amp;quot;  -d --delay    delay (usec)\n&amp;quot;
	     &amp;quot;  -b --bpw      bits per word \n&amp;quot;
	     &amp;quot;  -l --loop     loopback\n&amp;quot;
	     &amp;quot;  -H --cpha     clock phase\n&amp;quot;
	     &amp;quot;  -O --cpol     clock polarity\n&amp;quot;
	     &amp;quot;  -L --lsb      least significant bit first\n&amp;quot;
	     &amp;quot;  -C --cs-high  chip select active high\n&amp;quot;
	     &amp;quot;  -3 --3wire    SI/SO signals shared\n&amp;quot;);
	exit(1);
}
 
static void parse_opts(int argc, char *argv[])
{
	while (1) {
		static const struct option lopts[] = {
			{ &amp;quot;device&amp;quot;,  1, 0, &#39;D&#39; },
			{ &amp;quot;speed&amp;quot;,   1, 0, &#39;s&#39; },
			{ &amp;quot;delay&amp;quot;,   1, 0, &#39;d&#39; },
			{ &amp;quot;bpw&amp;quot;,     1, 0, &#39;b&#39; },
			{ &amp;quot;loop&amp;quot;,    0, 0, &#39;l&#39; },
			{ &amp;quot;cpha&amp;quot;,    0, 0, &#39;H&#39; },
			{ &amp;quot;cpol&amp;quot;,    0, 0, &#39;O&#39; },
			{ &amp;quot;lsb&amp;quot;,     0, 0, &#39;L&#39; },
			{ &amp;quot;cs-high&amp;quot;, 0, 0, &#39;C&#39; },
			{ &amp;quot;3wire&amp;quot;,   0, 0, &#39;3&#39; },
			{ &amp;quot;no-cs&amp;quot;,   0, 0, &#39;N&#39; },
			{ &amp;quot;ready&amp;quot;,   0, 0, &#39;R&#39; },
			{ NULL, 0, 0, 0 },
		};
		int c;
 
		c = getopt_long(argc, argv, &amp;quot;D:s:d:b:lHOLC3NR&amp;quot;, lopts, NULL);
 
		if (c == -1)
			break;
 
		switch (c) {
		case &#39;D&#39;:
			device = optarg;
			break;
		case &#39;s&#39;:
			speed = atoi(optarg);
			break;
		case &#39;d&#39;:
			delay = atoi(optarg);
			break;
		case &#39;b&#39;:
			bits = atoi(optarg);
			break;
		case &#39;l&#39;:
			mode |= SPI_LOOP;
			break;
		case &#39;H&#39;:
			mode |= SPI_CPHA;
			break;
		case &#39;O&#39;:
			mode |= SPI_CPOL;
			break;
		case &#39;L&#39;:
			mode |= SPI_LSB_FIRST;
			break;
		case &#39;C&#39;:
			mode |= SPI_CS_HIGH;
			break;
		case &#39;3&#39;:
			mode |= SPI_3WIRE;
			break;
		case &#39;N&#39;:
			mode |= SPI_NO_CS;
			break;
		case &#39;R&#39;:
			mode |= SPI_READY;
			break;
		default:
			print_usage(argv[0]);
			break;
		}
	}
}
 
int main(int argc, char *argv[])
{
	int ret = 0;
	int fd;
 
	parse_opts(argc, argv);
 
	fd = open(device, O_RDWR);
	if (fd &amp;lt; 0)
		pabort(&amp;quot;can&#39;t open device&amp;quot;);
 
	/*
	 * spi mode
	 */
	ret = ioctl(fd, SPI_IOC_WR_MODE, &amp;amp;mode);
	if (ret == -1)
		pabort(&amp;quot;can&#39;t set spi mode&amp;quot;);
 
	ret = ioctl(fd, SPI_IOC_RD_MODE, &amp;amp;mode);
	if (ret == -1)
		pabort(&amp;quot;can&#39;t get spi mode&amp;quot;);
 
	/*
	 * bits per word
	 */
	ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &amp;amp;bits);
	if (ret == -1)
		pabort(&amp;quot;can&#39;t set bits per word&amp;quot;);
 
	ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &amp;amp;bits);
	if (ret == -1)
		pabort(&amp;quot;can&#39;t get bits per word&amp;quot;);
 
	/*
	 * max speed hz
	 */
	ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &amp;amp;speed);
	if (ret == -1)
		pabort(&amp;quot;can&#39;t set max speed hz&amp;quot;);
 
	ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &amp;amp;speed);
	if (ret == -1)
		pabort(&amp;quot;can&#39;t get max speed hz&amp;quot;);
 
	printf(&amp;quot;spi mode: %d\n&amp;quot;, mode);
	printf(&amp;quot;bits per word: %d\n&amp;quot;, bits);
	printf(&amp;quot;max speed: %d Hz (%d KHz)\n&amp;quot;, speed, speed/1000);
 
	transfer(fd);
 
	close(fd);
 
	return ret;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析： 在main()函数中，设置完spi总线的相关参数后，调用transfer(fd)来传递参数。&lt;br /&gt;
transfer()函数的实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void transfer(int fd)
{
	int ret;
	uint8_t tx[] = {
        0x48, 0x45, 0x4C, 0x4C, 0x4F,
        0x20, 
        0x57, 0x4F, 0x52, 0x4C, 0x44,
        0x0A 
	};
	uint8_t rx[ARRAY_SIZE(tx)] = {0, };
	struct spi_ioc_transfer tr = {
		.tx_buf = (unsigned long)tx,
		.rx_buf = (unsigned long)rx,
		.len = ARRAY_SIZE(tx),
		.delay_usecs = delay,
		.speed_hz = speed,
		.bits_per_word = bits,
	};
 
	ret = ioctl(fd, SPI_IOC_MESSAGE(1), &amp;amp;tr);
	if (ret &amp;lt; 1)
		pabort(&amp;quot;can&#39;t send spi message&amp;quot;);
 
    /*
	for (ret = 0; ret &amp;lt; ARRAY_SIZE(tx); ret++) {
		if (!(ret % 6))
			puts(&amp;quot;&amp;quot;);
		printf(&amp;quot;%.2X &amp;quot;, rx[ret]);
	}
	puts(&amp;quot;&amp;quot;);
    */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tx即为字符串，&amp;rsquo;H&amp;rsquo;=0x48, &amp;lsquo;E&amp;rsquo;=0x45, &amp;lsquo;L&amp;rsquo;=0x4c, &amp;lsquo;L&amp;rsquo;=0x4c, &amp;lsquo;O&amp;rsquo;=0x4f, &amp;lsquo; &amp;lsquo;=0x20, &amp;lsquo;W&amp;rsquo;=0x57, &amp;lsquo;O&amp;rsquo;=0x4f, &amp;lsquo;R&amp;rsquo;=0x52, &amp;lsquo;L&amp;rsquo;=0x4c, &amp;rsquo;D&amp;rsquo;=0x44, &amp;lsquo;\n&amp;rsquo;=0x0a.&lt;br /&gt;
实际传送则是调用：
    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &amp;amp;tr);
有关它的解释如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
	  72 * Pass it an array of related transfers, they&#39;ll execute together.
	  73 * Each transfer may be half duplex (either direction) or full duplex.
	  74 *
	  75 *      struct spi_ioc_transfer mesg[4];
	  76 *      ...
	  77 *      status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);

	#define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用完transfer()函数后，调用close()来关闭文件描述符。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>