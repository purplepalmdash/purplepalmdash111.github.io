<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embedded on Dash</title>
    <link>http://purplepalmdash.github.io/categories/embedded/</link>
    <description>Recent content in Embedded on Dash</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 May 2017 16:30:08 +0800</lastBuildDate>
    
	<atom:link href="http://purplepalmdash.github.io/categories/embedded/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OpenWRT MR11u</title>
      <link>http://purplepalmdash.github.io/blog/2017/05/05/openwrt-mr11u/</link>
      <pubDate>Fri, 05 May 2017 16:30:08 +0800</pubDate>
      
      <guid>http://purplepalmdash.github.io/blog/2017/05/05/openwrt-mr11u/</guid>
      <description>Upgrade kernel On OpenWRT:
$ cd /tmp $ wget http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/openwrt-ar71xx-generic-tl-mr11u-v2-squashfs-sysupgrade.bin $ sysupgrade -v openwrt-ar71xx-generic-tl-mr11u-v2-squashfs-sysupgrade.bin  Make sure your configuration is listed as following:
# cat /etc/opkg/distfeeds.conf src/gz designated_driver_base http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/base src/gz designated_driver_kernel http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/kernel src/gz designated_driver_telephony http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/telephony src/gz designated_driver_packages http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/packages src/gz designated_driver_routing http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/routing src/gz designated_driver_luci http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/luci src/gz designated_driver_management http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/management # src/gz designated_driver_targets http://openwrt.proxy.ustclug.org/snapshots/trunk/ar71xx/generic/packages/targets  Then opkg update, and install following packages:
$ opkg install block-mount kmod-fs-ext4 kmod-usb-ohci kmod-usb-storage  But the storage is too slow.</description>
    </item>
    
    <item>
      <title>将网站转化为Android应用程序</title>
      <link>http://purplepalmdash.github.io/blog/2017/01/13/%E5%B0%86%E7%BD%91%E7%AB%99%E8%BD%AC%E5%8C%96%E4%B8%BAandroid%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Fri, 13 Jan 2017 19:22:37 +0800</pubDate>
      
      <guid>http://purplepalmdash.github.io/blog/2017/01/13/%E5%B0%86%E7%BD%91%E7%AB%99%E8%BD%AC%E5%8C%96%E4%B8%BAandroid%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>写了几年博客，博文已有数百篇，于是我想能不能把每次需要上网搜索的过程改为在手机端本地查找呢？
看了下网上的解决方案，参考了以下这个，可以作为静态网站APP化的第一步。
参考链接:
http://www.vetbossel.in/convert-website-to-android-application/
构建开发环境 ArchLinux下安装android-studio的方法是通过yaourt:
$ yaourt -S android-studio  需要注意的是，安装过程中需要访问Google网站，因而需要代理（你懂的）。而安装完毕后，需要安装本地模拟器，下载 img也需要用到代理。确保你翻墙的速度够快。
运行模拟器会出错，可以通过以下两个步骤来纠正:
$ yaourt glxinfo $ cd ~/Android/Sdk/tools/lib64/libstdc++/ $ mv libstdc++.so.6 libstdc++.so.6.back $ ln -s /usr/lib/libstdc++.so.6 ~/Android/Sdk/tools/lib64/libstdc++/libstdc++.so.6  开发 开发步骤可以参考原文。
值得注意的是，在MainActivity.java文件中，第一行需要改正为正确的包名，否则会出现编译错误。
- package com.example.vetri.websitetoapplication; + package com.example.dash.websitetoapplication;  执行 实际运行的效果如下:
想法 在Android端已经可以有简单的Web服务器，考虑把hugo生成的网站内容上传到Android手机内的Web服务器上。
因为网站是本地化的，所以可以去掉一切不需要的插件，例如disqus之类。</description>
    </item>
    
    <item>
      <title>NodeMCU and 1602I2C(1)</title>
      <link>http://purplepalmdash.github.io/2016/04/01/nodemcu-and-1602i2c-1/</link>
      <pubDate>Fri, 01 Apr 2016 18:00:38 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/04/01/nodemcu-and-1602i2c-1/</guid>
      <description>今天更新了一下代码，实现了两行显示，第一行显示CPU Load，第二行显示剩余内存数。
只是部分替代数据显示部分，这个代码还是有BUG的，譬如说最后一位在下一次显示时不会被清零。
import psutil import serial import time # Setup the Serial Port and open it. ser = serial.Serial() ser.baudrate = 9600 ser.port = &#39;/dev/ttyUSB0&#39; ser.open() ## Todo, to check if the port is opened. # Really talks to the i2c LCD. # Setup the wiring ser.write(b&#39;i2c.setup(0, 4, 3, i2c.SLOW)\r\n&#39;) # dofile, load the lcd library ser.write(b&#39;lcd = dofile(&amp;quot;lcd1602.lua&amp;quot;)()\r\n&#39;) # Now Refresh the LCD. ser.write(b&#39;lcd.clear()\r\n&#39;) #ser.write(b&#39;lcd.put(lcd.light(on))\r\n&#39;) ser.write(b&#39;lcd.put(lcd.locate(0, 0), &amp;quot;CPU Load: &amp;quot;)\r\n&#39;) ser.</description>
    </item>
    
    <item>
      <title>NodeMCU And 1602I2C</title>
      <link>http://purplepalmdash.github.io/2016/03/31/nodemcu-and-1602i2c/</link>
      <pubDate>Thu, 31 Mar 2016 21:34:42 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/31/nodemcu-and-1602i2c/</guid>
      <description>最初入手的1602是N个口的, 激活它需要耗掉开发板上N个GPIO口,为此做完Arduino上的实 验就收了起来. 这次采购中看到店家有卖1602 I2C的转接卡,3块钱,顺手就买了回来.打算 用来做一个WIFI显示屏.
今天做了一个NodeMCU和1602连接实时显示CPU使用率的方案, 如下图所示,这里简单记录 一下制作过程.
连线图 1602 I2C上有四个口,分别是GND/VCC/SDA/SCL.
GND自然不用多说,连接NodeMCU上的GND即可.
VCC我们使用5V输入,在NodeMCU上则是VIN口. 在下图里我用红色做了标注.
SDA接GPIO0, SDC接GPIO2,在图中我用橙色做了标识.
软件准备 我这里参考了 http://domoticx.com/esp8266-wifi-lcd-1602-2004-via-i2c-nodemcu/ 上的实例, 所以用ESPlorer来写入1602的库文件. ESPlorer的下载地址在:
http://esp8266.ru/esplorer/#download
如果你使用的是ArchLinux的话,一行命令就够了:
$ yaourt esplorer  如果你运行上述网址上的示例, 故事的结尾你会获得一个Hallo的显示,以及跑马灯式的显 示效果.
CPU Load Program 先上代码, 用Python写的, 如果你看过上面的示例程序就会明白, 往串口写入1602的lua 脚本,就能获得对应的显示效果,那么以下的Python代码就是每分钟读取CPU的负载值, 将 它封装在一个字符串中发送到NodeMCU连接的串口.
import psutil import serial import time # Setup the Serial Port and open it. ser = serial.Serial() ser.baudrate = 9600 ser.port = &#39;/dev/ttyUSB0&#39; ser.open() ## Todo, to check if the port is opened.</description>
    </item>
    
    <item>
      <title>Tips On NodeMCU</title>
      <link>http://purplepalmdash.github.io/2016/03/27/tips-on-nodemcu/</link>
      <pubDate>Sun, 27 Mar 2016 09:30:05 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/27/tips-on-nodemcu/</guid>
      <description>电路图 在淘宝上买的NodeMCU是v1.0版的, v0.9版和v1.0版的差别如下:
1.0版的连线如图:
烧写固件 ArchLinux下,可以通过python程序直接烧写固件.
下载integer版本的固件,
$ wget https://github.com/nodemcu/nodemcu-firmware/releases/download/0.9.6-dev_20150704/nodemcu_integer_0.9.6-dev_20150704.bin  下载esp-tool, ArchLinux需要安装python2版本的pyserial库才能运行该软件:
$ git clone https://github.com/themadinventor/esptool.git $ sudo pacman -S python2-pyserial $ sudo python2 ./esptool.py --port /dev/ttyUSB0 --write_flash 0x0000 ../nodemcu_integer_0.9.6-dev_20150704.bin  Minicom串口 Minicom串口配置如下:
烧写完固件后,最简单的测试如下:
&amp;gt; print &amp;quot;Hello World&amp;quot; Hello World  同时我们可以看下NodeMCU的版本,命令如下:
&amp;gt; majorVer, minorVer, devVer, chipid, flashid, flashsize, flashmode, flashspeed = node.info(); &amp;gt; print(&amp;quot;NodeMCU &amp;quot;..majorVer..&amp;quot;.&amp;quot;..minorVer..&amp;quot;.&amp;quot;..devVer) NodeMCU 0.9.6  可以看到我们使用的固件版本是0.9.6的.
闪烁LED NodeMCU支持LUA编程,为此我们需要准备另一个写入LUA脚本的小程序:
$ git clone https://github.com/4refr0nt/luatool.git  NodeMCU板上自带有两个LED, 我们先点亮D4口,即GPIO2口上的LED:</description>
    </item>
    
    <item>
      <title>Tips on 5050RGB(2)</title>
      <link>http://purplepalmdash.github.io/2016/03/17/tips-on-5050rgb-2/</link>
      <pubDate>Thu, 17 Mar 2016 13:09:12 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/17/tips-on-5050rgb-2/</guid>
      <description>上次的5050RGB模块损坏后, 我又从淘宝买了一块. 价格不贵,4块钱不到. 卖家的资料上 这么写着:
瞅着还挺OK的,不就是Arduino板5V电压外接,然后用三个GPIO口来控制嘛. 接线完毕后发 现怎么也点不亮.
于是用万用表Debug, 发现公共端应该是接GND, 三个控制端需要电平置为高才可以点亮对 应的颜色.
于是正确的连线和示例代码如下:
// V-VCC GND R-9 B-10 G-11 #define LEDR 9 #define LEDB 10 #define LEDG 11 void clear() { analogWrite(LEDR,0); analogWrite(LEDB,0); analogWrite(LEDG,0); //off } void setup() { pinMode(LEDG,OUTPUT); pinMode(LEDB,OUTPUT); pinMode(LEDR,OUTPUT); } void loop() { clear(); // Red analogWrite(LEDR,255); delay(1000); clear(); // Green analogWrite(LEDG,255); delay(1000); clear(); // Blue analogWrite(LEDB,255); delay(1000); // White analogWrite(LEDB,255); analogWrite(LEDG,255); analogWrite(LEDR,255); delay(2000); }  编译并上传代码到Arduino板子上, LED将呈现成红色-&amp;gt;绿色-&amp;gt;蓝色-&amp;gt;白色的渐变.</description>
    </item>
    
    <item>
      <title>Tips On 5050RGB</title>
      <link>http://purplepalmdash.github.io/2016/03/12/tips-on-5050rgb/</link>
      <pubDate>Sat, 12 Mar 2016 19:32:42 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/12/tips-on-5050rgb/</guid>
      <description>背景 淘宝上买的5050RGB模块, 外观如下图:
连线:
这个RGB模块比较奇怪,直接使用Arduino的5v输出一直有问题,我是用的外接5V电源供电, 动用了面包板模块.(之后发现不是供电的问题, 是因为淘宝上卖的模块提供示例代码的问 题)
更具体的连线如下:
// V-VCC 5V R-9 B-10 G-11 #define LEDR 9 #define LEDB 10 #define LEDG 11  测试 按照厂方提供的程序,未能成功运行.
厂方提供的电路图如下:
Debug 百思不得其解后,用万用表测试, 电阻发声的那档, 发现加电后,某两个LED可以亮, 另外 一个不能亮.
发现奇怪的一点是, VCC接高电压, RGB接低电压时, 无法点亮LED. RGB接高电压, VCC接 低电压时, LED可以被点亮两个.
猜测: 厂方给的参考资料有误, 接线错误. 而且LED坏了一个.
验证, 正确.
连线更改为:
// V-VCC 5V R-9 B-10 G-11 #define LEDR 9 #define LEDG 10  蓝色的LED已坏, 所以示例代码中,不许配置LEDB.
// V-VCC GND R-9 G-10 #define LEDR 9 #define LEDG 10 int i = 0; void setup() { pinMode(LEDG,OUTPUT); pinMode(LEDR,OUTPUT); } void loop() { analogWrite(LEDR,0); analogWrite(LEDG,0); //off delay(1000); analogWrite(LEDR,255); delay(1000); analogWrite(LEDR,0); analogWrite(LEDG,0); delay(1000); analogWrite(LEDR,30); analogWrite(LEDG,200); delay(1000); analogWrite(LEDR,0); analogWrite(LEDG,0); delay(1000); analogWrite(LEDG,30); analogWrite(LEDR,200); delay(1000); }  正确的电路连线应该是:</description>
    </item>
    
    <item>
      <title>Tips on w5100</title>
      <link>http://purplepalmdash.github.io/2016/03/11/tips-on-w5100/</link>
      <pubDate>Fri, 11 Mar 2016 22:00:50 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/11/tips-on-w5100/</guid>
      <description>参考 参考如下:
http://www.bigiot.net/help/6.html
问题 上报的数据不准确.
原因是因为W5100抄版的淘宝版本有短路, 换成别的模拟口:
const int LM35 = 3;//LM35 pin byte mac[] = {0x00, 0x1D, 0x72, 0x82, 0x35, 0x9D}; EthernetClient client ; IPAddress ip(192, 168, 17, 177);//local IP //IPAddress server(121,42,180,30); char server[] = &amp;quot;www.bigiot.net&amp;quot;;  连线改为了3, 即A3口以后,上报数据成功.</description>
    </item>
    
    <item>
      <title>Tips on V-USB and Arduino(5)</title>
      <link>http://purplepalmdash.github.io/2016/03/07/tips-on-v-usb-and-arduino-5/</link>
      <pubDate>Mon, 07 Mar 2016 21:52:47 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/07/tips-on-v-usb-and-arduino-5/</guid>
      <description>这一节将添加一个LED到已有的方案中. 这个LED将使用11口, 通过./set-led new来设 置状态.
连线 新加一个LED如图:
仅仅添加了一个LED + 220欧电阻.
代码修改 requests.h 添加新的request定义:
diff --git a/requests.h b/requests.h index 90275f5..b354a73 100644 --- a/requests.h +++ b/requests.h @@ -32,4 +32,6 @@ #define CUSTOM_RQ_BLINK 3 +#define CUSTOM_RQ_NEWLED 4 +  hid_custom_rq.h 添加新的管脚, 和对CUSTOM_RQ_NEWLED的处理代码:
diff --git a/hid_custom_rq.h b/hid_custom_rq.h index f5509e4..b5411cf 100644 --- a/hid_custom_rq.h +++ b/hid_custom_rq.h @@ -13,6 +13,7 @@ class hid_custom_rqDevice { hid_custom_rqDevice () { usbInit(); ledPin = 13; // pin 13 as default ledPin + newledPin = 11; // pin 11 as newledPin } void poll() { @@ -20,6 +21,7 @@ class hid_custom_rqDevice { } unsigned int ledPin; + unsigned int newledPin; }; hid_custom_rqDevice hid_custom_rq = hid_custom_rqDevice(); @@ -99,6 +101,14 @@ usbMsgLen_t usbFunctionSetup(uchar data[8]) usbMsgPtr = dataBuffer; /* tell the driver which data to return */ return 1; /* tell the driver to send 1 byte */ } + /* Added for newly added LED */ + else if(rq-&amp;gt;bRequest == CUSTOM_RQ_NEWLED){ + if(rq-&amp;gt;wValue.</description>
    </item>
    
    <item>
      <title>Tips on V-USB and Arduino(4)</title>
      <link>http://purplepalmdash.github.io/2016/03/07/tips-on-v-usb-and-arduino-4/</link>
      <pubDate>Mon, 07 Mar 2016 21:07:53 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/07/tips-on-v-usb-and-arduino-4/</guid>
      <description>前面把玩了一下ebuddy, 回去想了一下, 觉得基于v-usb和arduino来实现 一个自己的ebuddy也不是特别难的事情.
思路 还是参考:
V-USB examples for Arduino
以hid_custom_rq项目来改. 例子里已经实现了Arduino板载的LED亮/灭. 我们只需要在 原例上修改, 添加自定义命令和硬件即可.
代码 示例代码我做完后放到了github上, 可以通过以下命令获得:
$ git clone git@github.com:purplepalmdash/arduino-usb-led.git  主要修改 request.h 这个头文件被USB固件和主机所共享, 定义了USB的request number数字, request number 被用于主机和设备之间的通信.
添加:
#define CUSTOM_RQ_BLINK 3  hid_custom_rq.h 这个文件是Arduino板上固件程序中对各种来自主机的request信息的响应, 或者说, 消息 处理函数.
针对上面在requst.h文件中添加的消息, 我们需要在usbFunctionSetup()函数中添加 对应的消息处理代码, 为简单起见, 直接添加在函数的入口处就好.
 usbMsgLen_t usbFunctionSetup(uchar data[8]) { usbRequest_t *rq = (usbRequest_t *)((void *)data); + if(rq-&amp;gt;bRequest == CUSTOM_RQ_BLINK){ /* blink -- used for blink the LED */ + /* First set the led pin to high */ + unsigned char i = 6; + while(i &amp;gt;= 1) + { + digitalWrite(hid_custom_rq.</description>
    </item>
    
    <item>
      <title>把玩ebuddy(2)</title>
      <link>http://purplepalmdash.github.io/2016/03/03/ba-wan-ebuddy-2/</link>
      <pubDate>Thu, 03 Mar 2016 10:15:43 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/03/ba-wan-ebuddy-2/</guid>
      <description>ArchLinux配置过程 因为ArchLinux默认python版本为python3, 使用python2激活e-buddy人偶:
$ sudo pacman -S python2-pip $ sudo pip2 install pyusb $ git clone git@github.com:purplepalmdash/pybuddy-dx.git $ sudo python2 ~/Code/ebuddy/pybuddy-dx/pybuddyDX.py $ sudo netstat -anp | grep 8888 udp 0 0 127.0.0.1:8888 0.0.0.0:* 14635/python2  接下来就是往127.0.0.1:8888发送指令控制人偶的干活了。具体的指令可以见上一篇文章。
定期检查邮件控制人偶 先安装用于检查imap服务端状态的python模块:
$ sudo pip2 install imapclient  检查邮件的脚本如下, 该脚本检查163邮箱的IMAP服务器，如果有新邮件，人偶的头就会出现颜色渐 变，否则，则显示绿灯闪烁:
#!/usr/bin/env python import imaplib from imapclient import IMAPClient import time import subprocess import thread DEBUG = True HOSTNAME = &#39;imap.163.com&#39; USERNAME = &#39;XXXXXXXX&#39; PASSWORD = &#39;XXXXXXXX&#39; MAILBOX = &#39;Inbox&#39; newmails = 0 NEWMAIL_OFFSET = 0 # my unread messages never goes to zero, yours might MAIL_CHECK_FREQ = 60 # check mail every 60 seconds # Define a function for checking email def check_mail( threadName): while True: # Login into the imap server and check the numbers for the new mail.</description>
    </item>
    
    <item>
      <title>e-buddy消息提醒服务设计思路(1)</title>
      <link>http://purplepalmdash.github.io/2016/03/01/e-buddyxiao-xi-ti-xing-fu-wu-she-ji-si-lu-1/</link>
      <pubDate>Tue, 01 Mar 2016 19:47:55 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/01/e-buddyxiao-xi-ti-xing-fu-wu-she-ji-si-lu-1/</guid>
      <description>设计目的 设计为一个系统通用的? 还是特定应用的?
监控 vs 告警 监控某项指标? 然后告警?
总线? DBUS 总线?
D-Bus For Python.</description>
    </item>
    
    <item>
      <title>把玩e-Buddy</title>
      <link>http://purplepalmdash.github.io/2016/03/01/ba-wan-e-buddy/</link>
      <pubDate>Tue, 01 Mar 2016 10:47:55 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/03/01/ba-wan-e-buddy/</guid>
      <description>状态 逆向工程得出的控制指令:
################ #Commands ################ # GLADNESS = 00 # FEAR = 01 # FIZZ = 02 # PLEASANTSURPRISE =03 # GRIEF = 04 # FURY = 05 # QUELL = 06 # REDHEAD = 07 # GREENHEAD = 08 # BLUEHEAD = 09 # YELLOWHEAD = 10 # BLAME = 11 # BLUEGREENHEAD = 12 # WHITEHEAD = 13 # HEART = 14 # WINGS = 15 # BODY = 16 # NOEFFECT = 17 # ONLINE = 18 # BUSY = 19 # DAZE = 20 # BACKSOON = 21 # AWAY = 22 # PHONE = 23 # LUNCH = 24 # OFFLINE = 25  功能列表:</description>
    </item>
    
    <item>
      <title>Tips on V-USB and Arduino(3)--Others</title>
      <link>http://purplepalmdash.github.io/2016/02/29/tips-on-v-usb-and-arduino-3-others/</link>
      <pubDate>Mon, 29 Feb 2016 11:50:09 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/02/29/tips-on-v-usb-and-arduino-3-others/</guid>
      <description>连线/电路 不需要对电路做任何修改，仅替换arduino里的程序即可。
代码 代码如下:
hid_custom_rq/ hid_data/ hid_mouse/  编译方法和上面一样。
值得注意的是, 这三个设备都是实现了HID设备，可以做到即插即用。
hid_data的用法：
读取/写入例子:
➜ commandline ./hidtool read 0x01 0x02 0x03 0x04 0x05 0x06 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 ➜ commandline .</description>
    </item>
    
    <item>
      <title>Tips On V-USB And Arduino(2)--用v-usb控制LED</title>
      <link>http://purplepalmdash.github.io/2016/02/26/tips-on-v-usb-and-arduino-2/</link>
      <pubDate>Fri, 26 Feb 2016 17:07:20 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/02/26/tips-on-v-usb-and-arduino-2/</guid>
      <description>参考 参考链接如下(需翻墙):
V-USB examples for Arduino
连线图 链接里的连线图如下:
这个图我想了很久，对比上一节里键盘的连线图对比，发现D+/D-的连线刚好是反过来的。此外就是 D-上加了一个上拉电阻， 电阻值为1.5K， 这个其实没关系，在我们的例子中，用到2.2K，是因为 我们用的参考电压是5V的。
对上一章我们的连线图进行修改，得出的连线图如下:
电路图如下:
上一章用到的开关可以不用拆除。
值得注意的是，2.2K的上拉电阻接到了5V输入。
代码 下载Windows版0022 Arduino，编译原帖中pde文件并上传，修改 hardware/arduino/cores/arduino/wiring.c里的:
SIGNAL(TIMER0_OVF_vect) { ++++++ sei() ...... }  客户端程序编译:
➜ pwd ......../custom_class/examples/custom_class_demo/commandline ➜ make clean rm -f *.o set-led ➜ make  使用./set-led即可，编译前需要修改头文件:
$ vim set-led.c //#include &amp;quot;../firmware/requests.h&amp;quot; /* custom request numbers */ //#include &amp;quot;../firmware/usbconfig.h&amp;quot; /* device&#39;s VID/PID and names */ #include &amp;quot;../../../requests.h&amp;quot; /* custom request numbers */ #include &amp;quot;.</description>
    </item>
    
    <item>
      <title>Tips On V-USB And Arduino(1)- USB Keyboard</title>
      <link>http://purplepalmdash.github.io/2016/02/26/tips-on-v-usb-and-arduino-1/</link>
      <pubDate>Fri, 26 Feb 2016 16:55:10 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/02/26/tips-on-v-usb-and-arduino-1/</guid>
      <description>参考 主要参考了:
Arduino学习笔记A11 - Arduino模拟电脑键盘（基于AVR-USB的USB-HID设备）
电路图 安装Fritzing后，可以绘制出面包板连线图和电路图:
电路图:
注意事项:
电阻换成100欧也可以，原帖中是68欧电阻。
注意齐纳二极管的极性，带有色条的一端是负极。
代码 值得注意的配置如下:
#define USB_CFG_IOPORTNAME D USB输入输出引脚使用AVR单片机的PORTD，如果改成B就是使用PORTB #define USB_CFG_DMINUS_BIT 4 USB的D-接PORTD的第四位PD4，对应Arduino D4 #define USB_CFG_DPLUS_BIT 2 USB的D+接PORTD的第二位PD2，对应Arduino D2 #define USB_CFG_PULLUP_IOPORTNAME D USB上拉引脚使用AVR单片机的PORTD，如果改成B就是使用PORTB #define USB_CFG_PULLUP_BIT 5 USB的上拉电阻接PORTD的第五位PD5，对应Arduino D5  在Arduino1.0.5上编译/配置都没有问题，最好在0022～1.05的版本范围内进行实验。
首先通过USBasp线写入编译后的程序，而后换上我们添加的USB线缆后，点击按键，每次即可输出 hello world字符串。</description>
    </item>
    
    <item>
      <title>Playing e-Buddy</title>
      <link>http://purplepalmdash.github.io/2016/02/23/playing-e-buddy/</link>
      <pubDate>Tue, 23 Feb 2016 09:36:58 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/02/23/playing-e-buddy/</guid>
      <description>Python Library Clone the repository from google Code to github, then clone it to local:
This library could makes the ebuddy dance and sing.
$ git clone git@github.com:purplepalmdash/pybuddy-dx.git  Environment Since ArchLinux runs python3, we need to create a virtualenv for running python2.7
$ virtualenv2 venv2 --python=python2.7 ✗ . ~/venv2/bin/activate (venv2) ➜ _posts git:(master) ✗ python Python 2.7.11 (default, Dec 6 2015, 15:43:46) [GCC 5.2.0] on linux2 $ pip install pyusb  Modification Modify the source code, mainly change the following lines:</description>
    </item>
    
    <item>
      <title>USB Cute Things</title>
      <link>http://purplepalmdash.github.io/2016/02/18/usb-cute-things/</link>
      <pubDate>Thu, 18 Feb 2016 18:04:42 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/02/18/usb-cute-things/</guid>
      <description>Funny Things on Taobao:
USB新奇特 带HUB HUB USB邮件通知提醒器 USB Webmail Notifier https://item.taobao.com/item.htm?spm=a230r.1.14.7.1r483a&amp;amp;id=19165960441&amp;amp;ns=1&amp;amp;abbucket=5#detail Dream Cheeky USB Friends Alert 邮件消息提醒器 还用老旧的邮箱？来，一起怀个旧吧。这个小东西能帮你提醒邮件状态，支持Facebook、Twitter、 MSN的消息呢，哦，差点忘记了，只有MSN你偶尔可以玩一下。 https://item.taobao.com/item.htm?spm=a230r.1.14.13.1r483a&amp;amp;id=523240173722&amp;amp;ns=1&amp;amp;abbucket=5#detail i-buddy: https://item.taobao.com/item.htm?spm=a230r.1.14.1.aWRsP6&amp;amp;id=5177828698&amp;amp;ns=1&amp;amp;abbucket=5#detail https://2.taobao.com/item.htm?id=521593051559&amp;amp;spm=a230r.1.14.12.CcgnsG&amp;amp;ns=1&amp;amp;abbucket=5#detail USB Webmail Notifer USB邮件通知器 USB Webmail Notifer USB邮件通知器 https://item.taobao.com/item.htm?spm=a230r.1.14.36.BVZqTi&amp;amp;id=2719139321&amp;amp;ns=1&amp;amp;abbucket=5#detail HX USB温度计TEMPer 机房/库房 温度计 环境监测 防水 邮件提醒 https://detail.tmall.com/item.htm?spm=a230r.1.14.4.BVZqTi&amp;amp;id=40327431222&amp;amp;cm_id=140105335569ed55e27b&amp;amp;abbucket=5 taobao ebuddy http://www.computersolutions.cn/blog/category/tao-bao/ AIDA64 On Digital Frame http://bbs.yleee.com.cn/thread-30787-1-1.html  </description>
    </item>
    
    <item>
      <title>Hacking SteelSeries Engine 3 USB Mouse Under Linux</title>
      <link>http://purplepalmdash.github.io/2016/02/03/hacking-steelseries-engine-3-usb-mouse-under-linux/</link>
      <pubDate>Wed, 03 Feb 2016 18:36:19 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2016/02/03/hacking-steelseries-engine-3-usb-mouse-under-linux/</guid>
      <description>Background Since SteelSeries Engine 3 USB mouse have only driver for Windows/MAC, I want to enable the changing color under Linux, following is the hacking steps.
Catching Packets Using Wireshark for capturing the USB Packages of mouse, at the meantime, use another mouse for clicking the setting color area, to capture the setting color events, After this we sent the captured packets to Linux machine for analysing.
Setting Color With the filter and continue for anlysing, found each setting step includes 3 steps.</description>
    </item>
    
    <item>
      <title>Bluetooth NAP How-To</title>
      <link>http://purplepalmdash.github.io/2015/12/05/bluetooth-nap-how-to/</link>
      <pubDate>Sat, 05 Dec 2015 20:03:41 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2015/12/05/bluetooth-nap-how-to/</guid>
      <description>Notice Notice, this way is only for Bluez-5!!!!
Refers to:
https://wiki.gentoo.org/wiki/Bluetooth_Network_Aggregation_Point
https://wiki.gentoo.org/wiki/Bluetooth
http://blog.fraggod.net/2015/03/28/bluetooth-pan-network-setup-with-bluez-5x.html
Bluez-4 could be much more easier via pand. For example, in ubuntu you could setup the bluetooth PAN via:
http://blog.sumostyle.net/2009/11/ubuntu-tethering-via-bluetooth-pan/
RF-KILL Use rfkill for unblock the soft-blocked bluetooth adapter:
[root@xxxx dash]# rfkill list bluetooth 2: hp-bluetooth: Bluetooth Soft blocked: yes Hard blocked: no 5: hci1: Bluetooth Soft blocked: yes Hard blocked: no [root@xxxx dash]# rfkill unblock bluetooth # rfkill list bluetooth 2: hp-bluetooth: Bluetooth Soft blocked: no Hard blocked: no 5: hci1: Bluetooth Soft blocked: no Hard blocked: no  bluetoothctl Use bluetoothctl for configurating the bluetooth adapter:</description>
    </item>
    
    <item>
      <title>FRDM-KL02Z Tips(1)</title>
      <link>http://purplepalmdash.github.io/2015/11/05/frdm-kl02z-tips-1/</link>
      <pubDate>Thu, 05 Nov 2015 09:53:38 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2015/11/05/frdm-kl02z-tips-1/</guid>
      <description>Reference Material:
http://www.freescale.com/zh-Hans/products/arm-processors/kinetis-cortex-m/l-series/freedom-development-platform-for-the-kinetis-kl02-family:FRDM-KL02Z?tab=In-Depth_Tab
Minicom 115200/data-bit: 8/ no parity/stop bit 1.</description>
    </item>
    
    <item>
      <title>Modification SWAP on RPI Installation</title>
      <link>http://purplepalmdash.github.io/2015/04/30/modification-on-rpi-installation/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2015/04/30/modification-on-rpi-installation/</guid>
      <description>First disable the swap partition, for it will save your sd card:
Know where is your swap file:
$ cat /proc/swap*  Disable it via change the S to K under /etc/rcx.d, and reboot the services:
$ sudo mv S02dphys-swapfile K02dphys-swapfile  </description>
    </item>
    
    <item>
      <title>Enable Bluetooth Playing</title>
      <link>http://purplepalmdash.github.io/2015/03/08/enable-bluetooth-playing/</link>
      <pubDate>Sun, 08 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2015/03/08/enable-bluetooth-playing/</guid>
      <description>First scan the bluetooth adapter via lsusb:
$ lsusb Bus 005 Device 002: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)  Install packages and configure bluetooth:
$ sudo apt-get install bluetooth $ sudo apt-get install bluez-utils $ sudo apt-get install blueman  Then setup the bluetooth headset in blueman&amp;rsquo;s graphical interface.
The more detailed steps are available at:
http://kkkttt.github.io/blog/2013/12/19/bluetooth-headset-on-archlinux/</description>
    </item>
    
    <item>
      <title>Upgrade OpenWRT on MW151RM3G</title>
      <link>http://purplepalmdash.github.io/2014/11/24/upgrade-openwrt-on-mw151rm3g/</link>
      <pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/24/upgrade-openwrt-on-mw151rm3g/</guid>
      <description>Prepare First go to http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/, find the &amp;ldquo;wr703n&amp;rdquo;, download the 2 files.
$ ls -l openwrt* -rw-r----- 1 Trusty root 3932160 Nov 24 13:50 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin -rw-r----- 1 Trusty root 3342340 Nov 24 13:50 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-sysupgrade.bin  sysupgrade.bin is for upgrading.
Upgrade System-&amp;gt; Backup/Flash Firmware.
Flash New firmware image, choose File. Select the sysupgrade.bin, Upgrade.
Tehn you have to wait for the changes to be applied, around half a miniutes, then everything will be OK.</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB - PWM</title>
      <link>http://purplepalmdash.github.io/2014/11/16/ebc-exercises-on-bbb-pwm/</link>
      <pubDate>Sun, 16 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/16/ebc-exercises-on-bbb-pwm/</guid>
      <description>PWM Simply enable the P9_21 to PWM, then connect to the LED. The LED connection could refer to EBC Exercises on BBB - Control LED
SLOTS=/sys/devices/bone_capemgr.*/slots echo am33xx_pwm &amp;gt; $SLOTS echo bone_pwm_P9_21 &amp;gt; $SLOTS cd /sys/devices/ocp.3/pwm_test_P9_21.15/ echo 1000000000 &amp;gt; period echo 250000000 &amp;gt; duty echo 1 &amp;gt; run  From now you could see the LED begin to flash. In fact using this pwm we could control servo motor:</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB -GPIO Via Mmap</title>
      <link>http://purplepalmdash.github.io/2014/11/16/gpio-via-mmap/</link>
      <pubDate>Sun, 16 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/16/gpio-via-mmap/</guid>
      <description>Operate On Device Tree Turn off the trigger and then shine on the LED USR3 via following command:
root@arm:~# cd /sys/class/leds/beaglebone\:green\:usr3 root@arm:/sys/class/leds/beaglebone:green:usr3# ls brightness device max_brightness power subsystem trigger uevent root@arm:/sys/class/leds/beaglebone:green:usr3# echo none &amp;gt; trigger root@arm:/sys/class/leds/beaglebone:green:usr3# echo 1 &amp;gt; brightness  We could find the gpio is attached to which pin:
# ./findGPIO.js USR3 { name: &#39;USR3&#39;, gpio: 56, led: &#39;usr3&#39;, mux: &#39;gpmc_a8&#39;, key: &#39;USR3&#39;, muxRegOffset: &#39;0x060&#39;, options: [ &#39;gpmc_a8&#39;, &#39;gmii2_rxd3&#39;, &#39;rgmii2_rd3&#39;, &#39;mmc2_dat6&#39;, &#39;gpmc_a24&#39;, &#39;pr1_mii1_rxd0&#39;, &#39;mcasp0_aclkx&#39;, &#39;gpio1_24&#39; ] } USR3 (gpio 56) mode: 7 (gpio1_24) 0x060 pullup pin 24 (44e10860): (MUX UNCLAIMED) (GPIO UNCLAIMED)  gpio1_24 is what we want.</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB -i2c and BBB</title>
      <link>http://purplepalmdash.github.io/2014/11/16/i2c-and-bbb/</link>
      <pubDate>Sun, 16 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/16/i2c-and-bbb/</guid>
      <description>Connection HMC5883L magnetometer runs in 400KHZ I2C bus, it&amp;rsquo;s for measuring the magnetic field vector in 3 dimensions.
We use its 4 ports: VCC,GND,SDA, SCL. SDA is for Data, while SCL is for Clock.
Use P9 for connecting the HMC5883L.
P9_02(GND) &amp;lt;----&amp;gt; GND P9_04(VCC) &amp;lt;----&amp;gt; VCC P9_19(I2C2_SCL) &amp;lt;----&amp;gt; SCL	I2C bus 2(pin 19 on header p9 to SCL) P9_20(I2C2_SDA) &amp;lt;----&amp;gt; SDA	 I2C Detect First you should install i2cdetect, then list the avaiable i2c bus via following command:</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB</title>
      <link>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb/</guid>
      <description>Tips on Building Kenrel Via following commands you could build the 3.8 kernel for BBB:
$ git clone git://github.com/RobertCNelson/linux-dev.git $ cd linux-dev $ git checkout origin/am33x-v3.8 -b am33x-v3.8 $ time git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git $ cp system.sh.sample system.sh $ diff system.sh* 15c15 &amp;lt; CC=arm-linux-gnueabi- --- &amp;gt; #CC=arm-linux-gnueabi- 21c21 &amp;lt; LINUX_GIT=~/BeagleBoard/linux-stable/ --- &amp;gt; #LINUX_GIT=/home/user/linux-stable/ 31c31 &amp;lt; ZRELADDR=0x80008000 --- &amp;gt; #ZRELADDR=0x80008000 $ ./build_kernel.sh  U-boot Cross-compile Download the U-boot and cross-compile it.</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB - Control LED</title>
      <link>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb-control-led/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb-control-led/</guid>
      <description>Using Sysfs The easiest way to do general purpose I/O(gpio) on BBB is through the terminal and shell command. sysfs is the virtual file system which exposes the drivers for the hardware so you can directly use them.
# cd /sys/class/leds # ls # beaglebone:green:usr0 beaglebone:green:usr1 beaglebone:green:usr2 beaglebone:green:usr3 # cd beaglebone\:green\:usr0 # cat trigger none nand-disk mmc0 mmc1 timer oneshot [heartbeat] backlight gpio cpu0 default-on transient  If you want to disable the heartbeat:</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB - Device Tree</title>
      <link>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb-device-tree/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb-device-tree/</guid>
      <description>Install js wrapped bonescript For using the javascript wrapped library, first we have to install following packages:
$ sudo apt-get install nodejs npm nodejs-legacy $ npm config set proxy http://1xx.xx.xx.xxx:2xxx $ npm config set https-proxy http://1xx.xx.xx.xx:2xxx $ npm install bonescript  Because my network environment is under the firewall, so I need to set the proxy, if you directly connect to internet, you could ignore the npm config set commands.</description>
    </item>
    
    <item>
      <title>EBC Exercises on BBB - Read Analog</title>
      <link>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb-read-analog/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/13/ebc-exercises-on-bbb-read-analog/</guid>
      <description>Connection The wired connection is listed as following:
Pin 34(analog ground) &amp;mdash;&amp;gt; Negative Pin
Pin 32(1.8 V) &amp;mdash;&amp;gt; Positive Pin
Pin 36(AIN5) &amp;mdash;&amp;gt; Wiper
Pin 32: VADC, Pin 34: AGND, Pin36, AIN5.
Operation root@arm:/sys/kernel/debug/pinctrl/44e10800.pinmux# cat /sys/devices/bone_capemgr.*/slots 0: 54:PF--- 1: 55:PF--- 2: 56:PF--- 3: 57:PF--- 4: ff:P-O-L Bone-LT-eMMC-2G,00A0,Texas Instrument,BB-BONE-EMMC-2G 5: ff:P-O-L Bone-Black-HDMI,00A0,Texas Instrument,BB-BONELT-HDMI root@arm:/sys/kernel/debug/pinctrl/44e10800.pinmux# SLOTS=/sys/devices/bone_capemgr.*/slots root@arm:/sys/kernel/debug/pinctrl/44e10800.pinmux# PINS=/sys/kernel/debug/pinctrl/44e10800.pinmux/pins root@arm:/sys/kernel/debug/pinctrl/44e10800.pinmux# echo cape-bone-iio &amp;gt; $SLOTS root@arm:/sys/kernel/debug/pinctrl/44e10800.pinmux# cat $SLOTS 0: 54:PF--- 1: 55:PF--- 2: 56:PF--- 3: 57:PF--- 4: ff:P-O-L Bone-LT-eMMC-2G,00A0,Texas Instrument,BB-BONE-EMMC-2G 5: ff:P-O-L Bone-Black-HDMI,00A0,Texas Instrument,BB-BONELT-HDMI 7: ff:P-O-L Override Board Name,00A0,Override Manuf,cape-bone-iio root@arm:/sys/kernel/debug/pinctrl/44e10800.</description>
    </item>
    
    <item>
      <title>OpenWRT on BBB(3)</title>
      <link>http://purplepalmdash.github.io/2014/11/10/openwrt-on-bbb-3/</link>
      <pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/10/openwrt-on-bbb-3/</guid>
      <description>Building Guideline I found a openwrt-bbb repository on github, so just download it and build:
https://github.com/nc543/openwrt-bbb/wiki
$ git clone https://github.com/nc543/openwrt-bbb.git $ cd openwrt-bbb $ make  When building you will meet the openssl download error, simply change the version from 1.0.1i to 1.0.1h or other version is OK.
I change this because in recent days the download page of openssl.org is not stable, so the download procedure will directly download the tar files from openwrt.</description>
    </item>
    
    <item>
      <title>为BBB编译内核和Linux</title>
      <link>http://purplepalmdash.github.io/2014/11/09/wei-bbbbian-yi-nei-he-he-linux/</link>
      <pubDate>Sun, 09 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/09/wei-bbbbian-yi-nei-he-he-linux/</guid>
      <description>因为原文是英文的缘故，所以这里就直接用中文翻译，并把编译时的步骤和注意事项记载下来。
主要参考了:
https://eewiki.net/display/linuxonarm/BeagleBone+Black
All of the files and folder are located under $BBB/201411 folder.
交叉编译链准备 下载、设置交叉编译链:
wget -c https://releases.linaro.org/14.09/components/toolchain/binaries/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux.tar.xz tar xf gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux.tar.xz export CC=`pwd`/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-  测试交叉编译链:
# ${CC}gcc --version arm-linux-gnueabihf-gcc (crosstool-NG linaro-1.13.1-4.9-2014.09 - Linaro GCC 4.9-2014.09) 4.9.2 20140904 (prerelease) Copyright (C) 2014 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</description>
    </item>
    
    <item>
      <title>Install new image to sd card for BBB</title>
      <link>http://purplepalmdash.github.io/2014/11/08/install-new-image-to-sd-card-for-bbb/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/08/install-new-image-to-sd-card-for-bbb/</guid>
      <description>Mainly for installing the OpenWRT system on the BBB, following is the steps:
# zImage cp /media/y/embedded/BBB/svnco/trunk/bin/omap/openwrt-omap-zImage ./zImage # dtb file cp /media/y/embedded/BBB/svnco/trunk/bin/omap/dtbs/am335x-boneblack.dtb ./dtbs/  </description>
    </item>
    
    <item>
      <title>Build OpenWRT For X86</title>
      <link>http://purplepalmdash.github.io/2014/11/05/build-openwrt-for-x86/</link>
      <pubDate>Wed, 05 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/05/build-openwrt-for-x86/</guid>
      <description>Prepare Install following packages:
$ sudo apt-get install build-essential subversion git-core libncurses5-dev zlib1g-dev gawk flex quilt libssl-dev xsltproc libxml-parser-perl  Code Get the source code from OpenWRT.org:
$ git clone git://git.openwrt.org/openwrt.git  Then Prepare for menuconfig:
$ cd openwrt $ ./scripts/feeds update -a $ ./scripts/feeds install -a $ make menuconfig  Select x86 for Target System.
[] ext4&amp;ndash;&amp;gt; Target Images &amp;ndash;&amp;gt; ext4
[] Build VMware image files (VMDK)
You could also select for VDI or other formats.</description>
    </item>
    
    <item>
      <title>Enable nfs server of 53</title>
      <link>http://purplepalmdash.github.io/2014/11/05/enable-nfs-server-of-53/</link>
      <pubDate>Wed, 05 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/05/enable-nfs-server-of-53/</guid>
      <description>Only enabled the nfs server and use the max disk for building, the nfs server runs Redhat RHEL6.2, the same procedure could be applied to CentOS Based system.
Steps:
Query for installed packages in server:
$ rpm -qa nfs-utils $ rpm -qa rpcbind  Edit the nfs based directory:
# cat /etc/exports /home/Trusty/share/ *(rw,sync,no_subtree_check,no_root_squash)  Start the service and test:
# service rpcbind start # service nfs start  In client machine, just type following command for mount the remote nfs directory:</description>
    </item>
    
    <item>
      <title>OpenWRT on BBB(2)</title>
      <link>http://purplepalmdash.github.io/2014/11/04/openwrt-on-bbb-2/</link>
      <pubDate>Tue, 04 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/04/openwrt-on-bbb-2/</guid>
      <description>Cheetsheet For Using NFS Following configuration use the 192.168.1.221&amp;rsquo;s tftp server and 192.168.1.11&amp;rsquo;s nfs server, why I use different nfs server because 192.168.1.11 runs ubuntu and could reached by nfs client easily.
setenv ipaddr 192.168.1.16 setenv serverip 192.168.1.221 tftpboot ${fdtaddr} am335x-boneblack.dtb tftpboot ${kloadaddr} uImage setenv bootargs console=ttyO0,115200n8 root=/dev/nfs rw nfsroot=192.168.1.11:/srv/nfs4/BBBrootfs ip=192.168.1.1 rootwait bootm ${kloadaddr} - ${fdtaddr}  How to start more services Current we only got following output:
procd: - init - //.</description>
    </item>
    
    <item>
      <title>Use TFTP/NFS Testing  BBB Kernel </title>
      <link>http://purplepalmdash.github.io/2014/11/02/use-tftp-slash-nfs-testing-bbb-kernel/</link>
      <pubDate>Sun, 02 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/02/use-tftp-slash-nfs-testing-bbb-kernel/</guid>
      <description>Prerequisite You have a tftp server and NFS server configured, in my environment these 2 server runs on ArchLinux, ip address is 10.0.0.221, while BBB takes another ip address, for example, 10.0.0.16.
NFS Server Preparation Create the nfs server&amp;rsquo;s rootfs for BBB Black ,and open all of the priviledges :
# pwd /media/y/embedded/BBB/svnco/trunk/bin/omap # mkdir /srv/nfs4/BBBrootfs # tar xzvf openwrt-omap-Default-rootfs.tar.gz -C /srv/nfs4/BBBrootfs/ # chmod 777 -R /srv/nfs4/BBBrootfs/  Now you have the NFS Server available.</description>
    </item>
    
    <item>
      <title>OpenWRT on BBB</title>
      <link>http://purplepalmdash.github.io/2014/11/01/openwrt-on-bbb/</link>
      <pubDate>Sat, 01 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/11/01/openwrt-on-bbb/</guid>
      <description>This article will try to build and run OpenWRT on BBB(BeagleBone Black)
Checkout Code Checkout the code from openwrt.org:
[Trusty@/media/y/embedded/BBB/OpenWRT]$ svn checkout -r 40887 svn://svn.openwrt.org/openwrt/trunk/ ...... Checked out revision 40887.  Since the wiki said the only workable version for BBB is r40887, we just checkout this specified version.
Currently only runs with openwrt/trunk (r40887) and kernel 3.14.4. Kernel 3.13.7 (as in r40887 on target/linux/omap) will boot the device, but as soon as you attach a USB device, it will freeze.</description>
    </item>
    
    <item>
      <title>Arduino Performance</title>
      <link>http://purplepalmdash.github.io/2014/10/29/arduino-performance/</link>
      <pubDate>Wed, 29 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/29/arduino-performance/</guid>
      <description>Program Storage Classical Blink program:
/* Blink Turns on an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the Uno and Leonardo, it is attached to digital pin 13. If you&#39;re unsure what pin the on-board LED is connected to on your Arduino model, check the documentation at http://arduino.cc This example code is in the public domain.</description>
    </item>
    
    <item>
      <title>Linux2.6.32 for Utu2440(7)</title>
      <link>http://purplepalmdash.github.io/2014/10/28/linux2-dot-6-32-for-utu2440-7/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/28/linux2-dot-6-32-for-utu2440-7/</guid>
      <description>Watchdog Change the configuraiton of Watchdog in kernel:
Watchdog configuraiton in kernel:
$ grep &amp;quot;CONFIG_S3C2410_WATCHDOG_DEFAULT_TIME&amp;quot; ./ -r ./drivers/watchdog/s3c2410_wdt.c:#define CONFIG_S3C2410_WATCHDOG_DEFAULT_TIME (15)  Test Watchdog:
~ # dmesg | grep watchdog s3c2410-wdt s3c2410-wdt: watchdog inactive, reset disabled, irq enabled ~ # ~ # echo 0&amp;gt;/dev/watchdog s3c2410-wdt s3c2410-wdt: Unexpected close, not stopping watchdog  Then after 15 seconds your board will reset, disable watchdog via:
~ # echo -n V&amp;gt;/dev/watchdog  LED The connection for LED is:</description>
    </item>
    
    <item>
      <title>Linux2.6.32 for Utu2440(6)</title>
      <link>http://purplepalmdash.github.io/2014/10/27/linux2-dot-6-32-for-utu2440-6/</link>
      <pubDate>Mon, 27 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/27/linux2-dot-6-32-for-utu2440-6/</guid>
      <description>Flash Disk Enable the scsi device support in kernel configuration:
Then enable the usb support:
* Support for Host-side USB * USB device filesystem(DEPRECATED) * OHCI HCD support * USB Mass Storage support  Also enable the filesystem support for FAT/FAT16/FAT32/EXT4:
change the default u-boot parameters:
utu-bootloader=&amp;gt;&amp;gt;&amp;gt;printenv bootcmd bootcmd=nand read.i 0x32000000 0x60000 0x200000; bootm utu-bootloader=&amp;gt;&amp;gt;&amp;gt;setenv bootcmd &#39;tftp 30000000 uImage; bootm&#39; utu-bootloader=&amp;gt;&amp;gt;&amp;gt;printenv bootcmd bootcmd=tftp 30000000 uImage; bootm utu-bootloader=&amp;gt;&amp;gt;&amp;gt;saveenv Saving Environment to NAND.</description>
    </item>
    
    <item>
      <title>Linux2.6.32 for Utu2440(5)</title>
      <link>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-32-for-utu2440-5/</link>
      <pubDate>Sat, 25 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-32-for-utu2440-5/</guid>
      <description>In this chapter we will continue to migrate driver on LCD, first we want to get the LCD information.
LCD Info From the LCD we could see &amp;ldquo;LTV350QV-F0E&amp;rdquo;, Search it on google and we know it&amp;rsquo;s SAMSUNG TFT 3.5-inch 320*240 LTV350QV-F0E lcd panel.
Its datasheet could be downloaded from:
http://www.datasheet-pdf.com/datasheet-html/L/T/V/LTV350QV-F0E_Samsung.pdf.html
TFT means （Thin Film Transistor）.
Beware, the kernel we should choose is uImage_T1_F0E_320x240_ts, because we bought the Package 1 of the development board, they shipped us with Samsung screen .</description>
    </item>
    
    <item>
      <title>Linux2.6.39 for Utu2440(2)</title>
      <link>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-39-for-utu2440-2/</link>
      <pubDate>Sat, 25 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-39-for-utu2440-2/</guid>
      <description>Serial Port Support Enable the Device Driver&amp;mdash;-&amp;gt; Character deivces &amp;mdash;-&amp;gt; Serial drivers &amp;mdash;-&amp;gt; Samsung related settings, My setting is listed as following:
Then you will see serial output during kernel boot.
DM9000 Support Add following code into the linux/arch/arm/mach-s3c2440/mach-smdk2440.c:
#include &amp;lt;linux/serial_core.h&amp;gt; + /* Added dm9000 support for utu2400 */ + #include &amp;lt;linux/dm9000.h&amp;gt; #include &amp;lt;linux/platform_device.h&amp;gt; #include &amp;lt;plat/common-smdk.h&amp;gt; + /* DM9000 Base address for SMDK2440 */ + #define MACH_SMDK2440_DM9K_BASE (S3C2410_CS3 + 0x300) static struct map_desc smdk2440_iodesc[] __initdata = { + /* Added for dm9000 */ + static struct resource smdk2440_dm9k_resource[] = + { + [0] = + { + .</description>
    </item>
    
    <item>
      <title>Linux2.6.39 for Utu2440(3)</title>
      <link>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-39-for-utu2440-3/</link>
      <pubDate>Sat, 25 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-39-for-utu2440-3/</guid>
      <description>Building Filesystems Use following script for building the basic filesystem:
$ cat mkrootfs #!/bin/sh echo &amp;quot;------Create rootfs directons start...--------&amp;quot; mkdir rootfs cd rootfs echo &amp;quot;--------Create root,dev....----------&amp;quot; mkdir bin boot dev etc home lib mnt proc root sbin sys tmp usr var www mkdir etc/init.d etc/rc.d etc/sysconfig mkdir usr/sbin usr/bin usr/lib usr/modules echo &amp;quot;make node in dev/console dev/null&amp;quot; mknod -m 666 dev/console c 5 1 mknod -m 666 dev/null c 1 3 mkdir mnt/etc mnt/jffs2 mnt/yaffs mnt/data mnt/temp mkdir var/lib var/lock var/run var/tmp chmod 1777 tmp chmod 1777 var/tmp echo &amp;quot;-------make direction done---------&amp;quot;  Run it and you will get an folder which contains the newly created directory structure.</description>
    </item>
    
    <item>
      <title>Linux2.6.39 for Utu2440(4)</title>
      <link>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-39-for-utu2440-4/</link>
      <pubDate>Sat, 25 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/25/linux2-dot-6-39-for-utu2440-4/</guid>
      <description>RTC Activate RealTime Clock functionality could be easily activated via:
$ vim arch/arm/mach-s3c2440/mach-smdk2440.c static struct platform_device *smdk2440_devices[] __initdata = { &amp;amp;s3c_device_ohci, +	&amp;amp;s3c_device_rtc, &amp;amp;s3c_device_lcd,  Configure the Kernel:
Device Drivers&amp;mdash;-&amp;gt; RealTime Clock &amp;mdash;-&amp;gt; Samsung S3C series Soc RTC
Save and exit, then make Image.
Test RTC Before we have following configuration:
[root@www ~]# date Thu Jan 1 01:07:51 UTC 1970  Now we switch to new kernel which contains RTC support:</description>
    </item>
    
    <item>
      <title>utu2400&#39;s Kernel Drivers</title>
      <link>http://purplepalmdash.github.io/2014/10/23/utu2400-s-kernel-drivers/</link>
      <pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/23/utu2400-s-kernel-drivers/</guid>
      <description> sshd replacement Since busybox enabled the telnetd by default, we could just use telnet for accessing the board.
[root@www ~]# ps -ef | grep telnet 861 root 0:00 /usr/sbin/telnetd -l /bin/login 893 root 0:00 grep telnet  </description>
    </item>
    
    <item>
      <title>Enable sshd on 2440</title>
      <link>http://purplepalmdash.github.io/2014/10/22/enable-sshd-on-2440/</link>
      <pubDate>Wed, 22 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/22/enable-sshd-on-2440/</guid>
      <description>Package Preparation For openssh requires the following packages, first we have to download them all from internet.
zlib, openssl, openssh.
$ wget http://zlib.net/zlib-1.2.8.tar.gz $ wget https://www.openssl.org/source/openssl-0.9.8zc.tar.gz $ wget http://mirror.internode.on.net/pub/OpenBSD/OpenSSH/portable/openssh-6.7p1.tar.gz  Building Cross-compile zlib We have to manually change the following line in Makefile :
LDSHARED=gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map to LDSHARED=arm-linux-gcc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map  Then:
$ ./configure --prefix=/media/nfs/rootfs/usr/ $ make CC=arm-linux-gcc AR=arm-linux-ar LD=arm-linux-ld $ make install  Cross-compile openssh Get the openssl&amp;rsquo;s configure help menus:</description>
    </item>
    
    <item>
      <title>Cross-compile the kernel for utu2440</title>
      <link>http://purplepalmdash.github.io/2014/10/18/cross-compile-the-kernel-for-utu2440/</link>
      <pubDate>Sat, 18 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/18/cross-compile-the-kernel-for-utu2440/</guid>
      <description>Cross-compiler Preparation The official documentation said use gcc-3.4.1 for compiling the kernel.
$ cat ~/.zshrc | grep -i set341 alias set341=&#39;export PATH=/opt/cross/arm-linux-gcc_3.4.1/bin:$PATH&#39; $ set341 $ pwd /media/y/embedded/utu2440/UTU2440-F-T1-20080328/YC2440CDROM_DM9000_080328/utuLinuxfor2440V1.5.8/utu-linux_for_s3c2440_dm9000_V1.5.8 $ arm-linux-gcc -v Reading specs from /opt/cross/arm-linux-gcc_3.4.1/bin/../lib/gcc/arm-linux/3.4.1/specs Configured with: /work/crosstool-0.27/build/arm-linux/gcc-3.4.1-glibc-2.3.2/gcc-3.4.1/configure --target=arm-linux --host=i686-host_pc-linux-gnu --prefix=/usr/local/arm/3.4.1 --with-headers=/usr/local/arm/3.4.1/arm-linux/include --with-local-prefix=/usr/local/arm/3.4.1/arm-linux --disable-nls --enable-threads=posix --enable-symvers=gnu --enable-__cxa_atexit --enable-languages=c,c++ --enable-shared --enable-c99 --enable-long-long Thread model: posix gcc version 3.4.1  Kernel Compilation Compile the kernel via:
$ make menuconfig &amp;quot;Load an Alternate Configuration File&amp;quot;-&amp;gt; config_480272_ts $ make uImage -j4  Trouble shooting: in ArchLinux, install uboot&amp;rsquo;s mkimage tool via:</description>
    </item>
    
    <item>
      <title>Embedded Environment on Arch</title>
      <link>http://purplepalmdash.github.io/2014/10/18/embedded-environment-on-arch/</link>
      <pubDate>Sat, 18 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/18/embedded-environment-on-arch/</guid>
      <description>NFS Server Server Setup
$ sudo pacman -S nfs-utils $ sudo vim /etc/idmapd.conf [General] #Verbosity = 0 Verbosity = 1 Pipefs-Directory = /var/lib/nfs/rpc_pipefs Domain = localdomain [Mapping] Nobody-User = nobody Nobody-Group = nobody $ sudo vim /etc/conf.d/nfs-common.conf STATD_OPTS=&amp;quot;-p 32765 -o 32766 -T 32803&amp;quot; $ sudo vim /etc/conf.d/nfs-server.conf MOUNTD_OPTS=&amp;quot;-p 20048&amp;quot; $ sudo mkdir -p /srv/nfs4/music $ cat /etc/exports /srv/nfs4/ 10.0.0.0/24(rw,fsid=root,no_subtree_check) /srv/nfs4/music 10.0.0.0/24(rw,no_subtree_check,nohide) # note the nohide option which is applied to mounted directories on the file system.</description>
    </item>
    
    <item>
      <title>Linux2.6.39 for utu2440</title>
      <link>http://purplepalmdash.github.io/2014/10/18/linux2-dot-6-39-for-utu2440/</link>
      <pubDate>Sat, 18 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/18/linux2-dot-6-39-for-utu2440/</guid>
      <description>Kernel Preparation First download the kernel source from kernel.org:
$ wget https://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.39.tar.bz2 $ tar xjvf lnux-2.6.39.tar.bz2  Change the Makefile:
$ cat Makefile export KBUILD_BUILDHOST := $(SUBARCH) ARCH	?= $(SUBARCH) CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:&amp;quot;%&amp;quot;=%) # Added our own cross-compiler here. ARCH	?= arm CROSS_COMPILE	?= arm-linux- # End of added own cross-compiler.  Change the pltf input clock:
$ vim arch/arm/mach-s3c2440/mach-smdk2440.c static void __init smdk2440_map_io(void) { s3c24xx_init_io(smdk2440_iodesc, ARRAY_SIZE(smdk2440_iodesc)); //s3c24xx_init_clocks(16934400); // Change the input clock adjust to utu2440 s3c24xx_init_clocks(12000000); s3c24xx_init_uarts(smdk2440_uartcfgs, ARRAY_SIZE(smdk2440_uartcfgs)); }  Change the machine code(this code is the same as the bootloader&amp;rsquo;s parameter, bootloader transfer 5244 to Linux Kernel.</description>
    </item>
    
    <item>
      <title>Serial Port on BBB</title>
      <link>http://purplepalmdash.github.io/2014/10/15/serial-port-on-bbb/</link>
      <pubDate>Wed, 15 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/15/serial-port-on-bbb/</guid>
      <description>Serial Port Settings Use following settings for the serial monitor software:
The default serial port settings for the board are: Baud 115,200 Bits 8 Parity N Stop Bits 1 Handshake None  Connection The serial port in BBB is listed as following:</description>
    </item>
    
    <item>
      <title>Run BBB building in server</title>
      <link>http://purplepalmdash.github.io/2014/10/14/run-bbb-building-in-server/</link>
      <pubDate>Tue, 14 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/14/run-bbb-building-in-server/</guid>
      <description>Background Since building is heavy task to CPU, I decide to use the server in lab for building
Packages We need to install following packages for setting up the building environment:
zypper in git patch u-boot-tools git ncurses-devel dpkg dpkg-devel dpkg-lang  Use git for acrossing the firewall of company:
&amp;gt; git config --global user.email xxxx@gmail.com &amp;gt; git config --global user.name xxxx &amp;gt; cat ~/.gitconfig [user] email = xxxx@gmail.com name = xxx  Then we compile a cross Firewall tool and tell git for using it.</description>
    </item>
    
    <item>
      <title>Tips for deploying ArchLinux on BBB</title>
      <link>http://purplepalmdash.github.io/2014/10/14/tips-for-deploying-archlinux-on-bbb/</link>
      <pubDate>Tue, 14 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/14/tips-for-deploying-archlinux-on-bbb/</guid>
      <description>The detailed installation guideline could be found at:
http://archlinuxarm.org/platforms/armv7/ti/beaglebone-black
But while there are some tips in changing the uEnv.txt, to enable the boot from 2nd mmc partition. following is the configuration file:
[root@alarm mnt]# cat uEnv.txt optargs=coherent_pool=1M #u-boot eMMC specific overrides; Angstrom Distribution (BeagleBone Black) 2013-06-20 kernel_file=zImage initrd_file=uInitrd loadzimage=load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${kernel_file} loadinitrd=load mmc ${mmcdev}:${mmcpart} 0x81000000 ${initrd_file}; setenv initrd_size ${filesize} loadfdt=load mmc ${mmcdev}:${mmcpart} ${fdtaddr} /dtbs/${fdtfile} # console=ttyO0,115200n8 # If you want to boot from usb #mmcroot=/dev/sda1 ro # If you want to boot from SD card mmcroot=/dev/mmcblk0p2 ro mmcrootfstype=ext4 rootwait fixrtc  Now reboot and then you could see the BBB runs into the ArchLinux.</description>
    </item>
    
    <item>
      <title>Switch from BBB to RaspberryPI</title>
      <link>http://purplepalmdash.github.io/2014/10/13/switch-from-bbb-to-raspberrypi/</link>
      <pubDate>Mon, 13 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2014/10/13/switch-from-bbb-to-raspberrypi/</guid>
      <description>Background I have BeagleBone Black and RaspberryPi, both of them are cute board. Previous I use BBB for home server, which holds my own Weather APP website, also serves as a sshd server, dynamic dns server, etc. While Rpi serves like a File server and download server.
Now I want to use BBB for developing some funny things, that means I will transfer all of the functionalities which runs in BBB to Rpi.</description>
    </item>
    
    <item>
      <title>BBBlack编译脚本解析</title>
      <link>http://purplepalmdash.github.io/2013/12/11/bbblackbian-yi-jiao-ben-jie-xi/</link>
      <pubDate>Wed, 11 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/11/bbblackbian-yi-jiao-ben-jie-xi/</guid>
      <description>###Preparation Download the &amp;ldquo;linux-dev&amp;rdquo; repository from github:
	git clone git://github.com/RobertCNelson/linux-dev.git  View the downloaded packages:
	[Trusty@XXXyyy mykernel]$ du -hs linux-dev/ 19M	linux-dev/ [Trusty@XXXyyy linux-dev]$ ls build_deb.sh build_kernel.sh build_mainline.sh LICENSE patches patch.sh README repo_maintenance scripts system.sh.sample tools version.sh  Switch to the 3.12 Branch:
	git checkout origin/am33x-v3.12 -b tmp [Trusty@XXXyyy linux-dev]$ ls build_deb.sh build_kernel.sh LICENSE patches patch.sh README repo_maintenance scripts system.sh.sample tools version.sh  ###Walk by lines Since we call .</description>
    </item>
    
    <item>
      <title>NFS of beaglebone</title>
      <link>http://purplepalmdash.github.io/2013/12/11/nfs-of-beaglebone/</link>
      <pubDate>Wed, 11 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/11/nfs-of-beaglebone/</guid>
      <description>###Serial Preparation The serial port image is as following: ###Failure information The bootup failure information is listed as following:
	Running uenvcmd ... reading zImage 3345240 bytes read in 383 ms (8.3 MiB/s) reading /dtbs/am335x-boneblack.dtb 24884 bytes read in 10 ms (2.4 MiB/s) Starting kernel ... Uncompressing Linux... done, booting the kernel. Error: unrecognized/unsupported machine ID (r1 = 0x00000e05). Available machine support: ID (hex) NAME ffffffff Generic OMAP4 (Flattened Device Tree) ffffffff Generic AM33XX (Flattened Device Tree) ffffffff Generic OMAP3-GP (Flattened Device Tree) ffffffff Generic OMAP3 (Flattened Device Tree) 0000060a OMAP3 Beagle Board 00000a9d IGEP OMAP3 module 00000928 IGEP v2 board 00000ae7 OMAP4 Panda board Please check your kernel config and/or bootloader.</description>
    </item>
    
    <item>
      <title>Enable audio in BeagleBone Black</title>
      <link>http://purplepalmdash.github.io/2013/12/09/enable-audio-in-beaglebone-black/</link>
      <pubDate>Mon, 09 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/09/enable-audio-in-beaglebone-black/</guid>
      <description>The usb sound card which I want to enable is a legend hub.
###Package Installation Install necessary packages:
	$ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade $ sudo apt-get install vim mplayer alsa-base  ###Hardware Configuration View the sound card information:
	root@arm:~# lsusb Bus 001 Device 029: ID 0424:2507 Standard Microsystems Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.</description>
    </item>
    
    <item>
      <title>raspberryPI GPIO Programming on ArchLinux</title>
      <link>http://purplepalmdash.github.io/2013/12/08/raspberrypi-gpio-programming-on-archlinux/</link>
      <pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/08/raspberrypi-gpio-programming-on-archlinux/</guid>
      <description>###Python Preparation Install python
	$ pacman -S python  Install pip
	$ pacman -S python-pip  Install virtualenv, before install virtualenv, be sure to update your time. 1970&amp;rsquo;s time will get ssl error.
	$ date -s &amp;quot;8 Dec 2013 16:09:40&amp;quot; $ pip install --upgrade virtualenv virtualenvwrapper  Prepare virtualenv:
	[root@alarmpi ~]# mkdir ~/pyv [root@alarmpi ~]# vim ~/.virtualenvrc export WORKON_HOME=&amp;quot;/root/pyv&amp;quot; export PROJECT_HOME=&amp;quot;/root/pyv&amp;quot; source /usr/bin/virtualenvwrapper.sh [root@alarmpi ~]# source ~/.</description>
    </item>
    
    <item>
      <title>GPIO Advanced in STM32</title>
      <link>http://purplepalmdash.github.io/2013/12/01/gpio-advanced-in-stm32/</link>
      <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/01/gpio-advanced-in-stm32/</guid>
      <description>直接操作寄存器的好处，最主要的就是看中它的快。缺点在于比较晦涩，因为你需要了解到实现的底层。在官方库中，我们可以找到如下的定义：
//./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h: #define PERIPH_BASE ((uint32_t)0x40000000) /*!&amp;lt; Peripheral base address in the alias region */ //./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h: #define APB2PERIPH_BASE (PERIPH_BASE + 0x10000) //./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h: #define GPIOA_BASE (APB2PERIPH_BASE + 0x0800) //./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h: #define GPIOA ((GPIO_TypeDef *) GPIOA_BASE) // Definition of the GPIO Types /** * @brief General Purpose I/O */ typedef struct { __IO uint32_t CRL; __IO uint32_t CRH; __IO uint32_t IDR; __IO uint32_t ODR; __IO uint32_t BSRR; __IO uint32_t BRR; __IO uint32_t LCKR; } GPIO_TypeDef; /** * IO definitions * * define access restrictions to peripheral registers */ #ifdef __cplusplus #define __I volatile /*!</description>
    </item>
    
    <item>
      <title>STM32 and 25F080</title>
      <link>http://purplepalmdash.github.io/2013/12/01/stm32-and-25f080/</link>
      <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/12/01/stm32-and-25f080/</guid>
      <description>SST25F080,高达 1M 字节的串行 FLASH 存储器,此芯片为-50 版,即 SPI 速度可达到 50M,利用 STM32 的最高速 SPI 接口(36M),读写速度绝对不比并行 FLASH 慢.
连线图如下：</description>
    </item>
    
    <item>
      <title>RTC on STM32</title>
      <link>http://purplepalmdash.github.io/2013/11/30/rtc-on-stm32/</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/30/rtc-on-stm32/</guid>
      <description>RTC(Real Time Clock) 在STM32中可以理解为内置的一个部件，和传说中的DS1302是有差别的。尽管官方发布的程序可以将RTC搞成一个万年历。
###配置RTC RTC需要顺带使用后备寄存器， 因为RTC是一个简单的秒中断定时器，关于年日月分秒的信息需要在掉电保存时依然放在某个地方，这个地方就是STM32的后备寄存器。配置好以后，尽管系统关电，依靠板子上的后备电池，依然可以保存32768的晶振和后备寄存器的数据。
配置RTC的方法：
	#include &amp;quot;stm32f10x_bkp.h&amp;quot; #include &amp;quot;stm32f10x_pwr.h&amp;quot; #include &amp;quot;stm32f10x_rtc.h&amp;quot; //使能一些外设 RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); PWR_BackupAccessCmd(ENABLE);  ###判断RTC是否被配置过 下面的函数被用于判断RTC是否被配置过：
/************************************************************** ** 函数名:TestRtc ** 功能:测试RTC用 ** 注意事项:用于显示RTC是否已经设置过. ***************************************************************/ void TestRtc(void) { if(RTC_Blank) { USART1_Puts(&amp;quot;The Time is not set\r\n&amp;quot;); } else { USART1_Puts(&amp;quot;Time Setted.\r\n&amp;quot;); } }  这个函数判断RTC_Blank全局变量的值，而全局变量的值则在配置RTC的时候被设定。
void RTC_Configuration(void) { //...... if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5) { //...... RTC_Blank=1;	//这个标志代表RTC是没有预设的(或者说是没有上纽扣电池) }  如果RTC后备寄存器的值为设定为0xA5A5，则代表RTC已经被设置过。否则，我们认为它处于未被设置过的状态。
###使用RTC的秒中断 在NVIC中，需要有下列的定义，以标识RTC的秒中断。
	/* RTC */ NVIC_InitStructure.</description>
    </item>
    
    <item>
      <title>STM32中的Systick</title>
      <link>http://purplepalmdash.github.io/2013/11/30/stm32zhong-de-systick/</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/30/stm32zhong-de-systick/</guid>
      <description>Cortx-M3特有的SysTick可以很方便的实现定时。系统始终的频率和开启系统时钟中断主要在RCC.c里进行设置：
	//SYSTICK分频--1ms的系统时钟中断 if (SysTick_Config(SystemCoreClock / 1000)) { /* Capture error */ while (1); } // The definition of the SysTick_Config: /** * @brief Initialize and start the SysTick counter and its interrupt. * * @param ticks number of ticks between two interrupts * @return 1 = failed, 0 = successful * * Initialise the system tick timer and its interrupt and start the * system tick timer / counter in free running mode to generate * periodical interrupts.</description>
    </item>
    
    <item>
      <title>STM使用库函数读写Flash</title>
      <link>http://purplepalmdash.github.io/2013/11/30/stmshi-yong-ku-han-shu-du-xie-flash/</link>
      <pubDate>Sat, 30 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/30/stmshi-yong-ku-han-shu-du-xie-flash/</guid>
      <description>代码非常之简单：
#define	FLASH_ADR	0x08008000	//要写入数据的地址 #define	FLASH_DATA	0x5a5a5a5a	//要写入的数据 int main(void) { u32 tmp; ChipHalInit();	//片内硬件初始化 ChipOutHalInit();	//片外硬件初始化 //判断此FLASH是否为空白 tmp=*(vu32*)(FLASH_ADR); if(tmp==0xffffffff) { FLASH_Unlock(); FLASH_ProgramWord(FLASH_ADR,FLASH_DATA); FLASH_Lock(); USART1_Puts(&amp;quot;The destination is empty, Data has been written in!\r\n&amp;quot;); } else if(tmp==FLASH_DATA) { USART1_Puts(&amp;quot;The destination data is the same as certification data!\r\n&amp;quot;); } else { USART1_Puts(&amp;quot;The destination data is not equal to certification data, may caused via written error, or the destination is not empty!\r\n&amp;quot;); FLASH_Unlock(); FLASH_ErasePage(FLASH_ADR); FLASH_Lock(); USART1_Puts(&amp;quot;Erased the written destination!</description>
    </item>
    
    <item>
      <title>STM32上的定时器</title>
      <link>http://purplepalmdash.github.io/2013/11/29/stm32shang-de-ding-shi-qi/</link>
      <pubDate>Fri, 29 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/29/stm32shang-de-ding-shi-qi/</guid>
      <description>使用定时器的好处是，等待某个时隙的同时还可以干别的事，而定时器的时间一到，得到一个中断后对应执行中断函数中的服务例程而已。STM32的定时器非常之复杂而强大，配置和使用都要花很大精力。
打开TIM2线的程序如下：
void TIM_Configuration(void) { //...... /* TIM2 clock enable */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //......  有关定时器的设置如下：
	/* 基础设置*/ TIM_TimeBaseStructure.TIM_Period = 8000;	//计数值 TIM_TimeBaseStructure.TIM_Prescaler = 7200-1; //预分频,此值+1为分频的除数 TIM_TimeBaseStructure.TIM_ClockDivision = 0x0; // TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //向上计数  这里设置的是定时器溢出控制,分频值的计算就是上述代码中提到的预分频的设置。 TIM2属于低速总线，这条总线最高只能达到36M的速度，芯片内部还有一个X2的倍频器，用于将低速的32M倍频成72M， 库中已经默认有实现。所以我们这里使用的TIM2其速度依然是72M， 如果预设分频为7200的话，分频后的结果就是72M/7200=10K(72000000&amp;frasl;7200). 我们可以把这个值变大或变小，以获得更慢或更快的分频速度。
计数值设置的是8000，计数器向上计数到8000的时候会溢出。因而溢出的时间是8000/10K=0.8s 比较值的设置如下：
	u16 CCR1_Val = 4000; u16 CCR2_Val = 2000; u16 CCR3_Val = 1000; u16 CCR4_Val = 500; /* 比较通道1*/ TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Inactive; //输出比较非主动模式 TIM_OCInitStructure.TIM_Pulse = CCR1_Val; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;	//极性为正 TIM_OC1Init(TIM2, &amp;amp;TIM_OCInitStructure); TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Disable);	//禁止OC1重装载,其实可以省掉这句,因为默认是4路都不重装的.</description>
    </item>
    
    <item>
      <title>关于STM32板上的12864液晶(2)</title>
      <link>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-1/</link>
      <pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-1/</guid>
      <description>###有关电路 上一章讲的是12864的基础知识。这一章里来看12864和stm32板的连接和驱动的问题。
有关12864小LCD的连接，在PDF中我们可以找到如下的表项:
   功能模块 占用模块 备注     12864小LCD PC4,PB2,PB11,PB13,PB15 PC4:A0,同时也是 CH375 和 TFT 的 A0;
PB2:BOOT1,LCD 的 CS 脚;
PB11:28J60 和大小 LCD 的复位脚    再结合电路图：
关于GPIO口的设置，我们可以看到有这样的定义：
	typedef enum { GPIO_Mode_AIN = 0x0, GPIO_Mode_IN_FLOATING = 0x04, GPIO_Mode_IPD = 0x28, GPIO_Mode_IPU = 0x48, GPIO_Mode_Out_OD = 0x14, GPIO_Mode_Out_PP = 0x10, GPIO_Mode_AF_OD = 0x1C, GPIO_Mode_AF_PP = 0x18 }GPIOMode_TypeDef;  而在stm32的Datasheet中有如下的配置模式：
最低的8个bit和表中是一一对应的，其中通用输出/复用功能输出的mode1/mode0的值为00.
因为PB15是MOSI2口， PB13是SCK2口，所以这两个管脚需要被设置为AF模式的。AF代表复用功能。PP代表push-pull.
	/* PB15-MOSI2,PB13-SCK2*/ /* Why PB14 should be enabled?</description>
    </item>
    
    <item>
      <title>关于STM32板上的12864液晶(3)</title>
      <link>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-3/</link>
      <pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/28/guan-yu-stm32ban-shang-de-12864ye-jing-3/</guid>
      <description>###如何控制液晶屏幕 ASCII码的可打印字符的范围在0x20 ~ 0x7f之间， 0x20 是空格字符，0x7f是delete字符。 最开始我们需要在内存中建立一张关于可打印字符的表。用于表示在液晶屏幕上如何显示出该字符，即该字符的点阵排列。
下图是可以打印的ASCII/Unicode 0-127的值：
点阵数组：
	const u8 Asii8[] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x06,0x5F,0x06,0x00,0x00,0x07,0x03,0x00, 0x07,0x03,0x00,0x24,0x7E,0x24,0x7E,0x24, 0x00,0x24,0x2B,0x6A,0x12,0x00,0x00,0x63, 0x13,0x08,0x64,0x63,0x00,0x36,0x49,0x56,  来个例子：
	#: 0x00, 0x24, 0x7e, 0x24, 0x7e, 0x24 00000000 00100100 01111110 00100100 01111110 00100100  对应的1代表将该点的液晶点点上。
要注意，实际的显示应该是倒过来的，即： 把你的脖子顺时针转90度看上面的二进制表达式。
在LCD上设置需要写入的坐标，
	/************************************************************** **函数名 :LcdSetXP **功能:设置坐标** **注意事项:这里设置的坐标不是X,Y,而是X,PAGE.因为黑白屏一次写入的数据为8个点,而且为竖 **	式写入,故纵坐标是以页为单位,64个点共8页 ***************************************************************/ void LcdSetXP(u8 x,u8 page) { LcdCmd((page&amp;amp;0x07)+0xb0);	//设置页指针 LcdCmd((x&amp;gt;&amp;gt;4)|0x10); LcdCmd(x&amp;amp;0x0f); }  128X64的屏幕一共有8192个点， 每一个字符用48个点来表示，即8X6。所以每一个字的X坐标长度应该是6, 而Y坐标应该是8. 一个page代表8个点。
考虑下面代码:
	LcdSetXP(0,1); LcdChar8(&#39;T&#39;); LcdChar8(&#39;E&#39;); LcdChar8(&#39;S&#39;); LcdChar8(&#39;T&#39;); LcdChar8(&#39; &#39;); LcdChar8(&#39;O&#39;); LcdChar8(&#39;K&#39;); LcdChar8(&#39;!</description>
    </item>
    
    <item>
      <title>关于STM32板上的12864液晶</title>
      <link>http://purplepalmdash.github.io/2013/11/27/guan-yu-stm32ban-shang-de-12864ye-jing/</link>
      <pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/27/guan-yu-stm32ban-shang-de-12864ye-jing/</guid>
      <description>板子是09年入手的，但是一直没时间好好玩，最近端起来觉得有必要好好研究一番。为了以后翻阅方便，全中文记下来。
###12864 通常所说的12864LCD显示块是所说的点阵液晶显示模块，就是由128X64个液晶显示点组成的一个128列X64行的阵列，所以也就叫成了12864。每个显示点都对应着有一位二进制数，0表示灭，1表示亮。存储这些点阵信息的RAM被称为显示数据存储器。如果要显示某个图形或汉字就是将相应的点阵信息写入到对应的存储单元中。图形或汉字的点阵信息是由自己设计，这时候问题的关键是显示点在液晶屏上的位置与其在存储器中的地址之间的关系。
显示点在64X64液晶屏上的位置由列号（line,0~63）与行号（line,0~63）确定。512X8 bits RAM中某个存储单元的地址由页地址（Xpage,0~7）和列地址（Yaddress,0~63）确定。每个存储单元存储8个液晶点的显示信息。也就是说，一个页的大小是8. 运算关系则是64x64=(64x8)x8=512x8.
由于多数液晶显示模块的驱动电路是由一片行驱动器和两片列驱动器构成，所以12864液晶屏实际上是由左右两块独立的64X64液晶屏拼接而成，每半屏有一个512X8 bits显示数据RAM。左右半屏驱动电路及存储器分别由片选信号CS1和CS2选择。（少数厂商为了简化用户设计，在模块中增加译码电路，使得128X64液晶屏就是一个整屏，只需一个片选信号。）
如如果点亮12864的屏中（20，30）位置上的液晶点，因列地址30小于64，该点在左半屏第29列，所以CS1有效；行地址20除以8取整得2，取余得4，该点在RAM中页地址为2，在字节中的序号为4；所以将二进制数据00010000（也可能是00001000，高低顺序取决于制造商）写入Xpage=2，Yaddress=29的存储单元中即点亮（20，30）上的液晶点。
这是为了为了使液晶点位置信息与存储地址的对应关系更直观关，将64X64液晶屏从上至下8等分为8个显示块，每块包括8行X64列个点阵。每列中的8行点阵信息构成一个8bits二进制数，存储在一个存储单元中。（需要注意：二进制的高低有效位顺序与行号对应关系因不同商家而不同）存放一个显示块的RAM区称为存储页。即64X64液晶屏的点阵信息存储在8个存储页中，每页64个字节，每个字节存储一列(8行)点阵信息。因此存储单元地址包括列地址（Yaddress,0~63）和页地址（Xpage,0~7）。
以上就是对于12864点阵液晶显示器的原理介绍。
在DX32开发板上的液晶是怎么一回事呢？它的封装图如下：
Datasheet有72页，乱七八糟的会讲一大堆。但是事实上我们只需要关注和软件有关的方面，拿一个很简单的开启/关闭LCD的例子来说，DataSheet里有这样的表格：
   Command A0 /RD /WR D7 D6 D5 D4 D3 D2 D1 D0 Function     Display On/OFF 0 1 0 1 0 1 0 1 1 1 1 LCD Display ON   Display On/OFF 0 1 0 1 0 1 0 1 1 1 0 LCD Display OFF    那么会有对应的代码:</description>
    </item>
    
    <item>
      <title>openOCD Configuration</title>
      <link>http://purplepalmdash.github.io/2013/11/22/openocd-configuration/</link>
      <pubDate>Fri, 22 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://purplepalmdash.github.io/2013/11/22/openocd-configuration/</guid>
      <description>###OpenOCD Device Scan Install and view the OpenOCD:
	$ pacman -S openocd [Trusty@XXXyyy debian_octopress]$ openocd -v Open On-Chip Debugger 0.7.0 (2013-11-02-01:53) Licensed under GNU GPL v2 For bug reports, read http://openocd.sourceforge.net/doc/doxygen/bugs.html  Insert your openJTAG debug board, and view its connection:
	[Trusty@XXXyyy debian_octopress]$ lsusb Bus 001 Device 016: ID 1457:5118 First International Computer, Inc. OpenMoko Neo1973 Debug board (V2+)  From the dmesg information:
	[15767.673553] usb 1-1: new full-speed USB device number 11 using xhci_hcd [15767.</description>
    </item>
    
  </channel>
</rss>